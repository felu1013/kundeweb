{"ast":null,"code":"var _AuthService_instances, _AuthService_handleLogin;\n\nimport { __classPrivateFieldGet } from \"tslib\";\nimport { first, tap } from 'rxjs/operators';\nimport { Subject } from 'rxjs';\nimport log from 'loglevel';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./jwt.service\";\nimport * as i2 from \"./storage.service\";\nexport const ROLLE_ADMIN = 'admin'; // Spring Security:\n// export const ROLLE_ADMIN = 'ROLE_ADMIN'\n\nexport class AuthService {\n  constructor(jwtService, storageService) {\n    this.jwtService = jwtService;\n    this.storageService = storageService;\n\n    _AuthService_instances.add(this); // in RxJS: Observables = Event-Streaming mit Promises\n    // Subject statt Basisklasse Observable: in login() und logout() wird next() aufgerufen\n    // Suffix \"$\" wird als \"Finnish Notation\" bezeichnet https://medium.com/@benlesh/observables-and-finnish-notation-df8356ed1c9b\n\n\n    this.isLoggedIn$ = new Subject(); // public fuer z.B. nav.component mit der Property isAdmin\n\n    this.rollen$ = new Subject(); // OnInit ist nur bei @Component moeglich\n\n    if (this.isLoggedIn) {\n      log.debug('AuthService.constructor: bereits eingeloggt');\n      this.isLoggedIn$.next(true);\n      const rollen = this.roles;\n\n      if (rollen.length > 0) {\n        log.debug('AuthService.constructor: rollen=', rollen);\n        this.rollen$.next(rollen);\n      }\n\n      return;\n    }\n\n    log.debug('AuthService.constructor: noch nicht eingeloggt');\n    this.isLoggedIn$.next(false);\n  }\n  /**\r\n   * @param username als String\r\n   * @param password als String\r\n   * @return void\r\n   */\n\n\n  login(username, password) {\n    log.debug(`AuthService.login: username=${username}, password=${password}`);\n    this.jwtService.login(username, password).pipe( // den 1. Datensatz empfangen und danach implizites \"unsubscribe\"\n    first(), tap(result => __classPrivateFieldGet(this, _AuthService_instances, \"m\", _AuthService_handleLogin).call(this, result))).subscribe();\n  }\n  /**\r\n   * @return void\r\n   */\n\n\n  logout() {\n    log.debug('AuthService.logout()');\n    this.storageService.deleteAuthorization();\n    this.isLoggedIn$.next(false);\n    this.rollen$.next([]);\n  }\n  /**\r\n   * @return String fuer JWT oder Basic-Authentifizierung\r\n   */\n\n\n  get authorization() {\n    return this.storageService.authorization;\n  }\n  /**\r\n   * Statische Abfrage, z.B. beim Start des Browsers, wenn noch kein\r\n   * Click-Ereignis eingetreten ist.\r\n   * @return true, falls ein User eingeloggt ist; sonst false.\r\n   */\n\n\n  get isLoggedIn() {\n    return this.storageService.authorization !== undefined;\n  }\n  /**\r\n   * Statische Abfrage, z.B. beim Start des Browsers, wenn noch kein\r\n   * Click-Ereignis eingetreten ist oder bei der Anzeige des Suchergebnisses.\r\n   * @return true, falls ein User in der Rolle \"admin\" eingeloggt ist;\r\n   *         sonst false.\r\n   */\n\n\n  get isAdmin() {\n    return this.storageService.roles.includes(ROLLE_ADMIN);\n  }\n  /**\r\n   * Statische Abfrage, z.B. beim Start des Browsers, wenn noch kein\r\n   * Click-Ereignis eingetreten ist oder bei der Anzeige des Suchergebnisses.\r\n   * @return Array der vorhandenen Rollen.\r\n   */\n\n\n  get roles() {\n    return this.storageService.roles;\n  }\n\n}\n_AuthService_instances = new WeakSet(), _AuthService_handleLogin = function _AuthService_handleLogin(result) {\n  log.debug('AuthService.login: result', result);\n\n  if (result === undefined) {\n    this.isLoggedIn$.next(false);\n    this.rollen$.next([]);\n  } else {\n    this.isLoggedIn$.next(true);\n    this.rollen$.next(result);\n  }\n};\n\nAuthService.ɵfac = function AuthService_Factory(t) {\n  return new (t || AuthService)(i0.ɵɵinject(i1.JwtService), i0.ɵɵinject(i2.StorageService));\n};\n\nAuthService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: AuthService,\n  factory: AuthService.ɵfac,\n  providedIn: 'root'\n});","map":null,"metadata":{},"sourceType":"module"}