{"ast":null,"code":"import JSBI from 'jsbi';\nconst INTRINSICS = {};\nconst customUtilInspectFormatters = {\n  ['Temporal.Duration'](depth, options) {\n    const descr = options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n    if (depth < 1) return descr;\n    const entries = [];\n\n    for (const prop of ['years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds', 'milliseconds', 'microseconds', 'nanoseconds']) {\n      if (this[prop] !== 0) entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n    }\n\n    return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n  }\n\n};\n\nfunction defaultUtilInspectFormatter(depth, options) {\n  return options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n}\n\nfunction MakeIntrinsicClass(Class, name) {\n  Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n    value: name,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n  {\n    Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n      value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n\n  for (const prop of Object.getOwnPropertyNames(Class)) {\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class, prop);\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class, prop, desc);\n  }\n\n  for (const prop of Object.getOwnPropertyNames(Class.prototype)) {\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop);\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class.prototype, prop, desc);\n  }\n\n  DefineIntrinsic(name, Class);\n  DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\n\nfunction DefineIntrinsic(name, value) {\n  const key = `%${name}%`;\n  if (INTRINSICS[key] !== undefined) throw new Error(`intrinsic ${name} already exists`);\n  INTRINSICS[key] = value;\n}\n\nfunction GetIntrinsic(intrinsic) {\n  return INTRINSICS[intrinsic];\n} // Instant\n\n\nconst EPOCHNANOSECONDS = 'slot-epochNanoSeconds'; // TimeZone\n\nconst TIMEZONE_ID = 'slot-timezone-identifier'; // DateTime, Date, Time, YearMonth, MonthDay\n\nconst ISO_YEAR = 'slot-year';\nconst ISO_MONTH = 'slot-month';\nconst ISO_DAY = 'slot-day';\nconst ISO_HOUR = 'slot-hour';\nconst ISO_MINUTE = 'slot-minute';\nconst ISO_SECOND = 'slot-second';\nconst ISO_MILLISECOND = 'slot-millisecond';\nconst ISO_MICROSECOND = 'slot-microsecond';\nconst ISO_NANOSECOND = 'slot-nanosecond';\nconst CALENDAR = 'slot-calendar'; // Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\n\nconst DATE_BRAND = 'slot-date-brand';\nconst YEAR_MONTH_BRAND = 'slot-year-month-brand';\nconst MONTH_DAY_BRAND = 'slot-month-day-brand'; // ZonedDateTime\n\nconst INSTANT = 'slot-cached-instant';\nconst TIME_ZONE = 'slot-time-zone'; // Duration\n\nconst YEARS = 'slot-years';\nconst MONTHS = 'slot-months';\nconst WEEKS = 'slot-weeks';\nconst DAYS = 'slot-days';\nconst HOURS = 'slot-hours';\nconst MINUTES = 'slot-minutes';\nconst SECONDS = 'slot-seconds';\nconst MILLISECONDS = 'slot-milliseconds';\nconst MICROSECONDS = 'slot-microseconds';\nconst NANOSECONDS = 'slot-nanoseconds'; // Calendar\n\nconst CALENDAR_ID = 'slot-calendar-identifier';\nconst slots = new WeakMap();\n\nfunction CreateSlots(container) {\n  slots.set(container, Object.create(null));\n}\n\nfunction GetSlots(container) {\n  return slots.get(container);\n}\n\nfunction HasSlot(container, ...ids) {\n  if (!container || 'object' !== typeof container) return false;\n  const myslots = GetSlots(container);\n  return !!myslots && ids.reduce((all, id) => all && id in myslots, true);\n}\n\nfunction GetSlot(container, id) {\n  const value = GetSlots(container)[id];\n  if (value === undefined) throw new TypeError(`Missing internal slot ${id}`);\n  return value;\n}\n\nfunction SetSlot(container, id, value) {\n  GetSlots(container)[id] = value;\n}\n\nconst ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush$2 = Array.prototype.push;\nconst IntlDateTimeFormat$2 = globalThis.Intl.DateTimeFormat;\nconst ArraySort = Array.prototype.sort;\nconst MathAbs$1 = Math.abs;\nconst MathFloor$1 = Math.floor;\nconst ObjectEntries = Object.entries;\nconst ObjectKeys = Object.keys;\n/**\n * Implementations for each calendar. Non-ISO calendars have an extra `helper`\n * property that provides additional per-calendar logic.\n */\n\nconst impl = {};\n/**\n * Thin wrapper around the implementation of each built-in calendar. This\n * class's methods follow a similar pattern:\n * 1. Validate parameters\n * 2. Fill in default options (for methods where options are present)\n * 3. Simplify and/or normalize parameters. For example, some methods accept\n *    PlainDate, PlainDateTime, ZonedDateTime, etc. and these are normalized to\n *    PlainDate.\n * 4. Look up the ID of the built-in calendar\n * 5. Fetch the implementation object for that ID.\n * 6. Call the corresponding method in the implementation object.\n */\n\nclass Calendar {\n  constructor(idParam) {\n    // Note: if the argument is not passed, IsBuiltinCalendar(\"undefined\") will fail. This check\n    //       exists only to improve the error message.\n    if (arguments.length < 1) {\n      throw new RangeError('missing argument: id is required');\n    }\n\n    const id = ToString(idParam);\n    if (!IsBuiltinCalendar(id)) throw new RangeError(`invalid calendar identifier ${id}`);\n    CreateSlots(this);\n    SetSlot(this, CALENDAR_ID, id);\n    {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${id}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  get id() {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return ToString(this);\n  }\n\n  dateFromFields(fields, optionsParam = undefined) {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsObject(fields)) throw new TypeError('invalid fields');\n    const options = GetOptionsObject(optionsParam);\n    return impl[GetSlot(this, CALENDAR_ID)].dateFromFields(fields, options, this);\n  }\n\n  yearMonthFromFields(fields, optionsParam = undefined) {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsObject(fields)) throw new TypeError('invalid fields');\n    const options = GetOptionsObject(optionsParam);\n    return impl[GetSlot(this, CALENDAR_ID)].yearMonthFromFields(fields, options, this);\n  }\n\n  monthDayFromFields(fields, optionsParam = undefined) {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsObject(fields)) throw new TypeError('invalid fields');\n    const options = GetOptionsObject(optionsParam);\n    return impl[GetSlot(this, CALENDAR_ID)].monthDayFromFields(fields, options, this);\n  }\n\n  fields(fields) {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const fieldsArray = [];\n    const allowed = new Set(['year', 'month', 'monthCode', 'day', 'hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond']);\n\n    for (const name of fields) {\n      if (typeof name !== 'string') throw new TypeError('invalid fields');\n      if (!allowed.has(name)) throw new RangeError(`invalid field name ${name}`);\n      allowed.delete(name);\n      ArrayPrototypePush$2.call(fieldsArray, name);\n    }\n\n    return impl[GetSlot(this, CALENDAR_ID)].fields(fieldsArray);\n  }\n\n  mergeFields(fields, additionalFields) {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return impl[GetSlot(this, CALENDAR_ID)].mergeFields(fields, additionalFields);\n  }\n\n  dateAdd(dateParam, durationParam, optionsParam = undefined) {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ToTemporalDate(dateParam);\n    const duration = ToTemporalDuration(durationParam);\n    const options = GetOptionsObject(optionsParam);\n    const overflow = ToTemporalOverflow(options);\n    const {\n      days\n    } = BalanceDuration(GetSlot(duration, DAYS), GetSlot(duration, HOURS), GetSlot(duration, MINUTES), GetSlot(duration, SECONDS), GetSlot(duration, MILLISECONDS), GetSlot(duration, MICROSECONDS), GetSlot(duration, NANOSECONDS), 'day');\n    return impl[GetSlot(this, CALENDAR_ID)].dateAdd(date, GetSlot(duration, YEARS), GetSlot(duration, MONTHS), GetSlot(duration, WEEKS), days, overflow, this);\n  }\n\n  dateUntil(oneParam, twoParam, optionsParam = undefined) {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const one = ToTemporalDate(oneParam);\n    const two = ToTemporalDate(twoParam);\n    const options = GetOptionsObject(optionsParam);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'], 'day');\n    const {\n      years,\n      months,\n      weeks,\n      days\n    } = impl[GetSlot(this, CALENDAR_ID)].dateUntil(one, two, largestUnit);\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  }\n\n  year(dateParam) {\n    let date = dateParam;\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsTemporalYearMonth(date)) date = ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].year(date);\n  }\n\n  month(dateParam) {\n    let date = dateParam;\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (IsTemporalMonthDay(date)) throw new TypeError('use monthCode on PlainMonthDay instead');\n    if (!IsTemporalYearMonth(date)) date = ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].month(date);\n  }\n\n  monthCode(dateParam) {\n    let date = dateParam;\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsTemporalYearMonth(date) && !IsTemporalMonthDay(date)) date = ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].monthCode(date);\n  }\n\n  day(dateParam) {\n    let date = dateParam;\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsTemporalMonthDay(date)) date = ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].day(date);\n  }\n\n  era(dateParam) {\n    let date = dateParam;\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsTemporalYearMonth(date)) date = ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].era(date);\n  }\n\n  eraYear(dateParam) {\n    let date = dateParam;\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsTemporalYearMonth(date)) date = ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].eraYear(date);\n  }\n\n  dayOfWeek(dateParam) {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].dayOfWeek(date);\n  }\n\n  dayOfYear(dateParam) {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].dayOfYear(date);\n  }\n\n  weekOfYear(dateParam) {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].weekOfYear(date);\n  }\n\n  daysInWeek(dateParam) {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    const date = ToTemporalDate(dateParam);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInWeek(date);\n  }\n\n  daysInMonth(dateParam) {\n    let date = dateParam;\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsTemporalYearMonth(date)) date = ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInMonth(date);\n  }\n\n  daysInYear(dateParam) {\n    let date = dateParam;\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsTemporalYearMonth(date)) date = ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].daysInYear(date);\n  }\n\n  monthsInYear(dateParam) {\n    let date = dateParam;\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsTemporalYearMonth(date)) date = ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].monthsInYear(date);\n  }\n\n  inLeapYear(dateParam) {\n    let date = dateParam;\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    if (!IsTemporalYearMonth(date)) date = ToTemporalDate(date);\n    return impl[GetSlot(this, CALENDAR_ID)].inLeapYear(date);\n  }\n\n  toString() {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR_ID);\n  }\n\n  toJSON() {\n    if (!IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n    return ToString(this);\n  }\n\n  static from(item) {\n    return ToTemporalCalendar(item);\n  }\n\n}\n\nMakeIntrinsicClass(Calendar, 'Temporal.Calendar');\nDefineIntrinsic('Temporal.Calendar.from', Calendar.from);\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\n\nimpl['iso8601'] = {\n  dateFromFields(fieldsParam, options, calendar) {\n    const overflow = ToTemporalOverflow(options);\n    let fields = PrepareTemporalFields(fieldsParam, [['day'], ['month', undefined], ['monthCode', undefined], ['year']]);\n    fields = resolveNonLunisolarMonth(fields);\n    let {\n      year,\n      month,\n      day\n    } = fields;\n    ({\n      year,\n      month,\n      day\n    } = RegulateISODate(year, month, day, overflow));\n    return CreateTemporalDate(year, month, day, calendar);\n  },\n\n  yearMonthFromFields(fieldsParam, options, calendar) {\n    const overflow = ToTemporalOverflow(options);\n    let fields = PrepareTemporalFields(fieldsParam, [['month', undefined], ['monthCode', undefined], ['year']]);\n    fields = resolveNonLunisolarMonth(fields);\n    let {\n      year,\n      month\n    } = fields;\n    ({\n      year,\n      month\n    } = RegulateISOYearMonth(year, month, overflow));\n    return CreateTemporalYearMonth(year, month, calendar,\n    /* referenceISODay = */\n    1);\n  },\n\n  monthDayFromFields(fieldsParam, options, calendar) {\n    const overflow = ToTemporalOverflow(options);\n    let fields = PrepareTemporalFields(fieldsParam, [['day'], ['month', undefined], ['monthCode', undefined], ['year', undefined]]);\n\n    if (fields.month !== undefined && fields.year === undefined && fields.monthCode === undefined) {\n      throw new TypeError('either year or monthCode required with month');\n    }\n\n    const useYear = fields.monthCode === undefined;\n    const referenceISOYear = 1972;\n    fields = resolveNonLunisolarMonth(fields);\n    let {\n      month,\n      day,\n      year\n    } = fields;\n    ({\n      month,\n      day\n    } = RegulateISODate(useYear ? year : referenceISOYear, month, day, overflow));\n    return CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n  },\n\n  fields(fields) {\n    return fields;\n  },\n\n  mergeFields(fields, additionalFields) {\n    const merged = {};\n\n    for (const nextKey of ObjectKeys(fields)) {\n      if (nextKey === 'month' || nextKey === 'monthCode') continue;\n      merged[nextKey] = fields[nextKey];\n    }\n\n    const newKeys = ObjectKeys(additionalFields);\n\n    for (const nextKey of newKeys) {\n      merged[nextKey] = additionalFields[nextKey];\n    }\n\n    if (!ArrayIncludes.call(newKeys, 'month') && !ArrayIncludes.call(newKeys, 'monthCode')) {\n      const {\n        month,\n        monthCode\n      } = fields;\n      if (month !== undefined) merged.month = month;\n      if (monthCode !== undefined) merged.monthCode = monthCode;\n    }\n\n    return merged;\n  },\n\n  dateAdd(date, years, months, weeks, days, overflow, calendar) {\n    let year = GetSlot(date, ISO_YEAR);\n    let month = GetSlot(date, ISO_MONTH);\n    let day = GetSlot(date, ISO_DAY);\n    ({\n      year,\n      month,\n      day\n    } = AddISODate(year, month, day, years, months, weeks, days, overflow));\n    return CreateTemporalDate(year, month, day, calendar);\n  },\n\n  dateUntil(one, two, largestUnit) {\n    return DifferenceISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY), largestUnit);\n  },\n\n  year(date) {\n    return GetSlot(date, ISO_YEAR);\n  },\n\n  era() {\n    return undefined;\n  },\n\n  eraYear() {\n    return undefined;\n  },\n\n  month(date) {\n    return GetSlot(date, ISO_MONTH);\n  },\n\n  monthCode(date) {\n    return buildMonthCode(GetSlot(date, ISO_MONTH));\n  },\n\n  day(date) {\n    return GetSlot(date, ISO_DAY);\n  },\n\n  dayOfWeek(date) {\n    return DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n  },\n\n  dayOfYear(date) {\n    return DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n  },\n\n  weekOfYear(date) {\n    return WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n  },\n\n  daysInWeek() {\n    return 7;\n  },\n\n  daysInMonth(date) {\n    return ISODaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));\n  },\n\n  daysInYear(dateParam) {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ToTemporalDate(date);\n    return LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;\n  },\n\n  monthsInYear() {\n    return 12;\n  },\n\n  inLeapYear(dateParam) {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ToTemporalDate(date);\n    return LeapYear(GetSlot(date, ISO_YEAR));\n  }\n\n};\n\nfunction monthCodeNumberPart(monthCode) {\n  if (!monthCode.startsWith('M')) {\n    throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n  }\n\n  const month = +monthCode.slice(1);\n  if (isNaN(month)) throw new RangeError(`Invalid month code: ${monthCode}`);\n  return month;\n}\n\nfunction buildMonthCode(month, leap = false) {\n  return `M${month.toString().padStart(2, '0')}${leap ? 'L' : ''}`;\n}\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\n\n\nfunction resolveNonLunisolarMonth(calendarDate, overflow = undefined, monthsPerYear = 12) {\n  let {\n    month,\n    monthCode\n  } = calendarDate;\n\n  if (monthCode === undefined) {\n    if (month === undefined) throw new TypeError('Either month or monthCode are required'); // The ISO calendar uses the default (undefined) value because it does\n    // constrain/reject after this method returns. Non-ISO calendars, however,\n    // rely on this function to constrain/reject out-of-range `month` values.\n\n    if (overflow === 'reject') RejectToRange(month, 1, monthsPerYear);\n    if (overflow === 'constrain') month = ConstrainToRange(month, 1, monthsPerYear);\n    monthCode = buildMonthCode(month);\n  } else {\n    const numberPart = monthCodeNumberPart(monthCode);\n\n    if (month !== undefined && month !== numberPart) {\n      throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n    }\n\n    if (monthCode !== buildMonthCode(numberPart)) {\n      throw new RangeError(`Invalid month code: ${monthCode}`);\n    }\n\n    month = numberPart;\n    if (month < 1 || month > monthsPerYear) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n  }\n\n  return { ...calendarDate,\n    month,\n    monthCode\n  };\n}\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\n\n\nclass OneObjectCache {\n  constructor(cacheToClone) {\n    this.map = new Map();\n    this.calls = 0;\n    this.hits = 0;\n    this.misses = 0;\n    this.now = globalThis.performance ? globalThis.performance.now() : Date.now();\n\n    if (cacheToClone !== undefined) {\n      let i = 0;\n\n      for (const entry of cacheToClone.map.entries()) {\n        if (++i > OneObjectCache.MAX_CACHE_ENTRIES) break;\n        this.map.set(...entry);\n      }\n    }\n  }\n\n  get(key) {\n    const result = this.map.get(key);\n\n    if (result) {\n      this.hits++;\n      this.report();\n    }\n\n    this.calls++;\n    return result;\n  }\n\n  set(key, value) {\n    this.map.set(key, value);\n    this.misses++;\n    this.report();\n  }\n\n  report() {\n    /*\n    if (this.calls === 0) return;\n    const ms = (globalThis.performance ? globalThis.performance.now() : Date.now()) - this.now;\n    const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n    console.log(`${this.calls} calls in ${ms.toFixed(2)}ms. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n    */\n  }\n\n  setObject(obj) {\n    if (OneObjectCache.objectMap.get(obj)) throw new RangeError('object already cached');\n    OneObjectCache.objectMap.set(obj, this);\n    this.report();\n  }\n  /**\n   * Returns a WeakMap-backed cache that's used to store expensive results\n   * that are associated with a particular Temporal object instance.\n   *\n   * @param obj - object to associate with the cache\n   */\n\n\n  static getCacheForObject(obj) {\n    let cache = OneObjectCache.objectMap.get(obj);\n\n    if (!cache) {\n      cache = new OneObjectCache();\n      OneObjectCache.objectMap.set(obj, cache);\n    }\n\n    return cache;\n  }\n\n}\n\nOneObjectCache.objectMap = new WeakMap();\nOneObjectCache.MAX_CACHE_ENTRIES = 1000;\n\nfunction toUtcIsoDateString({\n  isoYear,\n  isoMonth,\n  isoDay\n}) {\n  const yearString = ISOYearString(isoYear);\n  const monthString = ISODateTimePartString(isoMonth);\n  const dayString = ISODateTimePartString(isoDay);\n  return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\n\nfunction simpleDateDiff(one, two) {\n  return {\n    years: one.year - two.year,\n    months: one.month - two.month,\n    days: one.day - two.day\n  };\n}\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\n\n\nclass HelperBase {\n  constructor() {\n    // The short era format works for all calendars except Japanese, which will\n    // override.\n    this.eraLength = 'short'; // All built-in calendars except Chinese/Dangi and Hebrew use an era\n\n    this.hasEra = true;\n  }\n\n  getFormatter() {\n    // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n    // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n    // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n    // calendars that are used. Note that the nonIsoHelperBase object is spread\n    // into each each calendar's implementation before any cache is created, so\n    // each calendar gets its own separate cached formatter.\n    if (typeof this.formatter === 'undefined') {\n      this.formatter = new IntlDateTimeFormat$2(`en-US-u-ca-${this.id}`, {\n        day: 'numeric',\n        month: 'numeric',\n        year: 'numeric',\n        era: this.eraLength,\n        timeZone: 'UTC'\n      });\n    }\n\n    return this.formatter;\n  }\n\n  isoToCalendarDate(isoDate, cache) {\n    const {\n      year: isoYear,\n      month: isoMonth,\n      day: isoDay\n    } = isoDate;\n    const key = JSON.stringify({\n      func: 'isoToCalendarDate',\n      isoYear,\n      isoMonth,\n      isoDay,\n      id: this.id\n    });\n    const cached = cache.get(key);\n    if (cached) return cached;\n    const dateTimeFormat = this.getFormatter();\n    let parts, isoString;\n\n    try {\n      isoString = toUtcIsoDateString({\n        isoYear,\n        isoMonth,\n        isoDay\n      });\n      parts = dateTimeFormat.formatToParts(new Date(isoString));\n    } catch (e) {\n      throw new RangeError(`Invalid ISO date: ${JSON.stringify({\n        isoYear,\n        isoMonth,\n        isoDay\n      })}`);\n    }\n\n    const result = {};\n\n    for (let {\n      type,\n      value\n    } of parts) {\n      if (type === 'year') result.eraYear = +value; // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n\n      if (type === 'relatedYear') result.eraYear = +value;\n\n      if (type === 'month') {\n        const matches = /^([0-9]*)(.*?)$/.exec(value);\n\n        if (!matches || matches.length != 3 || !matches[1] && !matches[2]) {\n          throw new RangeError(`Unexpected month: ${value}`);\n        } // If the month has no numeric part (should only see this for the Hebrew\n        // calendar with newer FF / Chromium versions; see\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n        // placeholder month index of `1` and rely on the derived class to\n        // calculate the correct month index from the month name stored in\n        // `monthExtra`.\n\n\n        result.month = matches[1] ? +matches[1] : 1;\n\n        if (result.month < 1) {\n          throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` + ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)');\n        }\n\n        if (result.month > 13) {\n          throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` + ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n        } // The ICU formats for the Hebrew calendar no longer support a numeric\n        // month format. So we'll rely on the derived class to interpret it.\n        // `monthExtra` is also used on the Chinese calendar to handle a suffix\n        // \"bis\" indicating a leap month.\n\n\n        if (matches[2]) result.monthExtra = matches[2];\n      }\n\n      if (type === 'day') result.day = +value;\n\n      if (this.hasEra && type === 'era' && value != null && value !== '') {\n        // The convention for Temporal era values is lowercase, so following\n        // that convention in this prototype. Punctuation is removed, accented\n        // letters are normalized, and spaces are replaced with dashes.\n        // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En’ō\" => \"eno\"\n        // The call to normalize() and the replacement regex deals with era\n        // names that contain non-ASCII characters like Japanese eras. Also\n        // ignore extra content in parentheses like JPN era date ranges.\n        value = value.split(' (')[0];\n        result.era = value.normalize('NFD').replace(/[^-0-9 \\p{L}]/gu, '').replace(' ', '-').toLowerCase();\n      }\n    }\n\n    if (result.eraYear === undefined) {\n      // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n      // output of Intl.DateTimeFormat.formatToParts.\n      throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n    } // Translate eras that may be handled differently by Temporal vs. by Intl\n    // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n\n\n    if (this.reviseIntlEra) {\n      const {\n        era,\n        eraYear\n      } = this.reviseIntlEra(result, isoDate);\n      result.era = era;\n      result.eraYear = eraYear;\n    }\n\n    if (this.checkIcuBugs) this.checkIcuBugs(isoDate);\n    const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n    if (calendarDate.year === undefined) throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n    if (calendarDate.month === undefined) throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n    if (calendarDate.day === undefined) throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n    cache.set(key, calendarDate); // Also cache the reverse mapping\n\n    ['constrain', 'reject'].forEach(overflow => {\n      const keyReverse = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: calendarDate.year,\n        month: calendarDate.month,\n        day: calendarDate.day,\n        overflow,\n        id: this.id\n      });\n      cache.set(keyReverse, isoDate);\n    });\n    return calendarDate;\n  }\n\n  validateCalendarDate(calendarDate) {\n    const {\n      era,\n      month,\n      year,\n      day,\n      eraYear,\n      monthCode,\n      monthExtra\n    } = calendarDate; // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n    // the derived class must deal with it.\n\n    if (monthExtra !== undefined) throw new RangeError('Unexpected `monthExtra` value');\n    if (year === undefined && eraYear === undefined) throw new TypeError('year or eraYear is required');\n    if (month === undefined && monthCode === undefined) throw new TypeError('month or monthCode is required');\n    if (day === undefined) throw new RangeError('Missing day');\n\n    if (monthCode !== undefined) {\n      if (typeof monthCode !== 'string') {\n        throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n      }\n\n      if (!/^M([01]?\\d)(L?)$/.test(monthCode)) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n    }\n\n    if (this.constantEra) {\n      if (era !== undefined && era !== this.constantEra) {\n        throw new RangeError(`era must be ${this.constantEra}, not ${era}`);\n      }\n\n      if (eraYear !== undefined && year !== undefined && eraYear !== year) {\n        throw new RangeError(`eraYear ${eraYear} does not match year ${year}`);\n      }\n    }\n  }\n  /**\n   * Allows derived calendars to add additional fields and/or to make\n   * adjustments e.g. to set the era based on the date or to revise the month\n   * number in lunisolar calendars per\n   * https://github.com/tc39/proposal-temporal/issues/1203.\n   *\n   * The base implementation fills in missing values by assuming the simplest\n   * possible calendar:\n   * - no eras or a constant era defined in `.constantEra`\n   * - non-lunisolar calendar (no leap months)\n   * */\n\n\n  adjustCalendarDate(calendarDateParam, cache = undefined, overflow = 'constrain', // This param is only used by derived classes\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  fromLegacyDate = false) {\n    if (this.calendarType === 'lunisolar') throw new RangeError('Override required for lunisolar calendars');\n    let calendarDate = calendarDateParam;\n    this.validateCalendarDate(calendarDate); // For calendars that always use the same era, set it here so that derived\n    // calendars won't need to implement this method simply to set the era.\n\n    if (this.constantEra) {\n      // year and eraYear always match when there's only one possible era\n      const {\n        year,\n        eraYear\n      } = calendarDate;\n      calendarDate = { ...calendarDate,\n        era: this.constantEra,\n        year: year !== undefined ? year : eraYear,\n        eraYear: eraYear !== undefined ? eraYear : year\n      };\n    }\n\n    const largestMonth = this.monthsInYear(calendarDate, cache);\n    let {\n      month,\n      monthCode\n    } = calendarDate;\n    ({\n      month,\n      monthCode\n    } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n    return { ...calendarDate,\n      month,\n      monthCode\n    };\n  }\n\n  regulateMonthDayNaive(calendarDate, overflow, cache) {\n    const largestMonth = this.monthsInYear(calendarDate, cache);\n    let {\n      month,\n      day\n    } = calendarDate;\n\n    if (overflow === 'reject') {\n      RejectToRange(month, 1, largestMonth);\n      RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n    } else {\n      month = ConstrainToRange(month, 1, largestMonth);\n      day = ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate,\n        month\n      }));\n    }\n\n    return { ...calendarDate,\n      month,\n      day\n    };\n  }\n\n  calendarToIsoDate(dateParam, overflow = 'constrain', cache) {\n    const originalDate = dateParam; // First, normalize the calendar date to ensure that (year, month, day)\n    // are all present, converting monthCode and eraYear if needed.\n\n    let date = this.adjustCalendarDate(dateParam, cache, overflow, false); // Fix obviously out-of-bounds values. Values that are valid generally, but\n    // not in this particular year, may not be caught here for some calendars.\n    // If so, these will be handled lower below.\n\n    date = this.regulateMonthDayNaive(date, overflow, cache);\n    const {\n      year,\n      month,\n      day\n    } = date;\n    const key = JSON.stringify({\n      func: 'calendarToIsoDate',\n      year,\n      month,\n      day,\n      overflow,\n      id: this.id\n    });\n    let cached = cache.get(key);\n    if (cached) return cached; // If YMD are present in the input but the input has been constrained\n    // already, then cache both the original value and the constrained value.\n\n    let keyOriginal;\n\n    if (originalDate.year !== undefined && originalDate.month !== undefined && originalDate.day !== undefined && (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)) {\n      keyOriginal = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: originalDate.year,\n        month: originalDate.month,\n        day: originalDate.day,\n        overflow,\n        id: this.id\n      });\n      cached = cache.get(keyOriginal);\n      if (cached) return cached;\n    } // First, try to roughly guess the result\n\n\n    let isoEstimate = this.estimateIsoDate({\n      year,\n      month,\n      day\n    });\n\n    const calculateSameMonthResult = diffDays => {\n      // If the estimate is in the same year & month as the target, then we can\n      // calculate the result exactly and short-circuit any additional logic.\n      // This optimization assumes that months are continuous. It would break if\n      // a calendar skipped days, like the Julian->Gregorian switchover. But the\n      // only ICU calendars that currently skip days (japanese/roc/buddhist) is\n      // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n      // that's currently detected by `checkIcuBugs()` which will throw. So\n      // this optimization should be safe for all ICU calendars.\n      let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n\n      if (date.day > this.minimumMonthLength(date)) {\n        // There's a chance that the calendar date is out of range. Throw or\n        // constrain if so.\n        let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n\n        while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n          if (overflow === 'reject') {\n            throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n          } // Back up a day at a time until we're not hanging over the month end\n\n\n          testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n          testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n        }\n      }\n\n      return testIsoEstimate;\n    };\n\n    let sign = 0;\n    let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n    let diff = simpleDateDiff(date, roundtripEstimate);\n\n    if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n      const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n      isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      diff = simpleDateDiff(date, roundtripEstimate);\n\n      if (diff.years === 0 && diff.months === 0) {\n        isoEstimate = calculateSameMonthResult(diff.days);\n      } else {\n        sign = this.compareCalendarDates(date, roundtripEstimate);\n      }\n    } // If the initial guess is not in the same month, then then bisect the\n    // distance to the target, starting with 8 days per step.\n\n\n    let increment = 8;\n    let maybeConstrained = false;\n\n    while (sign) {\n      isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n      const oldRoundtripEstimate = roundtripEstimate;\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      const oldSign = sign;\n      sign = this.compareCalendarDates(date, roundtripEstimate);\n\n      if (sign) {\n        diff = simpleDateDiff(date, roundtripEstimate);\n\n        if (diff.years === 0 && diff.months === 0) {\n          isoEstimate = calculateSameMonthResult(diff.days); // Signal the loop condition that there's a match.\n\n          sign = 0; // If the calendar day is larger than the minimal length for this\n          // month, then it might be larger than the actual length of the month.\n          // So we won't cache it as the correct calendar date for this ISO\n          // date.\n\n          maybeConstrained = date.day > this.minimumMonthLength(date);\n        } else if (oldSign && sign !== oldSign) {\n          if (increment > 1) {\n            // If the estimate overshot the target, try again with a smaller increment\n            // in the reverse direction.\n            increment /= 2;\n          } else {\n            // Increment is 1, and neither the previous estimate nor the new\n            // estimate is correct. The only way that can happen is if the\n            // original date was an invalid value that will be constrained or\n            // rejected here.\n            if (overflow === 'reject') {\n              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate\n              })}`);\n            } else {\n              // To constrain, pick the earliest value\n              const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate); // If current value is larger, then back up to the previous value.\n\n              if (order > 0) isoEstimate = this.addDaysIso(isoEstimate, -1);\n              maybeConstrained = true;\n              sign = 0;\n            }\n          }\n        }\n      }\n    }\n\n    cache.set(key, isoEstimate);\n    if (keyOriginal) cache.set(keyOriginal, isoEstimate);\n\n    if (date.year === undefined || date.month === undefined || date.day === undefined || date.monthCode === undefined || this.hasEra && (date.era === undefined || date.eraYear === undefined)) {\n      throw new RangeError('Unexpected missing property');\n    }\n\n    if (!maybeConstrained) {\n      // Also cache the reverse mapping\n      const keyReverse = JSON.stringify({\n        func: 'isoToCalendarDate',\n        isoYear: isoEstimate.year,\n        isoMonth: isoEstimate.month,\n        isoDay: isoEstimate.day,\n        id: this.id\n      });\n      cache.set(keyReverse, date);\n    }\n\n    return isoEstimate;\n  }\n\n  temporalToCalendarDate(date, cache) {\n    const isoDate = {\n      year: GetSlot(date, ISO_YEAR),\n      month: GetSlot(date, ISO_MONTH),\n      day: GetSlot(date, ISO_DAY)\n    };\n    const result = this.isoToCalendarDate(isoDate, cache);\n    return result;\n  }\n\n  compareCalendarDates(date1Param, date2Param) {\n    // `date1` and `date2` are already records. The calls below simply validate\n    // that all three required fields are present.\n    const date1 = PrepareTemporalFields(date1Param, [['day'], ['month'], ['year']]);\n    const date2 = PrepareTemporalFields(date2Param, [['day'], ['month'], ['year']]);\n    if (date1.year !== date2.year) return ComparisonResult(date1.year - date2.year);\n    if (date1.month !== date2.month) return ComparisonResult(date1.month - date2.month);\n    if (date1.day !== date2.day) return ComparisonResult(date1.day - date2.day);\n    return 0;\n  }\n  /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n\n\n  regulateDate(calendarDate, overflow = 'constrain', cache) {\n    const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n    return this.isoToCalendarDate(isoDate, cache);\n  }\n\n  addDaysIso(isoDate, days) {\n    const added = AddISODate(isoDate.year, isoDate.month, isoDate.day, 0, 0, 0, days, 'constrain');\n    return added;\n  }\n\n  addDaysCalendar(calendarDate, days, cache) {\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIso = this.addDaysIso(isoDate, days);\n    const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n    return addedCalendar;\n  }\n\n  addMonthsCalendar(calendarDateParam, months, overflow, cache) {\n    let calendarDate = calendarDateParam;\n    const {\n      day\n    } = calendarDate;\n\n    for (let i = 0, absMonths = MathAbs$1(months); i < absMonths; i++) {\n      const {\n        month\n      } = calendarDate;\n      const oldCalendarDate = calendarDate;\n      const days = months < 0 ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache)) : this.daysInMonth(calendarDate, cache);\n      const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n      let addedIso = this.addDaysIso(isoDate, days);\n      calendarDate = this.isoToCalendarDate(addedIso, cache); // Normally, we can advance one month by adding the number of days in the\n      // current month. However, if we're at the end of the current month and\n      // the next month has fewer days, then we rolled over to the after-next\n      // month. Below we detect this condition and back up until we're back in\n      // the desired month.\n\n      if (months > 0) {\n        const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n\n        while (calendarDate.month - 1 !== month % monthsInOldYear) {\n          addedIso = this.addDaysIso(addedIso, -1);\n          calendarDate = this.isoToCalendarDate(addedIso, cache);\n        }\n      }\n\n      if (calendarDate.day !== day) {\n        // try to retain the original day-of-month, if possible\n        calendarDate = this.regulateDate({ ...calendarDate,\n          day\n        }, 'constrain', cache);\n      }\n    }\n\n    if (overflow === 'reject' && calendarDate.day !== day) {\n      throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n    }\n\n    return calendarDate;\n  }\n\n  addCalendar(calendarDate, {\n    years = 0,\n    months = 0,\n    weeks = 0,\n    days = 0\n  }, overflow, cache) {\n    const {\n      year,\n      month,\n      day\n    } = calendarDate;\n    const addedMonths = this.addMonthsCalendar({\n      year: year + years,\n      month,\n      day\n    }, months, overflow, cache);\n    const initialDays = days + weeks * 7;\n    const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n    return addedDays;\n  }\n\n  untilCalendar(calendarOne, calendarTwo, largestUnit, cache) {\n    let days = 0;\n    let weeks = 0;\n    let months = 0;\n    let years = 0;\n\n    switch (largestUnit) {\n      case 'day':\n        days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n        break;\n\n      case 'week':\n        {\n          const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n          days = totalDays % 7;\n          weeks = (totalDays - days) / 7;\n          break;\n        }\n\n      case 'month':\n      case 'year':\n        {\n          const diffYears = calendarTwo.year - calendarOne.year;\n          const diffMonths = calendarTwo.month - calendarOne.month;\n          const diffDays = calendarTwo.day - calendarOne.day;\n          const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n\n          if (largestUnit === 'year' && diffYears) {\n            const isOneFurtherInYear = diffMonths * sign < 0 || diffMonths === 0 && diffDays * sign < 0;\n            years = isOneFurtherInYear ? diffYears - sign : diffYears;\n          }\n\n          const yearsAdded = years ? this.addCalendar(calendarOne, {\n            years\n          }, 'constrain', cache) : calendarOne; // Now we have less than one year remaining. Add one month at a time\n          // until we go over the target, then back up one month and calculate\n          // remaining days and weeks.\n\n          let current;\n          let next = yearsAdded;\n\n          do {\n            months += sign;\n            current = next;\n            next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n\n            if (next.day !== calendarOne.day) {\n              // In case the day was constrained down, try to un-constrain it\n              next = this.regulateDate({ ...next,\n                day: calendarOne.day\n              }, 'constrain', cache);\n            }\n          } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n\n          months -= sign; // correct for loop above which overshoots by 1\n\n          const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n          days = remainingDays;\n          break;\n        }\n    }\n\n    return {\n      years,\n      months,\n      weeks,\n      days\n    };\n  }\n\n  daysInMonth(calendarDate, cache) {\n    // Add enough days to roll over to the next month. One we're in the next\n    // month, we can calculate the length of the current month. NOTE: This\n    // algorithm assumes that months are continuous. It would break if a\n    // calendar skipped days, like the Julian->Gregorian switchover. But the\n    // only ICU calendars that currently skip days (japanese/roc/buddhist) is a\n    // bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n    // that's currently detected by `checkIcuBugs()` which will throw. So this\n    // code should be safe for all ICU calendars.\n    const {\n      day\n    } = calendarDate;\n    const max = this.maximumMonthLength(calendarDate);\n    const min = this.minimumMonthLength(calendarDate); // easiest case: we already know the month length if min and max are the same.\n\n    if (min === max) return min; // Add enough days to get into the next month, without skipping it\n\n    const increment = day <= max - min ? max : min;\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIsoDate = this.addDaysIso(isoDate, increment);\n    const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache); // Now back up to the last day of the original month\n\n    const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n    const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n    return endOfMonthCalendar.day;\n  }\n\n  daysInPreviousMonth(calendarDate, cache) {\n    const {\n      day,\n      month,\n      year\n    } = calendarDate; // Check to see if we already know the month length, and return it if so\n\n    const previousMonthYear = month > 1 ? year : year - 1;\n    let previousMonthDate = {\n      year: previousMonthYear,\n      month,\n      day: 1\n    };\n    const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n    previousMonthDate = { ...previousMonthDate,\n      month: previousMonth\n    };\n    const min = this.minimumMonthLength(previousMonthDate);\n    const max = this.maximumMonthLength(previousMonthDate);\n    if (min === max) return max;\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n    const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n    return lastDayOfPreviousMonthCalendar.day;\n  }\n\n  startOfCalendarYear(calendarDate) {\n    return {\n      year: calendarDate.year,\n      month: 1,\n      day: 1\n    };\n  }\n\n  startOfCalendarMonth(calendarDate) {\n    return {\n      year: calendarDate.year,\n      month: calendarDate.month,\n      day: 1\n    };\n  }\n\n  calendarDaysUntil(calendarOne, calendarTwo, cache) {\n    const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n    const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n    return this.isoDaysUntil(oneIso, twoIso);\n  }\n\n  isoDaysUntil(oneIso, twoIso) {\n    const duration = DifferenceISODate(oneIso.year, oneIso.month, oneIso.day, twoIso.year, twoIso.month, twoIso.day, 'day');\n    return duration.days;\n  }\n\n  monthDayFromFields(fields, overflow, cache) {\n    let {\n      year,\n      month,\n      monthCode,\n      day,\n      era,\n      eraYear\n    } = fields;\n\n    if (monthCode === undefined) {\n      if (year === undefined && (era === undefined || eraYear === undefined)) {\n        throw new TypeError('`monthCode`, `year`, or `era` and `eraYear` is required');\n      }\n\n      ({\n        monthCode,\n        year\n      } = this.adjustCalendarDate({\n        year,\n        month,\n        monthCode,\n        day,\n        era,\n        eraYear\n      }, cache, overflow));\n    }\n\n    let isoYear, isoMonth, isoDay;\n    let closestCalendar, closestIso; // Look backwards starting from the calendar year of 1972-01-01 up to 100\n    // calendar years to find a year that has this month and day. Normal months\n    // and days will match immediately, but for leap days and leap months we may\n    // have to look for a while.\n\n    const startDateIso = {\n      year: 1972,\n      month: 1,\n      day: 1\n    };\n    const {\n      year: calendarYear\n    } = this.isoToCalendarDate(startDateIso, cache);\n\n    for (let i = 0; i < 100; i++) {\n      const testCalendarDate = this.adjustCalendarDate({\n        day,\n        monthCode,\n        year: calendarYear - i\n      }, cache);\n      const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n      const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n      ({\n        year: isoYear,\n        month: isoMonth,\n        day: isoDay\n      } = isoDate);\n\n      if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n        return {\n          month: isoMonth,\n          day: isoDay,\n          year: isoYear\n        };\n      } else if (overflow === 'constrain') {\n        // non-ISO constrain algorithm tries to find the closest date in a matching month\n        if (closestCalendar === undefined || roundTripCalendarDate.monthCode === closestCalendar.monthCode && roundTripCalendarDate.day > closestCalendar.day) {\n          closestCalendar = roundTripCalendarDate;\n          closestIso = isoDate;\n        }\n      }\n    }\n\n    if (overflow === 'constrain' && closestIso !== undefined) return closestIso;\n    throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n  }\n\n}\n\nclass HebrewHelper extends HelperBase {\n  constructor() {\n    super(...arguments);\n    this.id = 'hebrew';\n    this.calendarType = 'lunisolar';\n    this.months = {\n      Tishri: {\n        leap: 1,\n        regular: 1,\n        monthCode: 'M01',\n        days: 30\n      },\n      Heshvan: {\n        leap: 2,\n        regular: 2,\n        monthCode: 'M02',\n        days: {\n          min: 29,\n          max: 30\n        }\n      },\n      Kislev: {\n        leap: 3,\n        regular: 3,\n        monthCode: 'M03',\n        days: {\n          min: 29,\n          max: 30\n        }\n      },\n      Tevet: {\n        leap: 4,\n        regular: 4,\n        monthCode: 'M04',\n        days: 29\n      },\n      Shevat: {\n        leap: 5,\n        regular: 5,\n        monthCode: 'M05',\n        days: 30\n      },\n      Adar: {\n        leap: undefined,\n        regular: 6,\n        monthCode: 'M06',\n        days: 29\n      },\n      'Adar I': {\n        leap: 6,\n        regular: undefined,\n        monthCode: 'M05L',\n        days: 30\n      },\n      'Adar II': {\n        leap: 7,\n        regular: undefined,\n        monthCode: 'M06',\n        days: 29\n      },\n      Nisan: {\n        leap: 8,\n        regular: 7,\n        monthCode: 'M07',\n        days: 30\n      },\n      Iyar: {\n        leap: 9,\n        regular: 8,\n        monthCode: 'M08',\n        days: 29\n      },\n      Sivan: {\n        leap: 10,\n        regular: 9,\n        monthCode: 'M09',\n        days: 30\n      },\n      Tamuz: {\n        leap: 11,\n        regular: 10,\n        monthCode: 'M10',\n        days: 29\n      },\n      Av: {\n        leap: 12,\n        regular: 11,\n        monthCode: 'M11',\n        days: 30\n      },\n      Elul: {\n        leap: 13,\n        regular: 12,\n        monthCode: 'M12',\n        days: 29\n      }\n    }; // All built-in calendars except Chinese/Dangi and Hebrew use an era\n\n    this.hasEra = false;\n  }\n\n  inLeapYear(calendarDate) {\n    const {\n      year\n    } = calendarDate; // FYI: In addition to adding a month in leap years, the Hebrew calendar\n    // also has per-year changes to the number of days of Heshvan and Kislev.\n    // Given that these can be calculated by counting the number of days in\n    // those months, I assume that these DO NOT need to be exposed as\n    // Hebrew-only prototype fields or methods.\n\n    return (7 * year + 1) % 19 < 7;\n  }\n\n  monthsInYear(calendarDate) {\n    return this.inLeapYear(calendarDate) ? 13 : 12;\n  }\n\n  minimumMonthLength(calendarDate) {\n    return this.minMaxMonthLength(calendarDate, 'min');\n  }\n\n  maximumMonthLength(calendarDate) {\n    return this.minMaxMonthLength(calendarDate, 'max');\n  }\n\n  minMaxMonthLength(calendarDate, minOrMax) {\n    const {\n      month,\n      year\n    } = calendarDate;\n    const monthCode = this.getMonthCode(year, month);\n    const monthInfo = ObjectEntries(this.months).find(m => m[1].monthCode === monthCode);\n    if (monthInfo === undefined) throw new RangeError(`unmatched Hebrew month: ${month}`);\n    const daysInMonth = monthInfo[1].days;\n    return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n  }\n  /** Take a guess at what ISO date a particular calendar date corresponds to */\n\n\n  estimateIsoDate(calendarDate) {\n    const {\n      year\n    } = calendarDate;\n    return {\n      year: year - 3760,\n      month: 1,\n      day: 1\n    };\n  }\n\n  getMonthCode(year, month) {\n    if (this.inLeapYear({\n      year\n    })) {\n      return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n    } else {\n      return buildMonthCode(month);\n    }\n  }\n\n  adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n    // The incoming type is actually CalendarDate (same as args to\n    // Calendar.dateFromParams) but TS isn't smart enough to follow all the\n    // reassignments below, so as an alternative to 10+ type casts, we'll lie\n    // here and claim that the type has `day` and `year` filled in already.\n    let {\n      year,\n      eraYear,\n      month,\n      monthCode,\n      day,\n      monthExtra\n    } = calendarDate;\n    if (year === undefined && eraYear !== undefined) year = eraYear;\n    if (eraYear === undefined && year !== undefined) eraYear = year;\n\n    if (fromLegacyDate) {\n      // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n      // output returns the numeric equivalent of `month` as a string, meaning\n      // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n      // means Adar. In this case, `month` will already be correct and no action\n      // is needed. However, in Node 14 and later formatToParts returns the name\n      // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n      // correct `month` using the string name as a key.\n      if (monthExtra) {\n        const monthInfo = this.months[monthExtra];\n        if (!monthInfo) throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n        month = this.inLeapYear({\n          year\n        }) ? monthInfo.leap : monthInfo.regular;\n      } // Because we're getting data from legacy Date, then `month` will always be present\n\n\n      monthCode = this.getMonthCode(year, month);\n      const result = {\n        year,\n        month: month,\n        day,\n        era: undefined,\n        eraYear,\n        monthCode\n      };\n      return result;\n    } else {\n      // When called without input coming from legacy Date output, simply ensure\n      // that all fields are present.\n      this.validateCalendarDate(calendarDate);\n\n      if (month === undefined) {\n        if (monthCode.endsWith('L')) {\n          if (monthCode !== 'M05L') {\n            throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n          }\n\n          month = 6;\n\n          if (!this.inLeapYear({\n            year\n          })) {\n            if (overflow === 'reject') {\n              throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n            } else {\n              // constrain to last day of previous month (Av)\n              month = 5;\n              day = 30;\n              monthCode = 'M05';\n            }\n          }\n        } else {\n          month = monthCodeNumberPart(monthCode); // if leap month is before this one, the month index is one more than the month code\n\n          if (this.inLeapYear({\n            year\n          }) && month > 6) month++;\n          const largestMonth = this.monthsInYear({\n            year\n          });\n          if (month < 1 || month > largestMonth) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n      } else {\n        if (overflow === 'reject') {\n          RejectToRange(month, 1, this.monthsInYear({\n            year\n          }));\n          RejectToRange(day, 1, this.maximumMonthLength({\n            year,\n            month\n          }));\n        } else {\n          month = ConstrainToRange(month, 1, this.monthsInYear({\n            year\n          }));\n          day = ConstrainToRange(day, 1, this.maximumMonthLength({\n            year,\n            month\n          }));\n        }\n\n        if (monthCode === undefined) {\n          monthCode = this.getMonthCode(year, month);\n        } else {\n          const calculatedMonthCode = this.getMonthCode(year, month);\n\n          if (calculatedMonthCode !== monthCode) {\n            throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n          }\n        }\n      }\n\n      return { ...calendarDate,\n        day,\n        month,\n        monthCode: monthCode,\n        year,\n        eraYear\n      };\n    }\n  }\n\n}\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\n\n\nclass IslamicBaseHelper extends HelperBase {\n  constructor() {\n    super(...arguments);\n    this.calendarType = 'lunar';\n    this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n    this.DAYS_PER_ISO_YEAR = 365.2425;\n    this.constantEra = 'ah';\n  }\n\n  inLeapYear(calendarDate, cache) {\n    // In leap years, the 12th month has 30 days. In non-leap years: 29.\n    const days = this.daysInMonth({\n      year: calendarDate.year,\n      month: 12,\n      day: 1\n    }, cache);\n    return days === 30;\n  }\n\n  monthsInYear() {\n    return 12;\n  }\n\n  minimumMonthLength() {\n    return 29;\n  }\n\n  maximumMonthLength() {\n    return 30;\n  }\n\n  estimateIsoDate(calendarDate) {\n    const {\n      year\n    } = this.adjustCalendarDate(calendarDate);\n    return {\n      year: MathFloor$1(year * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR) + 622,\n      month: 1,\n      day: 1\n    };\n  }\n\n} // There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\n\n\nclass IslamicHelper extends IslamicBaseHelper {\n  constructor() {\n    super(...arguments);\n    this.id = 'islamic';\n  }\n\n}\n\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n  constructor() {\n    super(...arguments);\n    this.id = 'islamic-umalqura';\n  }\n\n}\n\nclass IslamicTblaHelper extends IslamicBaseHelper {\n  constructor() {\n    super(...arguments);\n    this.id = 'islamic-tbla';\n  }\n\n}\n\nclass IslamicCivilHelper extends IslamicBaseHelper {\n  constructor() {\n    super(...arguments);\n    this.id = 'islamic-civil';\n  }\n\n}\n\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n  constructor() {\n    super(...arguments);\n    this.id = 'islamic-rgsa';\n  }\n\n}\n\nclass IslamicCcHelper extends IslamicBaseHelper {\n  constructor() {\n    super(...arguments);\n    this.id = 'islamicc';\n  }\n\n}\n\nclass PersianHelper extends HelperBase {\n  constructor() {\n    super(...arguments);\n    this.id = 'persian';\n    this.calendarType = 'solar';\n    this.constantEra = 'ap';\n  }\n\n  inLeapYear(calendarDate, cache) {\n    // Same logic (count days in the last month) for Persian as for Islamic,\n    // even though Persian is solar and Islamic is lunar.\n    return IslamicHelper.prototype.inLeapYear.call(this, calendarDate, cache);\n  }\n\n  monthsInYear() {\n    return 12;\n  }\n\n  minimumMonthLength(calendarDate) {\n    const {\n      month\n    } = calendarDate;\n    if (month === 12) return 29;\n    return month <= 6 ? 31 : 30;\n  }\n\n  maximumMonthLength(calendarDate) {\n    const {\n      month\n    } = calendarDate;\n    if (month === 12) return 30;\n    return month <= 6 ? 31 : 30;\n  }\n\n  estimateIsoDate(calendarDate) {\n    const {\n      year\n    } = this.adjustCalendarDate(calendarDate);\n    return {\n      year: year + 621,\n      month: 1,\n      day: 1\n    };\n  }\n\n}\n\nclass IndianHelper extends HelperBase {\n  constructor() {\n    super(...arguments);\n    this.id = 'indian';\n    this.calendarType = 'solar';\n    this.constantEra = 'saka'; // Indian months always start at the same well-known Gregorian month and\n    // day. So this conversion is easy and fast. See\n    // https://en.wikipedia.org/wiki/Indian_national_calendar\n\n    this.months = {\n      1: {\n        length: 30,\n        month: 3,\n        day: 22,\n        leap: {\n          length: 31,\n          month: 3,\n          day: 21\n        }\n      },\n      2: {\n        length: 31,\n        month: 4,\n        day: 21\n      },\n      3: {\n        length: 31,\n        month: 5,\n        day: 22\n      },\n      4: {\n        length: 31,\n        month: 6,\n        day: 22\n      },\n      5: {\n        length: 31,\n        month: 7,\n        day: 23\n      },\n      6: {\n        length: 31,\n        month: 8,\n        day: 23\n      },\n      7: {\n        length: 30,\n        month: 9,\n        day: 23\n      },\n      8: {\n        length: 30,\n        month: 10,\n        day: 23\n      },\n      9: {\n        length: 30,\n        month: 11,\n        day: 22\n      },\n      10: {\n        length: 30,\n        month: 12,\n        day: 22\n      },\n      11: {\n        length: 30,\n        month: 1,\n        nextYear: true,\n        day: 21\n      },\n      12: {\n        length: 30,\n        month: 2,\n        nextYear: true,\n        day: 20\n      }\n    }; // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n    // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n    // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n    // expected.\n\n    this.vulnerableToBceBug = new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', {\n      timeZone: 'UTC'\n    }) !== '10/11/-79 Saka';\n  }\n\n  inLeapYear(calendarDate) {\n    // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n    // Years are counted in the Saka era, which starts its year 0 in the year 78\n    // of the Common Era. To determine leap years, add 78 to the Saka year – if\n    // the result is a leap year in the Gregorian calendar, then the Saka year\n    // is a leap year as well.\n    return isGregorianLeapYear(calendarDate.year + 78);\n  }\n\n  monthsInYear() {\n    return 12;\n  }\n\n  minimumMonthLength(calendarDate) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n\n  maximumMonthLength(calendarDate) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n\n  getMonthInfo(calendarDate) {\n    const {\n      month\n    } = calendarDate;\n    let monthInfo = this.months[month];\n    if (monthInfo === undefined) throw new RangeError(`Invalid month: ${month}`);\n    if (this.inLeapYear(calendarDate) && monthInfo.leap) monthInfo = monthInfo.leap;\n    return monthInfo;\n  }\n\n  estimateIsoDate(calendarDateParam) {\n    // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n    // calendar fast!\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const monthInfo = this.getMonthInfo(calendarDate);\n    const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n    const isoMonth = monthInfo.month;\n    const isoDay = monthInfo.day;\n    const isoDate = AddISODate(isoYear, isoMonth, isoDay, 0, 0, 0, calendarDate.day - 1, 'constrain');\n    return isoDate;\n  }\n\n  checkIcuBugs(isoDate) {\n    if (this.vulnerableToBceBug && isoDate.year < 1) {\n      throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01` + ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n    }\n  }\n\n}\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\n\n\nfunction adjustEras(erasParam) {\n  let eras = erasParam;\n\n  if (eras.length === 0) {\n    throw new RangeError('Invalid era data: eras are required');\n  }\n\n  if (eras.length === 1 && eras[0].reverseOf) {\n    throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n  }\n\n  if (eras.length === 1 && !eras[0].name) {\n    throw new RangeError('Invalid era data: at least one named era is required');\n  }\n\n  if (eras.filter(e => e.reverseOf != null).length > 1) {\n    throw new RangeError('Invalid era data: only one era can count years backwards');\n  } // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n  // eras can never be anchors. The era without an `anchorEpoch` property is the\n  // anchor.\n\n\n  let anchorEra;\n  eras.forEach(e => {\n    if (e.isAnchor || !e.anchorEpoch && !e.reverseOf) {\n      if (anchorEra) throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n      anchorEra = e;\n      e.anchorEpoch = {\n        year: e.hasYearZero ? 0 : 1\n      };\n    } else if (!e.name) {\n      throw new RangeError('If era name is blank, it must be the anchor era');\n    }\n  }); // If the era name is undefined, then it's an anchor that doesn't interact\n  // with eras at all. For example, Japanese `year` is always the same as ISO\n  // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n  // Strip it from the list that's returned.\n\n  eras = eras.filter(e => e.name);\n  eras.forEach(e => {\n    // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n    // Replace the string-valued \"reverseOf\" property with the actual era object\n    // that's reversed.\n    const {\n      reverseOf\n    } = e;\n\n    if (reverseOf) {\n      const reversedEra = eras.find(era => era.name === reverseOf);\n      if (reversedEra === undefined) throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n      e.reverseOf = reversedEra;\n      e.anchorEpoch = reversedEra.anchorEpoch;\n      e.isoEpoch = reversedEra.isoEpoch;\n    }\n\n    if (e.anchorEpoch.month === undefined) e.anchorEpoch.month = 1;\n    if (e.anchorEpoch.day === undefined) e.anchorEpoch.day = 1;\n  }); // Ensure that the latest epoch is first in the array. This lets us try to\n  // match eras in index order, with the last era getting the remaining older\n  // years. Any reverse-signed era must be at the end.\n\n  ArraySort.call(eras, (e1, e2) => {\n    if (e1.reverseOf) return 1;\n    if (e2.reverseOf) return -1;\n    if (!e1.isoEpoch || !e2.isoEpoch) throw new RangeError('Invalid era data: missing ISO epoch');\n    return e2.isoEpoch.year - e1.isoEpoch.year;\n  }); // If there's a reversed era, then the one before it must be the era that's\n  // being reversed.\n\n  const lastEraReversed = eras[eras.length - 1].reverseOf;\n\n  if (lastEraReversed) {\n    if (lastEraReversed !== eras[eras.length - 2]) throw new RangeError('Invalid era data: invalid reverse-sign era');\n  } // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n  // zero-based index, with the oldest era being zero. This format is used by\n  // older versions of ICU data.\n\n\n  eras.forEach((e, i) => {\n    e.genericName = `era${eras.length - 1 - i}`;\n  });\n  return {\n    eras: eras,\n    anchorEra: anchorEra || eras[0]\n  };\n}\n\nfunction isGregorianLeapYear(year) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n/** Base for all Gregorian-like calendars. */\n\n\nclass GregorianBaseHelper extends HelperBase {\n  constructor(id, originalEras) {\n    super();\n    this.calendarType = 'solar'; // Several calendars based on the Gregorian calendar use Julian dates (not\n    // proleptic Gregorian dates) before the Julian switchover in Oct 1582. See\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n\n    this.v8IsVulnerableToJulianBug = new Date('+001001-01-01T00:00Z').toLocaleDateString('en-US-u-ca-japanese', {\n      timeZone: 'UTC'\n    }).startsWith('12');\n    this.calendarIsVulnerableToJulianBug = false;\n    this.id = id;\n    const {\n      eras,\n      anchorEra\n    } = adjustEras(originalEras);\n    this.anchorEra = anchorEra;\n    this.eras = eras;\n  }\n\n  inLeapYear(calendarDate) {\n    // Calendars that don't override this method use the same months and leap\n    // years as Gregorian. Once we know the ISO year corresponding to the\n    // calendar year, we'll know if it's a leap year or not.\n    const {\n      year\n    } = this.estimateIsoDate({\n      month: 1,\n      day: 1,\n      year: calendarDate.year\n    });\n    return isGregorianLeapYear(year);\n  }\n\n  monthsInYear() {\n    return 12;\n  }\n\n  minimumMonthLength(calendarDate) {\n    const {\n      month\n    } = calendarDate;\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n  }\n\n  maximumMonthLength(calendarDate) {\n    return this.minimumMonthLength(calendarDate);\n  }\n  /** Fill in missing parts of the (year, era, eraYear) tuple */\n\n\n  completeEraYear(calendarDate) {\n    const checkField = (name, value) => {\n      const currentValue = calendarDate[name];\n\n      if (currentValue != null && currentValue != value) {\n        throw new RangeError(`Input ${name} ${currentValue} doesn't match calculated value ${value}`);\n      }\n    };\n\n    const eraFromYear = year => {\n      let eraYear;\n      const adjustedCalendarDate = { ...calendarDate,\n        year\n      };\n      const matchingEra = this.eras.find((e, i) => {\n        if (i === this.eras.length - 1) {\n          if (e.reverseOf) {\n            // This is a reverse-sign era (like BCE) which must be the oldest\n            // era. Count years backwards.\n            if (year > 0) throw new RangeError(`Signed year ${year} is invalid for era ${e.name}`);\n            eraYear = e.anchorEpoch.year - year;\n            return true;\n          } // last era always gets all \"leftover\" (older than epoch) years,\n          // so no need for a comparison like below.\n\n\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n\n        const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n\n        if (comparison >= 0) {\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n\n        return false;\n      });\n      if (!matchingEra) throw new RangeError(`Year ${year} was not matched by any era`);\n      return {\n        eraYear: eraYear,\n        era: matchingEra.name\n      };\n    };\n\n    let {\n      year,\n      eraYear,\n      era\n    } = calendarDate;\n\n    if (year != null) {\n      ({\n        eraYear,\n        era\n      } = eraFromYear(year));\n      checkField('era', era);\n      checkField('eraYear', eraYear);\n    } else if (eraYear != null) {\n      const matchingEra = era === undefined ? undefined : this.eras.find(e => e.name === era || e.genericName === era);\n      if (!matchingEra) throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n\n      if (eraYear < 1 && matchingEra.reverseOf) {\n        throw new RangeError(`Years in ${era} era must be positive, not ${year}`);\n      }\n\n      if (matchingEra.reverseOf) {\n        year = matchingEra.anchorEpoch.year - eraYear;\n      } else {\n        year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n      }\n\n      checkField('year', year); // We'll accept dates where the month/day is earlier than the start of\n      // the era or after its end as long as it's in the same year. If that\n      // happens, we'll adjust the era/eraYear pair to be the correct era for\n      // the `year`.\n\n      ({\n        eraYear,\n        era\n      } = eraFromYear(year));\n    } else {\n      throw new RangeError('Either `year` or `eraYear` and `era` are required');\n    }\n\n    return { ...calendarDate,\n      year,\n      eraYear,\n      era\n    };\n  }\n\n  adjustCalendarDate(calendarDateParam, cache, overflow = 'constrain') {\n    let calendarDate = calendarDateParam; // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n\n    const {\n      month,\n      monthCode\n    } = calendarDate;\n    if (month === undefined) calendarDate = { ...calendarDate,\n      month: monthCodeNumberPart(monthCode)\n    };\n    this.validateCalendarDate(calendarDate);\n    calendarDate = this.completeEraYear(calendarDate);\n    return super.adjustCalendarDate(calendarDate, cache, overflow);\n  }\n\n  estimateIsoDate(calendarDateParam) {\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const {\n      year,\n      month,\n      day\n    } = calendarDate;\n    const {\n      anchorEra\n    } = this;\n    const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n    return RegulateISODate(isoYearEstimate, month, day, 'constrain');\n  }\n\n  checkIcuBugs(isoDate) {\n    if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {\n      const beforeJulianSwitch = CompareISODate(isoDate.year, isoDate.month, isoDate.day, 1582, 10, 15) < 0;\n\n      if (beforeJulianSwitch) {\n        throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15` + ' (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)');\n      }\n    }\n  }\n\n}\n\nclass OrthodoxBaseHelper extends GregorianBaseHelper {\n  constructor(id, originalEras) {\n    super(id, originalEras);\n  }\n\n  inLeapYear(calendarDate) {\n    // Leap years happen one year before the Julian leap year. Note that this\n    // calendar is based on the Julian calendar which has a leap year every 4\n    // years, unlike the Gregorian calendar which doesn't have leap years on\n    // years divisible by 100 except years divisible by 400.\n    //\n    // Note that we're assuming that leap years in before-epoch times match\n    // how leap years are defined now. This is probably not accurate but I'm\n    // not sure how better to do it.\n    const {\n      year\n    } = calendarDate;\n    return (year + 1) % 4 === 0;\n  }\n\n  monthsInYear() {\n    return 13;\n  }\n\n  minimumMonthLength(calendarDate) {\n    const {\n      month\n    } = calendarDate; // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n\n    if (month === 13) return this.inLeapYear(calendarDate) ? 6 : 5;\n    return 30;\n  }\n\n  maximumMonthLength(calendarDate) {\n    return this.minimumMonthLength(calendarDate);\n  }\n\n} // `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\n\n\nclass EthioaaHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('ethioaa', [{\n      name: 'era0',\n      isoEpoch: {\n        year: -5492,\n        month: 7,\n        day: 17\n      }\n    }]);\n  }\n\n}\n\nclass CopticHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('coptic', [{\n      name: 'era1',\n      isoEpoch: {\n        year: 284,\n        month: 8,\n        day: 29\n      }\n    }, {\n      name: 'era0',\n      reverseOf: 'era1'\n    }]);\n  }\n\n} // Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\n\n\nclass EthiopicHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('ethiopic', [{\n      name: 'era0',\n      isoEpoch: {\n        year: -5492,\n        month: 7,\n        day: 17\n      }\n    }, {\n      name: 'era1',\n      isoEpoch: {\n        year: 8,\n        month: 8,\n        day: 27\n      },\n      anchorEpoch: {\n        year: 5501\n      }\n    }]);\n  }\n\n}\n\nclass RocHelper extends GregorianBaseHelper {\n  constructor() {\n    super('roc', [{\n      name: 'minguo',\n      isoEpoch: {\n        year: 1912,\n        month: 1,\n        day: 1\n      }\n    }, {\n      name: 'before-roc',\n      reverseOf: 'minguo'\n    }]);\n    this.calendarIsVulnerableToJulianBug = true;\n  }\n\n}\n\nclass BuddhistHelper extends GregorianBaseHelper {\n  constructor() {\n    super('buddhist', [{\n      name: 'be',\n      hasYearZero: true,\n      isoEpoch: {\n        year: -543,\n        month: 1,\n        day: 1\n      }\n    }]);\n    this.calendarIsVulnerableToJulianBug = true;\n  }\n\n}\n\nclass GregoryHelper extends GregorianBaseHelper {\n  constructor() {\n    super('gregory', [{\n      name: 'ce',\n      isoEpoch: {\n        year: 1,\n        month: 1,\n        day: 1\n      }\n    }, {\n      name: 'bce',\n      reverseOf: 'ce'\n    }]);\n  }\n\n  reviseIntlEra(calendarDate\n  /*, isoDate: IsoDate*/\n  ) {\n    let {\n      era,\n      eraYear\n    } = calendarDate; // Firefox 96 introduced a bug where the `'short'` format of the era\n    // option mistakenly returns the one-letter (narrow) format instead. The\n    // code below handles either the correct or Firefox-buggy format. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n\n    if (era === 'bc' || era === 'b') era = 'bce';\n    if (era === 'ad' || era === 'a') era = 'ce';\n    return {\n      era,\n      eraYear\n    };\n  }\n\n} // NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\n\n\nclass JapaneseHelper extends GregorianBaseHelper {\n  constructor() {\n    super('japanese', [// The Japanese calendar `year` is just the ISO year, because (unlike other\n    // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n    {\n      name: 'reiwa',\n      isoEpoch: {\n        year: 2019,\n        month: 5,\n        day: 1\n      },\n      anchorEpoch: {\n        year: 2019,\n        month: 5,\n        day: 1\n      }\n    }, {\n      name: 'heisei',\n      isoEpoch: {\n        year: 1989,\n        month: 1,\n        day: 8\n      },\n      anchorEpoch: {\n        year: 1989,\n        month: 1,\n        day: 8\n      }\n    }, {\n      name: 'showa',\n      isoEpoch: {\n        year: 1926,\n        month: 12,\n        day: 25\n      },\n      anchorEpoch: {\n        year: 1926,\n        month: 12,\n        day: 25\n      }\n    }, {\n      name: 'taisho',\n      isoEpoch: {\n        year: 1912,\n        month: 7,\n        day: 30\n      },\n      anchorEpoch: {\n        year: 1912,\n        month: 7,\n        day: 30\n      }\n    }, {\n      name: 'meiji',\n      isoEpoch: {\n        year: 1868,\n        month: 9,\n        day: 8\n      },\n      anchorEpoch: {\n        year: 1868,\n        month: 9,\n        day: 8\n      }\n    }, {\n      name: 'ce',\n      isoEpoch: {\n        year: 1,\n        month: 1,\n        day: 1\n      }\n    }, {\n      name: 'bce',\n      reverseOf: 'ce'\n    }]);\n    this.calendarIsVulnerableToJulianBug = true; // The last 3 Japanese eras confusingly return only one character in the\n    // default \"short\" era, so need to use the long format.\n\n    this.eraLength = 'long';\n  }\n\n  reviseIntlEra(calendarDate, isoDate) {\n    const {\n      era,\n      eraYear\n    } = calendarDate;\n    const {\n      year: isoYear\n    } = isoDate;\n    if (this.eras.find(e => e.name === era)) return {\n      era,\n      eraYear\n    };\n    return isoYear < 1 ? {\n      era: 'bce',\n      eraYear: 1 - isoYear\n    } : {\n      era: 'ce',\n      eraYear: isoYear\n    };\n  }\n\n}\n\nclass ChineseBaseHelper extends HelperBase {\n  constructor() {\n    super(...arguments);\n    this.calendarType = 'lunisolar'; // All built-in calendars except Chinese/Dangi and Hebrew use an era\n\n    this.hasEra = false;\n  }\n\n  inLeapYear(calendarDate, cache) {\n    const months = this.getMonthList(calendarDate.year, cache);\n    return ObjectEntries(months).length === 13;\n  }\n\n  monthsInYear(calendarDate, cache) {\n    return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n  }\n\n  minimumMonthLength() {\n    return 29;\n  }\n\n  maximumMonthLength() {\n    return 30;\n  }\n\n  getMonthList(calendarYear, cache) {\n    if (calendarYear === undefined) {\n      throw new TypeError('Missing year');\n    }\n\n    const key = JSON.stringify({\n      func: 'getMonthList',\n      calendarYear,\n      id: this.id\n    });\n    const cached = cache.get(key);\n    if (cached) return cached;\n    const dateTimeFormat = this.getFormatter();\n\n    const getCalendarDate = (isoYear, daysPastFeb1) => {\n      const isoStringFeb1 = toUtcIsoDateString({\n        isoYear,\n        isoMonth: 2,\n        isoDay: 1\n      });\n      const legacyDate = new Date(isoStringFeb1); // Now add the requested number of days, which may wrap to the next month.\n\n      legacyDate.setUTCDate(daysPastFeb1 + 1);\n      const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n      const calendarMonthString = newYearGuess.find(tv => tv.type === 'month').value;\n      const calendarDay = +newYearGuess.find(tv => tv.type === 'day').value;\n      let calendarYearToVerify = newYearGuess.find(tv => tv.type === 'relatedYear');\n\n      if (calendarYearToVerify !== undefined) {\n        calendarYearToVerify = +calendarYearToVerify.value;\n      } else {\n        // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n        // output of Intl.DateTimeFormat.formatToParts.\n        throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n      }\n\n      return {\n        calendarMonthString,\n        calendarDay,\n        calendarYearToVerify\n      };\n    }; // First, find a date close to Chinese New Year. Feb 17 will either be in\n    // the first month or near the end of the last month of the previous year.\n\n\n    let isoDaysDelta = 17;\n    let {\n      calendarMonthString,\n      calendarDay,\n      calendarYearToVerify\n    } = getCalendarDate(calendarYear, isoDaysDelta); // If we didn't guess the first month correctly, add (almost in some months)\n    // a lunar month\n\n    if (calendarMonthString !== '1') {\n      isoDaysDelta += 29;\n      ({\n        calendarMonthString,\n        calendarDay\n      } = getCalendarDate(calendarYear, isoDaysDelta));\n    } // Now back up to near the start of the first month, but not too near that\n    // off-by-one issues matter.\n\n\n    isoDaysDelta -= calendarDay - 5;\n    const result = {};\n    let monthIndex = 1;\n    let oldCalendarDay;\n    let oldMonthString;\n    let done = false;\n\n    do {\n      ({\n        calendarMonthString,\n        calendarDay,\n        calendarYearToVerify\n      } = getCalendarDate(calendarYear, isoDaysDelta));\n\n      if (oldCalendarDay) {\n        result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n      }\n\n      if (calendarYearToVerify !== calendarYear) {\n        done = true;\n      } else {\n        result[calendarMonthString] = {\n          monthIndex: monthIndex++\n        }; // Move to the next month. Because months are sometimes 29 days, the day of the\n        // calendar month will move forward slowly but not enough to flip over to a new\n        // month before the loop ends at 12-13 months.\n\n        isoDaysDelta += 30;\n      }\n\n      oldCalendarDay = calendarDay;\n      oldMonthString = calendarMonthString;\n    } while (!done);\n\n    result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n    cache.set(key, result);\n    return result;\n  }\n\n  estimateIsoDate(calendarDate) {\n    const {\n      year,\n      month\n    } = calendarDate;\n    return {\n      year,\n      month: month >= 12 ? 12 : month + 1,\n      day: 1\n    };\n  }\n\n  adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n    let {\n      year,\n      month,\n      monthExtra,\n      day,\n      monthCode,\n      eraYear\n    } = calendarDate;\n\n    if (fromLegacyDate) {\n      // Legacy Date output returns a string that's an integer with an optional\n      // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n      // month. Below we'll normalize the output.\n      year = eraYear;\n      if (monthExtra && monthExtra !== 'bis') throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n      const monthCode = buildMonthCode(month, monthExtra !== undefined);\n      const monthString = `${month}${monthExtra || ''}`;\n      const months = this.getMonthList(year, cache);\n      const monthInfo = months[monthString];\n      if (monthInfo === undefined) throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n      month = monthInfo.monthIndex;\n      return {\n        year: year,\n        month,\n        day: day,\n        era: undefined,\n        eraYear,\n        monthCode\n      };\n    } else {\n      // When called without input coming from legacy Date output,\n      // simply ensure that all fields are present.\n      this.validateCalendarDate(calendarDate);\n      if (year === undefined) year = eraYear;\n      if (eraYear === undefined) eraYear = year;\n\n      if (month === undefined) {\n        const months = this.getMonthList(year, cache);\n        let numberPart = monthCode.replace('L', 'bis').slice(1);\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        let monthInfo = months[numberPart];\n        month = monthInfo && monthInfo.monthIndex; // If this leap month isn't present in this year, constrain down to the last day of the previous month.\n\n        if (month === undefined && monthCode.endsWith('L') && !ArrayIncludes.call(['M01L', 'M12L', 'M13L'], monthCode) && overflow === 'constrain') {\n          let withoutML = monthCode.slice(1, -1);\n          if (withoutML[0] === '0') withoutML = withoutML.slice(1);\n          monthInfo = months[withoutML];\n\n          if (monthInfo) {\n            ({\n              daysInMonth: day,\n              monthIndex: month\n            } = monthInfo);\n            monthCode = buildMonthCode(withoutML);\n          }\n        }\n\n        if (month === undefined) {\n          throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n        }\n      } else if (monthCode === undefined) {\n        const months = this.getMonthList(year, cache);\n        const monthEntries = ObjectEntries(months);\n        const largestMonth = monthEntries.length;\n\n        if (overflow === 'reject') {\n          RejectToRange(month, 1, largestMonth);\n          RejectToRange(day, 1, this.maximumMonthLength());\n        } else {\n          month = ConstrainToRange(month, 1, largestMonth);\n          day = ConstrainToRange(day, 1, this.maximumMonthLength());\n        }\n\n        const matchingMonthEntry = monthEntries.find(([, v]) => v.monthIndex === month);\n\n        if (matchingMonthEntry === undefined) {\n          throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n        }\n\n        monthCode = buildMonthCode(matchingMonthEntry[0].replace('bis', ''), matchingMonthEntry[0].indexOf('bis') !== -1);\n      } else {\n        // Both month and monthCode are present. Make sure they don't conflict.\n        const months = this.getMonthList(year, cache);\n        let numberPart = monthCode.replace('L', 'bis').slice(1);\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        const monthInfo = months[numberPart];\n        if (!monthInfo) throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n\n        if (month !== monthInfo.monthIndex) {\n          throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n        }\n      }\n\n      return { ...calendarDate,\n        year: year,\n        eraYear,\n        month,\n        monthCode: monthCode,\n        day: day\n      };\n    }\n  }\n\n}\n\nclass ChineseHelper extends ChineseBaseHelper {\n  constructor() {\n    super(...arguments);\n    this.id = 'chinese';\n  }\n\n} // Dangi (Korean) calendar has same implementation as Chinese\n\n\nclass DangiHelper extends ChineseBaseHelper {\n  constructor() {\n    super(...arguments);\n    this.id = 'dangi';\n  }\n\n}\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\n\n\nconst nonIsoImpl = {\n  // `helper` is added when this object is spread into each calendar's\n  // implementation\n  helper: undefined,\n\n  dateFromFields(fieldsParam, options, calendar) {\n    const overflow = ToTemporalOverflow(options);\n    const cache = new OneObjectCache(); // Intentionally alphabetical\n\n    const fields = PrepareTemporalFields(fieldsParam, [['day'], ['era', undefined], ['eraYear', undefined], ['month', undefined], ['monthCode', undefined], ['year', undefined]]);\n    const {\n      year,\n      month,\n      day\n    } = this.helper.calendarToIsoDate(fields, overflow, cache);\n    const result = CreateTemporalDate(year, month, day, calendar);\n    cache.setObject(result);\n    return result;\n  },\n\n  yearMonthFromFields(fieldsParam, options, calendar) {\n    const overflow = ToTemporalOverflow(options);\n    const cache = new OneObjectCache(); // Intentionally alphabetical\n\n    const fields = PrepareTemporalFields(fieldsParam, [['era', undefined], ['eraYear', undefined], ['month', undefined], ['monthCode', undefined], ['year', undefined]]);\n    const {\n      year,\n      month,\n      day\n    } = this.helper.calendarToIsoDate({ ...fields,\n      day: 1\n    }, overflow, cache);\n    const result = CreateTemporalYearMonth(year, month, calendar,\n    /* referenceISODay = */\n    day);\n    cache.setObject(result);\n    return result;\n  },\n\n  monthDayFromFields(fieldsParam, options, calendar) {\n    const overflow = ToTemporalOverflow(options); // All built-in calendars require `day`, but some allow other fields to be\n    // substituted for `month`. And for lunisolar calendars, either `monthCode`\n    // or `year` must be provided because `month` is ambiguous without a year or\n    // a code.\n\n    const cache = new OneObjectCache();\n    const fields = PrepareTemporalFields(fieldsParam, [['day'], ['era', undefined], ['eraYear', undefined], ['month', undefined], ['monthCode', undefined], ['year', undefined]]);\n    const {\n      year,\n      month,\n      day\n    } = this.helper.monthDayFromFields(fields, overflow, cache); // `year` is a reference year where this month/day exists in this calendar\n\n    const result = CreateTemporalMonthDay(month, day, calendar,\n    /* referenceISOYear = */\n    year);\n    cache.setObject(result);\n    return result;\n  },\n\n  fields(fieldsParam) {\n    let fields = fieldsParam;\n    if (ArrayIncludes.call(fields, 'year')) fields = [...fields, 'era', 'eraYear'];\n    return fields;\n  },\n\n  mergeFields(fields, additionalFields) {\n    const fieldsCopy = { ...fields\n    };\n    const additionalFieldsCopy = { ...additionalFields\n    }; // era and eraYear are intentionally unused\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    const {\n      month,\n      monthCode,\n      year,\n      era,\n      eraYear,\n      ...original\n    } = fieldsCopy;\n    const {\n      month: newMonth,\n      monthCode: newMonthCode,\n      year: newYear,\n      era: newEra,\n      eraYear: newEraYear\n    } = additionalFieldsCopy;\n\n    if (newMonth === undefined && newMonthCode === undefined) {\n      original.month = month;\n      original.monthCode = monthCode;\n    }\n\n    if (newYear === undefined && newEra === undefined && newEraYear === undefined) {\n      // Only `year` is needed. We don't set era and eraYear because it's\n      // possible to create a conflict for eras that start or end mid-year. See\n      // https://github.com/tc39/proposal-temporal/issues/1784.\n      original.year = year;\n    }\n\n    return { ...original,\n      ...additionalFieldsCopy\n    };\n  },\n\n  dateAdd(date, years, months, weeks, days, overflow, calendar) {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const added = this.helper.addCalendar(calendarDate, {\n      years,\n      months,\n      weeks,\n      days\n    }, overflow, cache);\n    const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n    const {\n      year,\n      month,\n      day\n    } = isoAdded;\n    const newTemporalObject = CreateTemporalDate(year, month, day, calendar); // The new object's cache starts with the cache of the old object\n\n    const newCache = new OneObjectCache(cache);\n    newCache.setObject(newTemporalObject);\n    return newTemporalObject;\n  },\n\n  dateUntil(one, two, largestUnit) {\n    const cacheOne = OneObjectCache.getCacheForObject(one);\n    const cacheTwo = OneObjectCache.getCacheForObject(two);\n    const calendarOne = this.helper.temporalToCalendarDate(one, cacheOne);\n    const calendarTwo = this.helper.temporalToCalendarDate(two, cacheTwo);\n    const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n    return result;\n  },\n\n  year(date) {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.year;\n  },\n\n  month(date) {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.month;\n  },\n\n  day(date) {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.day;\n  },\n\n  era(date) {\n    if (!this.helper.hasEra) return undefined;\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.era;\n  },\n\n  eraYear(date) {\n    if (!this.helper.hasEra) return undefined;\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.eraYear;\n  },\n\n  monthCode(date) {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    return calendarDate.monthCode;\n  },\n\n  dayOfWeek(date) {\n    return impl['iso8601'].dayOfWeek(date);\n  },\n\n  dayOfYear(date) {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.isoToCalendarDate(date, cache);\n    const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n    const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n    return diffDays + 1;\n  },\n\n  weekOfYear(date) {\n    return impl['iso8601'].weekOfYear(date);\n  },\n\n  daysInWeek(date) {\n    return impl['iso8601'].daysInWeek(date);\n  },\n\n  daysInMonth(date) {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache); // Easy case: if the helper knows the length without any heavy calculation.\n\n    const max = this.helper.maximumMonthLength(calendarDate);\n    const min = this.helper.minimumMonthLength(calendarDate);\n    if (max === min) return max; // The harder case is where months vary every year, e.g. islamic calendars.\n    // Find the answer by calculating the difference in days between the first\n    // day of the current month and the first day of the next month.\n\n    const startOfMonthCalendar = this.helper.startOfCalendarMonth(calendarDate);\n    const startOfNextMonthCalendar = this.helper.addMonthsCalendar(startOfMonthCalendar, 1, 'constrain', cache);\n    const result = this.helper.calendarDaysUntil(startOfMonthCalendar, startOfNextMonthCalendar, cache);\n    return result;\n  },\n\n  daysInYear(dateParam) {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ToTemporalDate(date);\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n    const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, {\n      years: 1\n    }, 'constrain', cache);\n    const result = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n    return result;\n  },\n\n  monthsInYear(date) {\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const result = this.helper.monthsInYear(calendarDate, cache);\n    return result;\n  },\n\n  inLeapYear(dateParam) {\n    let date = dateParam;\n    if (!HasSlot(date, ISO_YEAR)) date = ToTemporalDate(date);\n    const cache = OneObjectCache.getCacheForObject(date);\n    const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n    const result = this.helper.inLeapYear(calendarDate, cache);\n    return result;\n  }\n\n};\n\nfor (const Helper of [HebrewHelper, PersianHelper, EthiopicHelper, EthioaaHelper, CopticHelper, ChineseHelper, DangiHelper, RocHelper, IndianHelper, BuddhistHelper, GregoryHelper, JapaneseHelper, IslamicHelper, IslamicUmalquraHelper, IslamicTblaHelper, IslamicCivilHelper, IslamicRgsaHelper, IslamicCcHelper]) {\n  const helper = new Helper(); // Clone the singleton non-ISO implementation that's the same for all\n  // calendars. The `helper` property contains per-calendar logic.\n\n  impl[helper.id] = { ...nonIsoImpl,\n    helper\n  };\n}\n\nconst BUILTIN_CALENDAR_IDS = Object.keys(impl);\n\nfunction IsBuiltinCalendar(id) {\n  return ArrayIncludes.call(BUILTIN_CALENDAR_IDS, id);\n}\n\nconst tzComponent = /\\.[-A-Za-z_]|\\.\\.[-A-Za-z._]{1,12}|\\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;\nconst offsetNoCapture = /(?:[+\\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\\d{1,9})?)?)?)/;\nconst timeZoneID = new RegExp(`(?:(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*|Etc/GMT[-+]\\\\d{1,2}|${offsetNoCapture.source})`);\nconst calComponent = /[A-Za-z0-9]{3,8}/;\nconst calendarID = new RegExp(`(?:${calComponent.source}(?:-${calComponent.source})*)`);\nconst yearpart = /(?:[+\\u2212-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(`(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nconst offset = /([+\\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nconst zonesplit = new RegExp(`(?:([zZ])|(?:${offset.source})?)(?:\\\\[(${timeZoneID.source})\\\\])?`);\nconst calendar = new RegExp(`\\\\[u-ca=(${calendarID.source})\\\\]`);\nconst zoneddatetime = new RegExp(`^${datesplit.source}(?:(?:T|\\\\s+)${timesplit.source})?${zonesplit.source}(?:${calendar.source})?$`, 'i');\nconst time = new RegExp(`^T?${timesplit.source}(?:${zonesplit.source})?(?:${calendar.source})?$`, 'i'); // The short forms of YearMonth and MonthDay are only for the ISO calendar.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\n\nconst yearmonth = new RegExp(`^(${yearpart.source})-?(${monthpart.source})$`);\nconst monthday = new RegExp(`^(?:--)?(${monthpart.source})-?(${daypart.source})$`);\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nconst duration = new RegExp(`^([+\\u2212-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\nconst ArrayPrototypePush$1 = Array.prototype.push;\nconst IntlDateTimeFormat$1 = globalThis.Intl.DateTimeFormat;\nconst MathMin = Math.min;\nconst MathMax = Math.max;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst MathSign = Math.sign;\nconst MathTrunc = Math.trunc;\nconst NumberIsNaN = Number.isNaN;\nconst NumberIsFinite = Number.isFinite;\nconst NumberCtor = Number;\nconst StringCtor = String;\nconst NumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nconst ObjectCreate$2 = Object.create;\nconst ObjectDefineProperty = Object.defineProperty;\nconst ObjectIs = Object.is;\nconst ReflectApply$1 = Reflect.apply;\nconst ZERO = JSBI.BigInt(0);\nconst ONE = JSBI.BigInt(1);\nconst SIXTY = JSBI.BigInt(60);\nconst THOUSAND = JSBI.BigInt(1e3);\nconst MILLION = JSBI.BigInt(1e6);\nconst BILLION = JSBI.BigInt(1e9);\nconst NEGATIVE_ONE = JSBI.BigInt(-1);\nconst DAY_SECONDS = 86400;\nconst DAY_NANOS = JSBI.multiply(JSBI.BigInt(DAY_SECONDS), BILLION);\nconst NS_MIN = JSBI.multiply(JSBI.BigInt(-86400), JSBI.BigInt(1e17));\nconst NS_MAX = JSBI.multiply(JSBI.BigInt(86400), JSBI.BigInt(1e17));\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_OFFSET_TRANSITION = JSBI.multiply(JSBI.BigInt(-388152), JSBI.BigInt(1e13)); // 1847-01-01T00:00:00Z\n\nconst ABOUT_TEN_YEARS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 10));\nconst ABOUT_ONE_YEAR_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 1));\nconst TWO_WEEKS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(2 * 7));\n\nfunction IsInteger(value) {\n  if (typeof value !== 'number' || !NumberIsFinite(value)) return false;\n  const abs = MathAbs(value);\n  return MathFloor(abs) === abs;\n}\n\nfunction IsObject(value) {\n  return typeof value === 'object' && value !== null || typeof value === 'function';\n}\n\nfunction ToNumber(value) {\n  if (typeof value === 'bigint') throw new TypeError('Cannot convert BigInt to number');\n  return NumberCtor(value);\n}\n\nfunction ToInteger(value) {\n  const num = ToNumber(value);\n  if (NumberIsNaN(num)) return 0;\n  const integer = MathTrunc(num);\n  if (num === 0) return 0;\n  return integer;\n}\n\nfunction ToString(value) {\n  if (typeof value === 'symbol') {\n    throw new TypeError('Cannot convert a Symbol value to a String');\n  }\n\n  return StringCtor(value);\n}\n\nfunction ToIntegerThrowOnInfinity(value) {\n  const integer = ToInteger(value);\n\n  if (!NumberIsFinite(integer)) {\n    throw new RangeError('infinity is out of range');\n  }\n\n  return integer;\n}\n\nfunction ToPositiveInteger(valueParam, property) {\n  const value = ToInteger(valueParam);\n\n  if (!NumberIsFinite(value)) {\n    throw new RangeError('infinity is out of range');\n  }\n\n  if (value < 1) {\n    if (property !== undefined) {\n      throw new RangeError(`property '${property}' cannot be a a number less than one`);\n    }\n\n    throw new RangeError('Cannot convert a number less than one to a positive integer');\n  }\n\n  return value;\n}\n\nfunction ToIntegerWithoutRounding(valueParam) {\n  const value = ToNumber(valueParam);\n  if (NumberIsNaN(value)) return 0;\n\n  if (!NumberIsFinite(value)) {\n    throw new RangeError('infinity is out of range');\n  }\n\n  if (!IsInteger(value)) {\n    throw new RangeError(`unsupported fractional value ${value}`);\n  }\n\n  return ToInteger(value); // ℝ(value) in spec text; converts -0 to 0\n}\n\nfunction divmod(x, y) {\n  const quotient = JSBI.divide(x, y);\n  const remainder = JSBI.remainder(x, y);\n  return {\n    quotient,\n    remainder\n  };\n}\n\nfunction abs(x) {\n  if (JSBI.lessThan(x, ZERO)) return JSBI.multiply(x, NEGATIVE_ONE);\n  return x;\n}\n\nconst BUILTIN_CASTS = new Map([['year', ToIntegerThrowOnInfinity], ['month', ToPositiveInteger], ['monthCode', ToString], ['day', ToPositiveInteger], ['hour', ToIntegerThrowOnInfinity], ['minute', ToIntegerThrowOnInfinity], ['second', ToIntegerThrowOnInfinity], ['millisecond', ToIntegerThrowOnInfinity], ['microsecond', ToIntegerThrowOnInfinity], ['nanosecond', ToIntegerThrowOnInfinity], ['years', ToIntegerWithoutRounding], ['months', ToIntegerWithoutRounding], ['weeks', ToIntegerWithoutRounding], ['days', ToIntegerWithoutRounding], ['hours', ToIntegerWithoutRounding], ['minutes', ToIntegerWithoutRounding], ['seconds', ToIntegerWithoutRounding], ['milliseconds', ToIntegerWithoutRounding], ['microseconds', ToIntegerWithoutRounding], ['nanoseconds', ToIntegerWithoutRounding], ['era', ToString], ['eraYear', ToInteger], ['offset', ToString]]);\nconst ALLOWED_UNITS = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'];\nconst SINGULAR_PLURAL_UNITS = [['years', 'year'], ['months', 'month'], ['weeks', 'week'], ['days', 'day'], ['hours', 'hour'], ['minutes', 'minute'], ['seconds', 'second'], ['milliseconds', 'millisecond'], ['microseconds', 'microsecond'], ['nanoseconds', 'nanosecond']];\nconst IntlDateTimeFormatEnUsCache = new Map();\n\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier) {\n  let instance = IntlDateTimeFormatEnUsCache.get(timeZoneIdentifier);\n\n  if (instance === undefined) {\n    instance = new IntlDateTimeFormat$1('en-us', {\n      timeZone: StringCtor(timeZoneIdentifier),\n      hour12: false,\n      era: 'short',\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n    IntlDateTimeFormatEnUsCache.set(timeZoneIdentifier, instance);\n  }\n\n  return instance;\n}\n\nfunction IsTemporalInstant(item) {\n  return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\n\nfunction IsTemporalTimeZone(item) {\n  return HasSlot(item, TIMEZONE_ID);\n}\n\nfunction IsTemporalCalendar(item) {\n  return HasSlot(item, CALENDAR_ID);\n}\n\nfunction IsTemporalDuration(item) {\n  return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\n\nfunction IsTemporalDate(item) {\n  return HasSlot(item, DATE_BRAND);\n}\n\nfunction IsTemporalTime(item) {\n  return HasSlot(item, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND) && !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY);\n}\n\nfunction IsTemporalDateTime(item) {\n  return HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND);\n}\n\nfunction IsTemporalYearMonth(item) {\n  return HasSlot(item, YEAR_MONTH_BRAND);\n}\n\nfunction IsTemporalMonthDay(item) {\n  return HasSlot(item, MONTH_DAY_BRAND);\n}\n\nfunction IsTemporalZonedDateTime(item) {\n  return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\n\nfunction RejectObjectWithCalendarOrTimeZone(item) {\n  if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n    throw new TypeError('with() does not support a calendar or timeZone property');\n  }\n\n  if (item.calendar !== undefined) {\n    throw new TypeError('with() does not support a calendar property');\n  }\n\n  if (item.timeZone !== undefined) {\n    throw new TypeError('with() does not support a timeZone property');\n  }\n}\n\nfunction ParseTemporalTimeZone(stringIdent) {\n  let {\n    ianaName,\n    offset,\n    z\n  } = ParseTemporalTimeZoneString(stringIdent);\n  if (ianaName) return ianaName;\n  if (z) return 'UTC';\n  return offset; // if !ianaName && !z then offset must be present\n}\n\nfunction FormatCalendarAnnotation(id, showCalendar) {\n  if (showCalendar === 'never') return '';\n  if (showCalendar === 'auto' && id === 'iso8601') return '';\n  return `[u-ca=${id}]`;\n}\n\nfunction ParseISODateTime(isoString) {\n  // ZDT is the superset of fields for every other Temporal type\n  const match = zoneddatetime.exec(isoString);\n  if (!match) throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n  let yearString = match[1];\n  if (yearString[0] === '\\u2212') yearString = `-${yearString.slice(1)}`;\n  if (yearString === '-000000') throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n  const year = ToInteger(yearString);\n  const month = ToInteger(match[2] || match[4]);\n  const day = ToInteger(match[3] || match[5]);\n  const hour = ToInteger(match[6]);\n  const hasTime = match[6] !== undefined;\n  const minute = ToInteger(match[7] || match[10]);\n  let second = ToInteger(match[8] || match[11]);\n  if (second === 60) second = 59;\n  const fraction = (match[9] || match[12]) + '000000000';\n  const millisecond = ToInteger(fraction.slice(0, 3));\n  const microsecond = ToInteger(fraction.slice(3, 6));\n  const nanosecond = ToInteger(fraction.slice(6, 9));\n  let offset;\n  let z = false;\n\n  if (match[13]) {\n    offset = undefined;\n    z = true;\n  } else if (match[14] && match[15]) {\n    const offsetSign = match[14] === '-' || match[14] === '\\u2212' ? '-' : '+';\n    const offsetHours = match[15] || '00';\n    const offsetMinutes = match[16] || '00';\n    const offsetSeconds = match[17] || '00';\n    let offsetFraction = match[18] || '0';\n    offset = `${offsetSign}${offsetHours}:${offsetMinutes}`;\n\n    if (+offsetFraction) {\n      while (offsetFraction.endsWith('0')) offsetFraction = offsetFraction.slice(0, -1);\n\n      offset += `:${offsetSeconds}.${offsetFraction}`;\n    } else if (+offsetSeconds) {\n      offset += `:${offsetSeconds}`;\n    }\n\n    if (offset === '-00:00') offset = '+00:00';\n  }\n\n  let ianaName = match[19];\n\n  if (ianaName) {\n    try {\n      // Canonicalize name if it is an IANA link name or is capitalized wrong\n      ianaName = GetCanonicalTimeZoneIdentifier(ianaName).toString();\n    } catch {// Not an IANA name, may be a custom ID, pass through unchanged\n    }\n  }\n\n  const calendar = match[20];\n  return {\n    year,\n    month,\n    day,\n    hasTime,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    ianaName,\n    offset,\n    z,\n    calendar\n  };\n}\n\nfunction ParseTemporalInstantString(isoString) {\n  const result = ParseISODateTime(isoString);\n  if (!result.z && !result.offset) throw new RangeError('Temporal.Instant requires a time zone offset');\n  return result;\n}\n\nfunction ParseTemporalZonedDateTimeString(isoString) {\n  const result = ParseISODateTime(isoString);\n  if (!result.ianaName) throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n  return result;\n}\n\nfunction ParseTemporalDateTimeString(isoString) {\n  return ParseISODateTime(isoString);\n}\n\nfunction ParseTemporalDateString(isoString) {\n  return ParseISODateTime(isoString);\n}\n\nfunction ParseTemporalTimeString(isoString) {\n  const match = time.exec(isoString);\n  let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n\n  if (match) {\n    hour = ToInteger(match[1]);\n    minute = ToInteger(match[2] || match[5]);\n    second = ToInteger(match[3] || match[6]);\n    if (second === 60) second = 59;\n    const fraction = (match[4] || match[7]) + '000000000';\n    millisecond = ToInteger(fraction.slice(0, 3));\n    microsecond = ToInteger(fraction.slice(3, 6));\n    nanosecond = ToInteger(fraction.slice(6, 9));\n    calendar = match[15];\n  } else {\n    let z, hasTime;\n    ({\n      hasTime,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar,\n      z\n    } = ParseISODateTime(isoString));\n    if (!hasTime) throw new RangeError(`time is missing in string: ${isoString}`);\n    if (z) throw new RangeError('Z designator not supported for PlainTime');\n  } // if it's a date-time string, OK\n\n\n  if (/[tT ][0-9][0-9]/.test(isoString)) {\n    return {\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    };\n  } // slow but non-grammar-dependent way to ensure that time-only strings that\n  // are also valid PlainMonthDay and PlainYearMonth throw. corresponds to\n  // assertion in spec text\n\n\n  try {\n    const {\n      month,\n      day\n    } = ParseTemporalMonthDayString(isoString);\n    RejectISODate(1972, month, day);\n  } catch {\n    try {\n      const {\n        year,\n        month\n      } = ParseTemporalYearMonthString(isoString);\n      RejectISODate(year, month, 1);\n    } catch {\n      return {\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        calendar\n      };\n    }\n  }\n\n  throw new RangeError(`invalid ISO 8601 time-only string ${isoString}; may need a T prefix`);\n}\n\nfunction ParseTemporalYearMonthString(isoString) {\n  const match = yearmonth.exec(isoString);\n  let year, month, calendar, referenceISODay;\n\n  if (match) {\n    let yearString = match[1];\n    if (yearString[0] === '\\u2212') yearString = `-${yearString.slice(1)}`;\n    if (yearString === '-000000') throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    year = ToInteger(yearString);\n    month = ToInteger(match[2]);\n    calendar = match[3];\n  } else {\n    let z;\n    ({\n      year,\n      month,\n      calendar,\n      day: referenceISODay,\n      z\n    } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainYearMonth');\n  }\n\n  return {\n    year,\n    month,\n    calendar,\n    referenceISODay\n  };\n}\n\nfunction ParseTemporalMonthDayString(isoString) {\n  const match = monthday.exec(isoString);\n  let month, day, calendar, referenceISOYear;\n\n  if (match) {\n    month = ToInteger(match[1]);\n    day = ToInteger(match[2]);\n  } else {\n    let z;\n    ({\n      month,\n      day,\n      calendar,\n      year: referenceISOYear,\n      z\n    } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainMonthDay');\n  }\n\n  return {\n    month,\n    day,\n    calendar,\n    referenceISOYear\n  };\n}\n\nfunction ParseTemporalTimeZoneString(stringIdent) {\n  try {\n    let canonicalIdent = GetCanonicalTimeZoneIdentifier(stringIdent);\n\n    if (canonicalIdent) {\n      canonicalIdent = canonicalIdent.toString();\n      if (TestTimeZoneOffsetString(canonicalIdent)) return {\n        offset: canonicalIdent\n      };\n      return {\n        ianaName: canonicalIdent\n      };\n    }\n  } catch {// fall through\n  }\n\n  try {\n    // Try parsing ISO string instead\n    const result = ParseISODateTime(stringIdent);\n\n    if (result.z || result.offset || result.ianaName) {\n      return result;\n    }\n  } catch {// fall through\n  }\n\n  throw new RangeError(`Invalid time zone: ${stringIdent}`);\n}\n\nfunction ParseTemporalDurationString(isoString) {\n  const match = duration.exec(isoString);\n  if (!match) throw new RangeError(`invalid duration: ${isoString}`);\n\n  if (match.slice(2).every(element => element === undefined)) {\n    throw new RangeError(`invalid duration: ${isoString}`);\n  }\n\n  const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : 1;\n  const years = ToInteger(match[2]) * sign;\n  const months = ToInteger(match[3]) * sign;\n  const weeks = ToInteger(match[4]) * sign;\n  const days = ToInteger(match[5]) * sign;\n  const hours = ToInteger(match[6]) * sign;\n  let fHours = match[7];\n  let minutes = ToInteger(match[8]) * sign;\n  let fMinutes = match[9];\n  let seconds = ToInteger(match[10]) * sign;\n  const fSeconds = match[11] + '000000000';\n  let milliseconds = ToInteger(fSeconds.slice(0, 3)) * sign;\n  let microseconds = ToInteger(fSeconds.slice(3, 6)) * sign;\n  let nanoseconds = ToInteger(fSeconds.slice(6, 9)) * sign;\n  fHours = fHours ? sign * ToInteger(fHours) / 10 ** fHours.length : 0;\n  fMinutes = fMinutes ? sign * ToInteger(fMinutes) / 10 ** fMinutes.length : 0;\n  ({\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  } = DurationHandleFractions(fHours, minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds));\n  return {\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  };\n}\n\nfunction ParseTemporalInstant(isoString) {\n  const {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond,\n    offset,\n    z\n  } = ParseTemporalInstantString(isoString);\n  const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (epochNs === null) throw new RangeError('DateTime outside of supported range');\n  const offsetNs = z ? 0 : ParseTimeZoneOffsetString(offset);\n  return JSBI.subtract(epochNs, JSBI.BigInt(offsetNs));\n}\n\nfunction RegulateISODate(yearParam, monthParam, dayParam, overflow) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n\n  switch (overflow) {\n    case 'reject':\n      RejectISODate(year, month, day);\n      break;\n\n    case 'constrain':\n      ({\n        year,\n        month,\n        day\n      } = ConstrainISODate(year, month, day));\n      break;\n  }\n\n  return {\n    year,\n    month,\n    day\n  };\n}\n\nfunction RegulateTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, overflow) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n\n  switch (overflow) {\n    case 'reject':\n      RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n      break;\n\n    case 'constrain':\n      ({\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond\n      } = ConstrainTime(hour, minute, second, millisecond, microsecond, nanosecond));\n      break;\n  }\n\n  return {\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n}\n\nfunction RegulateISOYearMonth(yearParam, monthParam, overflow) {\n  let year = yearParam;\n  let month = monthParam;\n  const referenceISODay = 1;\n\n  switch (overflow) {\n    case 'reject':\n      RejectISODate(year, month, referenceISODay);\n      break;\n\n    case 'constrain':\n      ({\n        year,\n        month\n      } = ConstrainISODate(year, month));\n      break;\n  }\n\n  return {\n    year,\n    month\n  };\n}\n\nfunction DurationHandleFractions(fHoursParam, minutesParam, fMinutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam) {\n  let fHours = fHoursParam;\n  let minutes = minutesParam;\n  let fMinutes = fMinutesParam;\n  let seconds = secondsParam;\n  let milliseconds = millisecondsParam;\n  let microseconds = microsecondsParam;\n  let nanoseconds = nanosecondsParam;\n\n  if (fHours !== 0) {\n    [minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds].forEach(val => {\n      if (val !== 0) throw new RangeError('only the smallest unit can be fractional');\n    });\n    const mins = fHours * 60;\n    minutes = MathTrunc(mins);\n    fMinutes = mins % 1;\n  }\n\n  if (fMinutes !== 0) {\n    [seconds, milliseconds, microseconds, nanoseconds].forEach(val => {\n      if (val !== 0) throw new RangeError('only the smallest unit can be fractional');\n    });\n    const secs = fMinutes * 60;\n    seconds = MathTrunc(secs);\n    const fSeconds = secs % 1;\n\n    if (fSeconds !== 0) {\n      const mils = fSeconds * 1000;\n      milliseconds = MathTrunc(mils);\n      const fMilliseconds = mils % 1;\n\n      if (fMilliseconds !== 0) {\n        const mics = fMilliseconds * 1000;\n        microseconds = MathTrunc(mics);\n        const fMicroseconds = mics % 1;\n\n        if (fMicroseconds !== 0) {\n          const nans = fMicroseconds * 1000;\n          nanoseconds = MathTrunc(nans);\n        }\n      }\n    }\n  }\n\n  return {\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  };\n}\n\nfunction ToTemporalDurationRecord(item) {\n  if (IsTemporalDuration(item)) {\n    return {\n      years: GetSlot(item, YEARS),\n      months: GetSlot(item, MONTHS),\n      weeks: GetSlot(item, WEEKS),\n      days: GetSlot(item, DAYS),\n      hours: GetSlot(item, HOURS),\n      minutes: GetSlot(item, MINUTES),\n      seconds: GetSlot(item, SECONDS),\n      milliseconds: GetSlot(item, MILLISECONDS),\n      microseconds: GetSlot(item, MICROSECONDS),\n      nanoseconds: GetSlot(item, NANOSECONDS)\n    };\n  }\n\n  const props = ToPartialRecord(item, ['days', 'hours', 'microseconds', 'milliseconds', 'minutes', 'months', 'nanoseconds', 'seconds', 'weeks', 'years']);\n  if (!props) throw new TypeError('invalid duration-like');\n  const {\n    years = 0,\n    months = 0,\n    weeks = 0,\n    days = 0,\n    hours = 0,\n    minutes = 0,\n    seconds = 0,\n    milliseconds = 0,\n    microseconds = 0,\n    nanoseconds = 0\n  } = props;\n  return {\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  };\n}\n\nfunction ToLimitedTemporalDuration(item, disallowedProperties = []) {\n  let record;\n\n  if (IsObject(item)) {\n    record = ToTemporalDurationRecord(item);\n  } else {\n    const str = ToString(item);\n    record = ParseTemporalDurationString(str);\n  }\n\n  const {\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  } = record;\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n  for (const property of disallowedProperties) {\n    if (record[property] !== 0) {\n      throw new RangeError(`Duration field ${property} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);\n    }\n  }\n\n  return record;\n}\n\nfunction ToTemporalOverflow(options) {\n  return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\n\nfunction ToTemporalDisambiguation(options) {\n  return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\n\nfunction ToTemporalRoundingMode(options, fallback) {\n  return GetOption(options, 'roundingMode', ['ceil', 'floor', 'trunc', 'halfExpand'], fallback);\n}\n\nfunction NegateTemporalRoundingMode(roundingMode) {\n  switch (roundingMode) {\n    case 'ceil':\n      return 'floor';\n\n    case 'floor':\n      return 'ceil';\n\n    default:\n      return roundingMode;\n  }\n}\n\nfunction ToTemporalOffset(options, fallback) {\n  return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\n\nfunction ToShowCalendarOption(options) {\n  return GetOption(options, 'calendarName', ['auto', 'always', 'never'], 'auto');\n}\n\nfunction ToShowTimeZoneNameOption(options) {\n  return GetOption(options, 'timeZoneName', ['auto', 'never'], 'auto');\n}\n\nfunction ToShowOffsetOption(options) {\n  return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\n\nfunction ToTemporalRoundingIncrement(options, dividend, inclusive) {\n  let maximum = Infinity;\n  if (dividend !== undefined) maximum = dividend;\n  if (!inclusive && dividend !== undefined) maximum = dividend > 1 ? dividend - 1 : 1;\n  const increment = GetNumberOption(options, 'roundingIncrement', 1, maximum, 1);\n\n  if (dividend !== undefined && dividend % increment !== 0) {\n    throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n  }\n\n  return increment;\n}\n\nfunction ToTemporalDateTimeRoundingIncrement(options, smallestUnit) {\n  const maximumIncrements = {\n    year: undefined,\n    month: undefined,\n    week: undefined,\n    day: undefined,\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n  };\n  return ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n}\n\nfunction ToSecondsStringPrecision(options) {\n  const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week', 'day', 'hour']);\n\n  switch (smallestUnit) {\n    case 'minute':\n      return {\n        precision: 'minute',\n        unit: 'minute',\n        increment: 1\n      };\n\n    case 'second':\n      return {\n        precision: 0,\n        unit: 'second',\n        increment: 1\n      };\n\n    case 'millisecond':\n      return {\n        precision: 3,\n        unit: 'millisecond',\n        increment: 1\n      };\n\n    case 'microsecond':\n      return {\n        precision: 6,\n        unit: 'microsecond',\n        increment: 1\n      };\n\n    case 'nanosecond':\n      return {\n        precision: 9,\n        unit: 'nanosecond',\n        increment: 1\n      };\n  }\n\n  let digits = options.fractionalSecondDigits;\n  if (digits === undefined) digits = 'auto';\n\n  if (typeof digits !== 'number') {\n    const stringDigits = ToString(digits);\n    if (stringDigits === 'auto') return {\n      precision: 'auto',\n      unit: 'nanosecond',\n      increment: 1\n    };\n    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${stringDigits}`);\n  }\n\n  if (NumberIsNaN(digits) || digits < 0 || digits > 9) {\n    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n  }\n\n  const precision = MathFloor(digits);\n\n  switch (precision) {\n    case 0:\n      return {\n        precision,\n        unit: 'second',\n        increment: 1\n      };\n\n    case 1:\n    case 2:\n    case 3:\n      return {\n        precision,\n        unit: 'millisecond',\n        increment: 10 ** (3 - precision)\n      };\n\n    case 4:\n    case 5:\n    case 6:\n      return {\n        precision,\n        unit: 'microsecond',\n        increment: 10 ** (6 - precision)\n      };\n\n    case 7:\n    case 8:\n    case 9:\n      return {\n        precision,\n        unit: 'nanosecond',\n        increment: 10 ** (9 - precision)\n      };\n\n    default:\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n  }\n}\n\nfunction ToLargestTemporalUnit(options, fallback, disallowedStrings = [], autoValue) {\n  const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n  const allowed = new Set(ALLOWED_UNITS);\n\n  for (const s of disallowedStrings) {\n    allowed.delete(s);\n  }\n\n  const retval = GetOption(options, 'largestUnit', ['auto', ...allowed, ...singular.keys()], fallback);\n  if (retval === 'auto' && autoValue !== undefined) return autoValue;\n\n  if (singular.has(retval)) {\n    return singular.get(retval);\n  }\n\n  return retval;\n}\n\nfunction ToSmallestTemporalUnit(options, fallback, disallowedStrings = []) {\n  const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n  const allowed = new Set(ALLOWED_UNITS);\n\n  for (const s of disallowedStrings) {\n    allowed.delete(s);\n  }\n\n  const value = GetOption(options, 'smallestUnit', [...allowed, ...singular.keys()], fallback);\n\n  if (singular.has(value)) {\n    return singular.get(value);\n  }\n\n  return value;\n}\n\nfunction ToTemporalDurationTotalUnit(options) {\n  // This AO is identical to ToSmallestTemporalUnit, except:\n  // - default is always `undefined` (caller will throw if omitted)\n  // - option is named `unit` (not `smallestUnit`)\n  // - all units are valid (no `disallowedStrings`)\n  const singular = new Map(SINGULAR_PLURAL_UNITS);\n  const value = GetOption(options, 'unit', [...singular.values(), ...singular.keys()], undefined);\n\n  if (singular.has(value)) {\n    return singular.get(value);\n  }\n\n  return value;\n}\n\nfunction ToRelativeTemporalObject(options) {\n  const relativeTo = options.relativeTo;\n  if (relativeTo === undefined) return relativeTo;\n  let offsetBehaviour = 'option';\n  let matchMinutes = false;\n  let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, timeZone, offset;\n\n  if (IsObject(relativeTo)) {\n    if (IsTemporalZonedDateTime(relativeTo) || IsTemporalDate(relativeTo)) return relativeTo;\n    if (IsTemporalDateTime(relativeTo)) return TemporalDateTimeToDate(relativeTo);\n    calendar = GetTemporalCalendarWithISODefault(relativeTo);\n    const fieldNames = CalendarFields(calendar, ['day', 'hour', 'microsecond', 'millisecond', 'minute', 'month', 'monthCode', 'nanosecond', 'second', 'year']);\n    const fields = ToTemporalDateTimeFields(relativeTo, fieldNames);\n    const dateOptions = ObjectCreate$2(null);\n    dateOptions.overflow = 'constrain';\n    ({\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = InterpretTemporalDateTimeFields(calendar, fields, dateOptions)); // The `offset` and `timeZone` properties only exist on ZonedDateTime (or\n    // ZonedDateTimeLike-property bags). The assertions below are used to avoid\n    // TS errors while not diverging runtime code from proposal-temporal.\n\n    offset = relativeTo.offset;\n    if (offset === undefined) offsetBehaviour = 'wall';\n    timeZone = relativeTo.timeZone;\n  } else {\n    let ianaName, z;\n    ({\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar,\n      ianaName,\n      offset,\n      z\n    } = ParseISODateTime(ToString(relativeTo)));\n    if (ianaName) timeZone = ianaName;\n\n    if (z) {\n      offsetBehaviour = 'exact';\n    } else if (!offset) {\n      offsetBehaviour = 'wall';\n    }\n\n    if (!calendar) calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    matchMinutes = true;\n  }\n\n  if (timeZone) {\n    timeZone = ToTemporalTimeZone(timeZone);\n    let offsetNs = 0;\n    if (offsetBehaviour === 'option') offsetNs = ParseTimeZoneOffsetString(ToString(offset));\n    const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, 'compatible', 'reject', matchMinutes);\n    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n  }\n\n  return CreateTemporalDate(year, month, day, calendar);\n}\n\nfunction ValidateTemporalUnitRange(largestUnit, smallestUnit) {\n  if (ALLOWED_UNITS.indexOf(largestUnit) > ALLOWED_UNITS.indexOf(smallestUnit)) {\n    throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n  }\n}\n\nfunction DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n  const singular = new Map(SINGULAR_PLURAL_UNITS);\n\n  for (const [prop, v] of [['years', years], ['months', months], ['weeks', weeks], ['days', days], ['hours', hours], ['minutes', minutes], ['seconds', seconds], ['milliseconds', milliseconds], ['microseconds', microseconds], ['nanoseconds', nanoseconds]]) {\n    if (v !== 0) return singular.get(prop);\n  }\n\n  return 'nanosecond';\n}\n\nfunction LargerOfTwoTemporalUnits(unit1, unit2) {\n  if (ALLOWED_UNITS.indexOf(unit1) > ALLOWED_UNITS.indexOf(unit2)) return unit2;\n  return unit1;\n}\n\nfunction ToPartialRecord(bagParam, fieldsParam) {\n  // External callers are limited to specific types, but this function's\n  // implementation uses generic property types. The casts below (and at the\n  // end) convert to/from generic records.\n  const bag = bagParam;\n  const fields = fieldsParam;\n  let any = false;\n  let result = {};\n\n  for (const property of fields) {\n    const value = bag[property];\n\n    if (value !== undefined) {\n      any = true;\n\n      if (BUILTIN_CASTS.has(property)) {\n        result[property] = BUILTIN_CASTS.get(property)(value);\n      } else {\n        result[property] = value;\n      }\n    }\n  }\n\n  return any ? result : false;\n}\n\nfunction PrepareTemporalFields(bagParam, fieldsParam) {\n  // External callers are limited to specific types, but this function's\n  // implementation uses generic property types. The casts below (and at the\n  // end) convert to/from generic records.\n  const bag = bagParam;\n  const fields = fieldsParam;\n  const result = {};\n  let any = false;\n\n  for (const fieldRecord of fields) {\n    const [property, defaultValue] = fieldRecord;\n    let value = bag[property];\n\n    if (value === undefined) {\n      if (fieldRecord.length === 1) {\n        throw new TypeError(`required property '${property}' missing or undefined`);\n      }\n\n      value = defaultValue;\n    } else {\n      any = true;\n\n      if (BUILTIN_CASTS.has(property)) {\n        value = BUILTIN_CASTS.get(property)(value);\n      }\n    }\n\n    result[property] = value;\n  }\n\n  if (!any) {\n    throw new TypeError('no supported properties found');\n  }\n\n  if (result['era'] === undefined !== (result['eraYear'] === undefined)) {\n    throw new RangeError(\"properties 'era' and 'eraYear' must be provided together\");\n  }\n\n  return result;\n} // field access in the following operations is intentionally alphabetical\n\n\nfunction ToTemporalDateFields(bag, fieldNames) {\n  const entries = [['day', undefined], ['month', undefined], ['monthCode', undefined], ['year', undefined]]; // Add extra fields from the calendar at the end\n\n  fieldNames.forEach(fieldName => {\n    if (!entries.some(([name]) => name === fieldName)) {\n      entries.push([fieldName, undefined]);\n    }\n  });\n  return PrepareTemporalFields(bag, entries);\n}\n\nfunction ToTemporalDateTimeFields(bag, fieldNames) {\n  const entries = [['day', undefined], ['hour', 0], ['microsecond', 0], ['millisecond', 0], ['minute', 0], ['month', undefined], ['monthCode', undefined], ['nanosecond', 0], ['second', 0], ['year', undefined]]; // Add extra fields from the calendar at the end\n\n  fieldNames.forEach(fieldName => {\n    if (!entries.some(([name]) => name === fieldName)) {\n      entries.push([fieldName, undefined]);\n    }\n  });\n  return PrepareTemporalFields(bag, entries);\n}\n\nfunction ToTemporalMonthDayFields(bag, fieldNames) {\n  const entries = [['day', undefined], ['month', undefined], ['monthCode', undefined], ['year', undefined]]; // Add extra fields from the calendar at the end\n\n  fieldNames.forEach(fieldName => {\n    if (!entries.some(([name]) => name === fieldName)) {\n      entries.push([fieldName, undefined]);\n    }\n  });\n  return PrepareTemporalFields(bag, entries);\n}\n\nfunction ToTemporalTimeRecord(bag) {\n  return PrepareTemporalFields(bag, [['hour', 0], ['microsecond', 0], ['millisecond', 0], ['minute', 0], ['nanosecond', 0], ['second', 0]]);\n}\n\nfunction ToTemporalYearMonthFields(bag, fieldNames) {\n  const entries = [['month', undefined], ['monthCode', undefined], ['year', undefined]]; // Add extra fields from the calendar at the end\n\n  fieldNames.forEach(fieldName => {\n    if (!entries.some(([name]) => name === fieldName)) {\n      entries.push([fieldName, undefined]);\n    }\n  });\n  return PrepareTemporalFields(bag, entries);\n}\n\nfunction ToTemporalZonedDateTimeFields(bag, fieldNames) {\n  const entries = [['day', undefined], ['hour', 0], ['microsecond', 0], ['millisecond', 0], ['minute', 0], ['month', undefined], ['monthCode', undefined], ['nanosecond', 0], ['second', 0], ['year', undefined], ['offset', undefined], ['timeZone']]; // Add extra fields from the calendar at the end\n\n  fieldNames.forEach(fieldName => {\n    if (!entries.some(([name]) => name === fieldName)) {\n      entries.push([fieldName, undefined]);\n    }\n  });\n  return PrepareTemporalFields(bag, entries);\n}\n\nfunction ToTemporalDate(itemParam, options = ObjectCreate$2(null)) {\n  let item = itemParam;\n\n  if (IsObject(item)) {\n    if (IsTemporalDate(item)) return item;\n\n    if (IsTemporalZonedDateTime(item)) {\n      item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n\n    if (IsTemporalDateTime(item)) {\n      return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n    }\n\n    const calendar = GetTemporalCalendarWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n    const fields = ToTemporalDateFields(item, fieldNames);\n    return DateFromFields(calendar, fields, options);\n  }\n\n  ToTemporalOverflow(options); // validate and ignore\n\n  const {\n    year,\n    month,\n    day,\n    calendar,\n    z\n  } = ParseTemporalDateString(ToString(item));\n  if (z) throw new RangeError('Z designator not supported for PlainDate');\n  const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n  return new TemporalPlainDate(year, month, day, calendar); // include validation\n}\n\nfunction InterpretTemporalDateTimeFields(calendar, fields, options) {\n  let {\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  } = ToTemporalTimeRecord(fields);\n  const overflow = ToTemporalOverflow(options);\n  const date = DateFromFields(calendar, fields, options);\n  const year = GetSlot(date, ISO_YEAR);\n  const month = GetSlot(date, ISO_MONTH);\n  const day = GetSlot(date, ISO_DAY);\n  ({\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n  return {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n}\n\nfunction ToTemporalDateTime(item, options = ObjectCreate$2(null)) {\n  let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n\n  if (IsObject(item)) {\n    if (IsTemporalDateTime(item)) return item;\n\n    if (IsTemporalZonedDateTime(item)) {\n      return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n\n    if (IsTemporalDate(item)) {\n      return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), 0, 0, 0, 0, 0, 0, GetSlot(item, CALENDAR));\n    }\n\n    calendar = GetTemporalCalendarWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, ['day', 'hour', 'microsecond', 'millisecond', 'minute', 'month', 'monthCode', 'nanosecond', 'second', 'year']);\n    const fields = ToTemporalDateTimeFields(item, fieldNames);\n    ({\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = InterpretTemporalDateTimeFields(calendar, fields, options));\n  } else {\n    ToTemporalOverflow(options); // validate and ignore\n\n    let z;\n    ({\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar,\n      z\n    } = ParseTemporalDateTimeString(ToString(item)));\n    if (z) throw new RangeError('Z designator not supported for PlainDateTime');\n    RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (calendar === undefined) calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n  }\n\n  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\n\nfunction ToTemporalDuration(item) {\n  let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n\n  if (IsObject(item)) {\n    if (IsTemporalDuration(item)) return item;\n    ({\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = ToTemporalDurationRecord(item));\n  } else {\n    ({\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = ParseTemporalDurationString(ToString(item)));\n  }\n\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\n\nfunction ToTemporalInstant(item) {\n  if (IsTemporalInstant(item)) return item;\n\n  if (IsTemporalZonedDateTime(item)) {\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(GetSlot(item, EPOCHNANOSECONDS));\n  }\n\n  const ns = ParseTemporalInstant(ToString(item));\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  return new TemporalInstant(ns);\n}\n\nfunction ToTemporalMonthDay(item, options = ObjectCreate$2(null)) {\n  if (IsObject(item)) {\n    if (IsTemporalMonthDay(item)) return item;\n    let calendar, calendarAbsent;\n\n    if (HasSlot(item, CALENDAR)) {\n      calendar = GetSlot(item, CALENDAR);\n      calendarAbsent = false;\n    } else {\n      let maybeStringCalendar = item.calendar;\n      calendarAbsent = maybeStringCalendar === undefined;\n      if (maybeStringCalendar === undefined) maybeStringCalendar = GetISO8601Calendar();\n      calendar = ToTemporalCalendar(maybeStringCalendar);\n    }\n\n    const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n    const fields = ToTemporalMonthDayFields(item, fieldNames); // Callers who omit the calendar are not writing calendar-independent\n    // code. In that case, `monthCode`/`year` can be omitted; `month` and\n    // `day` are sufficient. Add a `year` to satisfy calendar validation.\n\n    if (calendarAbsent && fields.month !== undefined && fields.monthCode === undefined && fields.year === undefined) {\n      fields.year = 1972;\n    }\n\n    return MonthDayFromFields(calendar, fields, options);\n  }\n\n  ToTemporalOverflow(options); // validate and ignore\n\n  let {\n    month,\n    day,\n    referenceISOYear,\n    calendar: maybeStringCalendar\n  } = ParseTemporalMonthDayString(ToString(item));\n  let calendar = maybeStringCalendar;\n  if (calendar === undefined) calendar = GetISO8601Calendar();\n  calendar = ToTemporalCalendar(calendar);\n\n  if (referenceISOYear === undefined) {\n    RejectISODate(1972, month, day);\n    return CreateTemporalMonthDay(month, day, calendar);\n  }\n\n  const result = CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n  const canonicalOptions = ObjectCreate$2(null);\n  return MonthDayFromFields(calendar, result, canonicalOptions);\n}\n\nfunction ToTemporalTime(itemParam, overflow = 'constrain') {\n  let item = itemParam;\n  let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n\n  if (IsObject(item)) {\n    if (IsTemporalTime(item)) return item;\n\n    if (IsTemporalZonedDateTime(item)) {\n      item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n    }\n\n    if (IsTemporalDateTime(item)) {\n      const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n      return new TemporalPlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n    }\n\n    calendar = GetTemporalCalendarWithISODefault(item);\n\n    if (ToString(calendar) !== 'iso8601') {\n      throw new RangeError('PlainTime can only have iso8601 calendar');\n    }\n\n    ({\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = ToTemporalTimeRecord(item));\n    ({\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n  } else {\n    ({\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      calendar\n    } = ParseTemporalTimeString(ToString(item)));\n    RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n\n    if (calendar !== undefined && calendar !== 'iso8601') {\n      throw new RangeError('PlainTime can only have iso8601 calendar');\n    }\n  }\n\n  const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n  return new TemporalPlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nfunction ToTemporalYearMonth(item, options = ObjectCreate$2(null)) {\n  if (IsObject(item)) {\n    if (IsTemporalYearMonth(item)) return item;\n    const calendar = GetTemporalCalendarWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year']);\n    const fields = ToTemporalYearMonthFields(item, fieldNames);\n    return YearMonthFromFields(calendar, fields, options);\n  }\n\n  ToTemporalOverflow(options); // validate and ignore\n\n  let {\n    year,\n    month,\n    referenceISODay,\n    calendar: maybeStringCalendar\n  } = ParseTemporalYearMonthString(ToString(item)); // TODO: replace with ternary?\n\n  let calendar = maybeStringCalendar;\n  if (calendar === undefined) calendar = GetISO8601Calendar();\n  calendar = ToTemporalCalendar(calendar);\n\n  if (referenceISODay === undefined) {\n    RejectISODate(year, month, 1);\n    return CreateTemporalYearMonth(year, month, calendar);\n  }\n\n  const result = CreateTemporalYearMonth(year, month, calendar, referenceISODay);\n  const canonicalOptions = ObjectCreate$2(null);\n  return YearMonthFromFields(calendar, result, canonicalOptions);\n}\n\nfunction InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute) {\n  const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n  const dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n\n  if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n    // Simple case: ISO string without a TZ offset (or caller wants to ignore\n    // the offset), so just convert DateTime to Instant in the given time zone\n    const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, disambiguation);\n    return GetSlot(instant, EPOCHNANOSECONDS);\n  } // The caller wants the offset to always win ('use') OR the caller is OK\n  // with the offset winning ('prefer' or 'reject') as long as it's valid\n  // for this timezone and date/time.\n\n\n  if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n    // Calculate the instant for the input's date/time and offset\n    const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (epochNs === null) throw new RangeError('ZonedDateTime outside of supported range');\n    return JSBI.subtract(epochNs, JSBI.BigInt(offsetNs));\n  } // \"prefer\" or \"reject\"\n\n\n  const possibleInstants = GetPossibleInstantsFor(timeZone, dt);\n\n  for (const candidate of possibleInstants) {\n    const candidateOffset = GetOffsetNanosecondsFor(timeZone, candidate);\n    const roundedCandidateOffset = JSBI.toNumber(RoundNumberToIncrement(JSBI.BigInt(candidateOffset), 60e9, 'halfExpand'));\n\n    if (candidateOffset === offsetNs || matchMinute && roundedCandidateOffset === offsetNs) {\n      return GetSlot(candidate, EPOCHNANOSECONDS);\n    }\n  } // the user-provided offset doesn't match any instants for this time\n  // zone and date/time.\n\n\n  if (offsetOpt === 'reject') {\n    const offsetStr = FormatTimeZoneOffsetString(offsetNs);\n    const timeZoneString = IsTemporalTimeZone(timeZone) ? GetSlot(timeZone, TIMEZONE_ID) : 'time zone'; // The tsc emit for this line rewrites to invoke the PlainDateTime's valueOf method, NOT\n    // toString (which is invoked by Node when using template literals directly).\n    // See https://github.com/microsoft/TypeScript/issues/39744 for the proposed fix in tsc emit\n\n    throw new RangeError(`Offset ${offsetStr} is invalid for ${dt.toString()} in ${timeZoneString}`);\n  } // fall through: offsetOpt === 'prefer', but the offset doesn't match\n  // so fall back to use the time zone instead.\n\n\n  const instant = DisambiguatePossibleInstants(possibleInstants, timeZone, dt, disambiguation);\n  return GetSlot(instant, EPOCHNANOSECONDS);\n}\n\nfunction ToTemporalZonedDateTime(item, options = ObjectCreate$2(null)) {\n  let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, timeZone, offset, calendar;\n  let matchMinute = false;\n  let offsetBehaviour = 'option';\n\n  if (IsObject(item)) {\n    if (IsTemporalZonedDateTime(item)) return item;\n    calendar = GetTemporalCalendarWithISODefault(item);\n    const fieldNames = CalendarFields(calendar, ['day', 'hour', 'microsecond', 'millisecond', 'minute', 'month', 'monthCode', 'nanosecond', 'second', 'year']);\n    const fields = ToTemporalZonedDateTimeFields(item, fieldNames);\n    ({\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = InterpretTemporalDateTimeFields(calendar, fields, options));\n    timeZone = ToTemporalTimeZone(fields.timeZone);\n    offset = fields.offset;\n\n    if (offset === undefined) {\n      offsetBehaviour = 'wall';\n    } else {\n      offset = ToString(offset);\n    }\n  } else {\n    ToTemporalOverflow(options); // validate and ignore\n\n    let ianaName, z;\n    ({\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      ianaName,\n      offset,\n      z,\n      calendar\n    } = ParseTemporalZonedDateTimeString(ToString(item)));\n    if (!ianaName) throw new RangeError('time zone ID required in brackets');\n\n    if (z) {\n      offsetBehaviour = 'exact';\n    } else if (!offset) {\n      offsetBehaviour = 'wall';\n    }\n\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    timeZone = new TemporalTimeZone(ianaName);\n    if (!calendar) calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    matchMinute = true; // ISO strings may specify offset with less precision\n  }\n\n  let offsetNs = 0; // The code above guarantees that if offsetBehaviour === 'option', then\n  // `offset` is not undefined.\n\n  if (offsetBehaviour === 'option') offsetNs = ParseTimeZoneOffsetString(offset);\n  const disambiguation = ToTemporalDisambiguation(options);\n  const offsetOpt = ToTemporalOffset(options, 'reject');\n  const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute);\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nfunction CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar) {\n  RejectISODate(isoYear, isoMonth, isoDay);\n  RejectDateRange(isoYear, isoMonth, isoDay);\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, DATE_BRAND, true);\n  {\n    ObjectDefineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalDateToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nfunction CreateTemporalDate(isoYear, isoMonth, isoDay, calendar = GetISO8601Calendar()) {\n  const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n  const result = ObjectCreate$2(TemporalPlainDate.prototype);\n  CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar);\n  return result;\n}\n\nfunction CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar) {\n  RejectDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n  RejectDateTimeRange(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, ISO_HOUR, h);\n  SetSlot(result, ISO_MINUTE, min);\n  SetSlot(result, ISO_SECOND, s);\n  SetSlot(result, ISO_MILLISECOND, ms);\n  SetSlot(result, ISO_MICROSECOND, µs);\n  SetSlot(result, ISO_NANOSECOND, ns);\n  SetSlot(result, CALENDAR, calendar);\n  {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalDateTimeToString(result, 'auto')}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nfunction CreateTemporalDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar = GetISO8601Calendar()) {\n  const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n  const result = ObjectCreate$2(TemporalPlainDateTime.prototype);\n  CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar);\n  return result;\n}\n\nfunction CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear) {\n  RejectISODate(referenceISOYear, isoMonth, isoDay);\n  RejectDateRange(referenceISOYear, isoMonth, isoDay);\n  CreateSlots(result);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, isoDay);\n  SetSlot(result, ISO_YEAR, referenceISOYear);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, MONTH_DAY_BRAND, true);\n  {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalMonthDayToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nfunction CreateTemporalMonthDay(isoMonth, isoDay, calendar = GetISO8601Calendar(), referenceISOYear = 1972) {\n  const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n  const result = ObjectCreate$2(TemporalPlainMonthDay.prototype);\n  CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear);\n  return result;\n}\n\nfunction CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay) {\n  RejectISODate(isoYear, isoMonth, referenceISODay);\n  RejectYearMonthRange(isoYear, isoMonth);\n  CreateSlots(result);\n  SetSlot(result, ISO_YEAR, isoYear);\n  SetSlot(result, ISO_MONTH, isoMonth);\n  SetSlot(result, ISO_DAY, referenceISODay);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, YEAR_MONTH_BRAND, true);\n  {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalYearMonthToString(result)}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nfunction CreateTemporalYearMonth(isoYear, isoMonth, calendar = GetISO8601Calendar(), referenceISODay = 1) {\n  const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n  const result = ObjectCreate$2(TemporalPlainYearMonth.prototype);\n  CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay);\n  return result;\n}\n\nfunction CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar) {\n  ValidateEpochNanoseconds(epochNanoseconds);\n  CreateSlots(result);\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n  SetSlot(result, TIME_ZONE, timeZone);\n  SetSlot(result, CALENDAR, calendar);\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const instant = new TemporalInstant(GetSlot(result, EPOCHNANOSECONDS));\n  SetSlot(result, INSTANT, instant);\n  {\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${TemporalZonedDateTimeToString(result, 'auto')}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nfunction CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar = GetISO8601Calendar()) {\n  const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n  const result = ObjectCreate$2(TemporalZonedDateTime.prototype);\n  CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n  return result;\n}\n\nfunction GetISO8601Calendar() {\n  const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n  return new TemporalCalendar('iso8601');\n} // TODO: should (can?) we make this generic so the field names are checked\n// against the type that the calendar is a property of?\n\n\nfunction CalendarFields(calendar, fieldNamesParam) {\n  let fieldNames = fieldNamesParam;\n\n  if (calendar.fields) {\n    fieldNames = calendar.fields(fieldNames);\n  }\n\n  const result = [];\n\n  for (const name of fieldNames) {\n    if (typeof name !== 'string') throw new TypeError('bad return from calendar.fields()');\n    ArrayPrototypePush$1.call(result, name);\n  }\n\n  return result;\n}\n\nfunction CalendarMergeFields(calendar, fields, additionalFields) {\n  const calMergeFields = calendar.mergeFields;\n\n  if (!calMergeFields) {\n    return { ...fields,\n      ...additionalFields\n    };\n  }\n\n  const result = Reflect.apply(calMergeFields, calendar, [fields, additionalFields]);\n  if (!IsObject(result)) throw new TypeError('bad return from calendar.mergeFields()');\n  return result;\n}\n\nfunction CalendarDateAdd(calendar, date, duration, options, dateAddParam) {\n  let dateAdd = dateAddParam;\n\n  if (dateAdd === undefined) {\n    dateAdd = calendar.dateAdd;\n  }\n\n  const result = ReflectApply$1(dateAdd, calendar, [date, duration, options]);\n  if (!IsTemporalDate(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nfunction CalendarDateUntil(calendar, date, otherDate, options, dateUntilParam) {\n  let dateUntil = dateUntilParam;\n\n  if (dateUntil === undefined) {\n    dateUntil = calendar.dateUntil;\n  }\n\n  const result = ReflectApply$1(dateUntil, calendar, [date, otherDate, options]);\n  if (!IsTemporalDuration(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nfunction CalendarYear(calendar, dateLike) {\n  const result = calendar.year(dateLike);\n\n  if (result === undefined) {\n    throw new RangeError('calendar year result must be an integer');\n  }\n\n  return ToIntegerThrowOnInfinity(result);\n}\n\nfunction CalendarMonth(calendar, dateLike) {\n  const result = calendar.month(dateLike);\n\n  if (result === undefined) {\n    throw new RangeError('calendar month result must be a positive integer');\n  }\n\n  return ToPositiveInteger(result);\n}\n\nfunction CalendarMonthCode(calendar, dateLike) {\n  const result = calendar.monthCode(dateLike);\n\n  if (result === undefined) {\n    throw new RangeError('calendar monthCode result must be a string');\n  }\n\n  return ToString(result);\n}\n\nfunction CalendarDay(calendar, dateLike) {\n  const result = calendar.day(dateLike);\n\n  if (result === undefined) {\n    throw new RangeError('calendar day result must be a positive integer');\n  }\n\n  return ToPositiveInteger(result);\n}\n\nfunction CalendarEra(calendar, dateLike) {\n  let result = calendar.era(dateLike);\n\n  if (result !== undefined) {\n    result = ToString(result);\n  }\n\n  return result;\n}\n\nfunction CalendarEraYear(calendar, dateLike) {\n  let result = calendar.eraYear(dateLike);\n\n  if (result !== undefined) {\n    result = ToIntegerThrowOnInfinity(result);\n  }\n\n  return result;\n}\n\nfunction CalendarDayOfWeek(calendar, dateLike) {\n  return calendar.dayOfWeek(dateLike);\n}\n\nfunction CalendarDayOfYear(calendar, dateLike) {\n  return calendar.dayOfYear(dateLike);\n}\n\nfunction CalendarWeekOfYear(calendar, dateLike) {\n  return calendar.weekOfYear(dateLike);\n}\n\nfunction CalendarDaysInWeek(calendar, dateLike) {\n  return calendar.daysInWeek(dateLike);\n}\n\nfunction CalendarDaysInMonth(calendar, dateLike) {\n  return calendar.daysInMonth(dateLike);\n}\n\nfunction CalendarDaysInYear(calendar, dateLike) {\n  return calendar.daysInYear(dateLike);\n}\n\nfunction CalendarMonthsInYear(calendar, dateLike) {\n  return calendar.monthsInYear(dateLike);\n}\n\nfunction CalendarInLeapYear(calendar, dateLike) {\n  return calendar.inLeapYear(dateLike);\n}\n\nfunction ToTemporalCalendar(calendarLikeParam) {\n  let calendarLike = calendarLikeParam;\n\n  if (IsObject(calendarLike)) {\n    if (HasSlot(calendarLike, CALENDAR)) return GetSlot(calendarLike, CALENDAR);\n    if (!('calendar' in calendarLike)) return calendarLike;\n    calendarLike = calendarLike.calendar;\n    if (IsObject(calendarLike) && !('calendar' in calendarLike)) return calendarLike;\n  }\n\n  const identifier = ToString(calendarLike);\n  const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n  if (IsBuiltinCalendar(identifier)) return new TemporalCalendar(identifier);\n  let calendar;\n\n  try {\n    ({\n      calendar\n    } = ParseISODateTime(identifier));\n  } catch {\n    throw new RangeError(`Invalid calendar: ${identifier}`);\n  }\n\n  if (!calendar) calendar = 'iso8601';\n  return new TemporalCalendar(calendar);\n}\n\nfunction GetTemporalCalendarWithISODefault(item) {\n  if (HasSlot(item, CALENDAR)) return GetSlot(item, CALENDAR);\n  const {\n    calendar\n  } = item;\n  if (calendar === undefined) return GetISO8601Calendar();\n  return ToTemporalCalendar(calendar);\n}\n\nfunction CalendarEquals(one, two) {\n  if (one === two) return true;\n  const cal1 = ToString(one);\n  const cal2 = ToString(two);\n  return cal1 === cal2;\n}\n\nfunction ConsolidateCalendars(one, two) {\n  if (one === two) return two;\n  const sOne = ToString(one);\n  const sTwo = ToString(two);\n\n  if (sOne === sTwo || sOne === 'iso8601') {\n    return two;\n  } else if (sTwo === 'iso8601') {\n    return one;\n  } else {\n    throw new RangeError('irreconcilable calendars');\n  }\n}\n\nfunction DateFromFields(calendar, fields, options) {\n  const result = calendar.dateFromFields(fields, options);\n  if (!IsTemporalDate(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nfunction YearMonthFromFields(calendar, fields, options) {\n  const result = calendar.yearMonthFromFields(fields, options);\n  if (!IsTemporalYearMonth(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nfunction MonthDayFromFields(calendar, fields, options) {\n  const result = calendar.monthDayFromFields(fields, options);\n  if (!IsTemporalMonthDay(result)) throw new TypeError('invalid result');\n  return result;\n}\n\nfunction ToTemporalTimeZone(temporalTimeZoneLikeParam) {\n  let temporalTimeZoneLike = temporalTimeZoneLikeParam;\n\n  if (IsObject(temporalTimeZoneLike)) {\n    if (IsTemporalZonedDateTime(temporalTimeZoneLike)) return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n    if (!('timeZone' in temporalTimeZoneLike)) return temporalTimeZoneLike;\n    temporalTimeZoneLike = temporalTimeZoneLike.timeZone;\n\n    if (IsObject(temporalTimeZoneLike) && !('timeZone' in temporalTimeZoneLike)) {\n      return temporalTimeZoneLike;\n    }\n  }\n\n  const identifier = ToString(temporalTimeZoneLike);\n  const timeZone = ParseTemporalTimeZone(identifier);\n  const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n  return new TemporalTimeZone(timeZone);\n}\n\nfunction TimeZoneEquals(one, two) {\n  if (one === two) return true;\n  const tz1 = ToString(one);\n  const tz2 = ToString(two);\n  return tz1 === tz2;\n}\n\nfunction TemporalDateTimeToDate(dateTime) {\n  return CreateTemporalDate(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, CALENDAR));\n}\n\nfunction TemporalDateTimeToTime(dateTime) {\n  const Time = GetIntrinsic('%Temporal.PlainTime%');\n  return new Time(GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n}\n\nfunction GetOffsetNanosecondsFor(timeZone, instant) {\n  let getOffsetNanosecondsFor = timeZone.getOffsetNanosecondsFor;\n\n  if (typeof getOffsetNanosecondsFor !== 'function') {\n    throw new TypeError('getOffsetNanosecondsFor not callable');\n  }\n\n  const offsetNs = Reflect.apply(getOffsetNanosecondsFor, timeZone, [instant]);\n\n  if (typeof offsetNs !== 'number') {\n    throw new TypeError('bad return from getOffsetNanosecondsFor');\n  }\n\n  if (!IsInteger(offsetNs) || MathAbs(offsetNs) > 86400e9) {\n    throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n  }\n\n  return offsetNs;\n}\n\nfunction BuiltinTimeZoneGetOffsetStringFor(timeZone, instant) {\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n  return FormatTimeZoneOffsetString(offsetNs);\n}\n\nfunction BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar) {\n  const ns = GetSlot(instant, EPOCHNANOSECONDS);\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n  let {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  } = GetISOPartsFromEpoch(ns);\n  ({\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  } = BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs));\n  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\n\nfunction BuiltinTimeZoneGetInstantFor(timeZone, dateTime, disambiguation) {\n  const possibleInstants = GetPossibleInstantsFor(timeZone, dateTime);\n  return DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation);\n}\n\nfunction DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation) {\n  const Instant = GetIntrinsic('%Temporal.Instant%');\n  const numInstants = possibleInstants.length;\n  if (numInstants === 1) return possibleInstants[0];\n\n  if (numInstants) {\n    switch (disambiguation) {\n      case 'compatible': // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n\n      case 'earlier':\n        return possibleInstants[0];\n\n      case 'later':\n        return possibleInstants[numInstants - 1];\n\n      case 'reject':\n        {\n          throw new RangeError('multiple instants found');\n        }\n    }\n  }\n\n  const year = GetSlot(dateTime, ISO_YEAR);\n  const month = GetSlot(dateTime, ISO_MONTH);\n  const day = GetSlot(dateTime, ISO_DAY);\n  const hour = GetSlot(dateTime, ISO_HOUR);\n  const minute = GetSlot(dateTime, ISO_MINUTE);\n  const second = GetSlot(dateTime, ISO_SECOND);\n  const millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n  const microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n  const nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n  const utcns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (utcns === null) throw new RangeError('DateTime outside of supported range');\n  const dayBefore = new Instant(JSBI.subtract(utcns, DAY_NANOS));\n  const dayAfter = new Instant(JSBI.add(utcns, DAY_NANOS));\n  const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n  const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n  const nanoseconds = offsetAfter - offsetBefore;\n\n  switch (disambiguation) {\n    case 'earlier':\n      {\n        const calendar = GetSlot(dateTime, CALENDAR);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const earlier = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, -nanoseconds, undefined);\n        const earlierPlainDateTime = new PlainDateTime(earlier.year, earlier.month, earlier.day, earlier.hour, earlier.minute, earlier.second, earlier.millisecond, earlier.microsecond, earlier.nanosecond, calendar);\n        return GetPossibleInstantsFor(timeZone, earlierPlainDateTime)[0];\n      }\n\n    case 'compatible': // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n\n    case 'later':\n      {\n        const calendar = GetSlot(dateTime, CALENDAR);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const later = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, nanoseconds, undefined);\n        const laterPlainDateTime = new PlainDateTime(later.year, later.month, later.day, later.hour, later.minute, later.second, later.millisecond, later.microsecond, later.nanosecond, calendar);\n        const possible = GetPossibleInstantsFor(timeZone, laterPlainDateTime);\n        return possible[possible.length - 1];\n      }\n\n    case 'reject':\n      {\n        throw new RangeError('no such instant found');\n      }\n  }\n}\n\nfunction GetPossibleInstantsFor(timeZone, dateTime) {\n  const possibleInstants = timeZone.getPossibleInstantsFor(dateTime);\n  const result = [];\n\n  for (const instant of possibleInstants) {\n    if (!IsTemporalInstant(instant)) {\n      throw new TypeError('bad return from getPossibleInstantsFor');\n    }\n\n    ArrayPrototypePush$1.call(result, instant);\n  }\n\n  return result;\n}\n\nfunction ISOYearString(year) {\n  let yearString;\n\n  if (year < 1000 || year > 9999) {\n    const sign = year < 0 ? '-' : '+';\n    const yearNumber = MathAbs(year);\n    yearString = sign + `000000${yearNumber}`.slice(-6);\n  } else {\n    yearString = `${year}`;\n  }\n\n  return yearString;\n}\n\nfunction ISODateTimePartString(part) {\n  return `00${part}`.slice(-2);\n}\n\nfunction FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision) {\n  if (precision === 'minute') return '';\n  const secs = `:${ISODateTimePartString(second)}`;\n  let fractionNumber = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n  let fraction;\n\n  if (precision === 'auto') {\n    if (fractionNumber === 0) return secs;\n    fraction = `${fractionNumber}`.padStart(9, '0');\n\n    while (fraction[fraction.length - 1] === '0') fraction = fraction.slice(0, -1);\n  } else {\n    if (precision === 0) return secs;\n    fraction = `${fractionNumber}`.padStart(9, '0').slice(0, precision);\n  }\n\n  return `${secs}.${fraction}`;\n}\n\nfunction TemporalInstantToString(instant, timeZone, precision) {\n  let outputTimeZone = timeZone;\n\n  if (outputTimeZone === undefined) {\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    outputTimeZone = new TemporalTimeZone('UTC');\n  }\n\n  const iso = GetISO8601Calendar();\n  const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(outputTimeZone, instant, iso);\n  const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n  const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n  const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n  const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n  let timeZoneString = 'Z';\n\n  if (timeZone !== undefined) {\n    const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, instant);\n    timeZoneString = FormatISOTimeZoneOffsetString(offsetNs);\n  }\n\n  return `${year}-${month}-${day}T${hour}:${minute}${seconds}${timeZoneString}`;\n}\n\nfunction TemporalDurationToString(duration, precision = 'auto', options = undefined) {\n  function formatNumber(num) {\n    if (num <= NumberMaxSafeInteger) return num.toString(10);\n    return JSBI.BigInt(num).toString(10);\n  }\n\n  const years = GetSlot(duration, YEARS);\n  const months = GetSlot(duration, MONTHS);\n  const weeks = GetSlot(duration, WEEKS);\n  const days = GetSlot(duration, DAYS);\n  const hours = GetSlot(duration, HOURS);\n  const minutes = GetSlot(duration, MINUTES);\n  let seconds = GetSlot(duration, SECONDS);\n  let ms = GetSlot(duration, MILLISECONDS);\n  let µs = GetSlot(duration, MICROSECONDS);\n  let ns = GetSlot(duration, NANOSECONDS);\n  const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, ms, µs, ns);\n\n  if (options) {\n    const {\n      unit,\n      increment,\n      roundingMode\n    } = options;\n    ({\n      seconds,\n      milliseconds: ms,\n      microseconds: µs,\n      nanoseconds: ns\n    } = RoundDuration(0, 0, 0, 0, 0, 0, seconds, ms, µs, ns, increment, unit, roundingMode));\n  }\n\n  const dateParts = [];\n  if (years) dateParts.push(`${formatNumber(MathAbs(years))}Y`);\n  if (months) dateParts.push(`${formatNumber(MathAbs(months))}M`);\n  if (weeks) dateParts.push(`${formatNumber(MathAbs(weeks))}W`);\n  if (days) dateParts.push(`${formatNumber(MathAbs(days))}D`);\n  const timeParts = [];\n  if (hours) timeParts.push(`${formatNumber(MathAbs(hours))}H`);\n  if (minutes) timeParts.push(`${formatNumber(MathAbs(minutes))}M`);\n  const secondParts = [];\n  let total = TotalDurationNanoseconds(0, 0, 0, seconds, ms, µs, ns, 0);\n  let nsBigInt, µsBigInt, msBigInt, secondsBigInt;\n  ({\n    quotient: total,\n    remainder: nsBigInt\n  } = divmod(total, THOUSAND));\n  ({\n    quotient: total,\n    remainder: µsBigInt\n  } = divmod(total, THOUSAND));\n  ({\n    quotient: secondsBigInt,\n    remainder: msBigInt\n  } = divmod(total, THOUSAND));\n  const fraction = MathAbs(JSBI.toNumber(msBigInt)) * 1e6 + MathAbs(JSBI.toNumber(µsBigInt)) * 1e3 + MathAbs(JSBI.toNumber(nsBigInt));\n  let decimalPart;\n\n  if (precision === 'auto') {\n    if (fraction !== 0) {\n      decimalPart = `${fraction}`.padStart(9, '0');\n\n      while (decimalPart[decimalPart.length - 1] === '0') {\n        decimalPart = decimalPart.slice(0, -1);\n      }\n    }\n  } else if (precision !== 0) {\n    decimalPart = `${fraction}`.padStart(9, '0').slice(0, precision);\n  }\n\n  if (decimalPart) secondParts.unshift('.', decimalPart);\n\n  if (!JSBI.equal(secondsBigInt, ZERO) || secondParts.length || precision !== 'auto') {\n    secondParts.unshift(abs(secondsBigInt).toString());\n  }\n\n  if (secondParts.length) timeParts.push(`${secondParts.join('')}S`);\n  if (timeParts.length) timeParts.unshift('T');\n  if (!dateParts.length && !timeParts.length) return 'PT0S';\n  return `${sign < 0 ? '-' : ''}P${dateParts.join('')}${timeParts.join('')}`;\n}\n\nfunction TemporalDateToString(date, showCalendar = 'auto') {\n  const year = ISOYearString(GetSlot(date, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(date, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(date, ISO_DAY));\n  const calendarID = ToString(GetSlot(date, CALENDAR));\n  const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n  return `${year}-${month}-${day}${calendar}`;\n}\n\nfunction TemporalDateTimeToString(dateTime, precision, showCalendar = 'auto', options = undefined) {\n  let year = GetSlot(dateTime, ISO_YEAR);\n  let month = GetSlot(dateTime, ISO_MONTH);\n  let day = GetSlot(dateTime, ISO_DAY);\n  let hour = GetSlot(dateTime, ISO_HOUR);\n  let minute = GetSlot(dateTime, ISO_MINUTE);\n  let second = GetSlot(dateTime, ISO_SECOND);\n  let millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n  let microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n  let nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n\n  if (options) {\n    const {\n      unit,\n      increment,\n      roundingMode\n    } = options;\n    ({\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n  }\n\n  const yearString = ISOYearString(year);\n  const monthString = ISODateTimePartString(month);\n  const dayString = ISODateTimePartString(day);\n  const hourString = ISODateTimePartString(hour);\n  const minuteString = ISODateTimePartString(minute);\n  const secondsString = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n  const calendarID = ToString(GetSlot(dateTime, CALENDAR));\n  const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n  return `${yearString}-${monthString}-${dayString}T${hourString}:${minuteString}${secondsString}${calendar}`;\n}\n\nfunction TemporalMonthDayToString(monthDay, showCalendar = 'auto') {\n  const month = ISODateTimePartString(GetSlot(monthDay, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(monthDay, ISO_DAY));\n  let resultString = `${month}-${day}`;\n  const calendar = GetSlot(monthDay, CALENDAR);\n  const calendarID = ToString(calendar);\n\n  if (calendarID !== 'iso8601') {\n    const year = ISOYearString(GetSlot(monthDay, ISO_YEAR));\n    resultString = `${year}-${resultString}`;\n  }\n\n  const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nfunction TemporalYearMonthToString(yearMonth, showCalendar = 'auto') {\n  const year = ISOYearString(GetSlot(yearMonth, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(yearMonth, ISO_MONTH));\n  let resultString = `${year}-${month}`;\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const calendarID = ToString(calendar);\n\n  if (calendarID !== 'iso8601') {\n    const day = ISODateTimePartString(GetSlot(yearMonth, ISO_DAY));\n    resultString += `-${day}`;\n  }\n\n  const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nfunction TemporalZonedDateTimeToString(zdt, precision, showCalendar = 'auto', showTimeZone = 'auto', showOffset = 'auto', options = undefined) {\n  let instant = GetSlot(zdt, INSTANT);\n\n  if (options) {\n    const {\n      unit,\n      increment,\n      roundingMode\n    } = options;\n    const ns = RoundInstant(GetSlot(zdt, EPOCHNANOSECONDS), increment, unit, roundingMode);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    instant = new TemporalInstant(ns);\n  }\n\n  const tz = GetSlot(zdt, TIME_ZONE);\n  const iso = GetISO8601Calendar();\n  const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(tz, instant, iso);\n  const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n  const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n  const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n  const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n  const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n  const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n  let result = `${year}-${month}-${day}T${hour}:${minute}${seconds}`;\n\n  if (showOffset !== 'never') {\n    const offsetNs = GetOffsetNanosecondsFor(tz, instant);\n    result += FormatISOTimeZoneOffsetString(offsetNs);\n  }\n\n  if (showTimeZone !== 'never') result += `[${tz}]`;\n  const calendarID = ToString(GetSlot(zdt, CALENDAR));\n  result += FormatCalendarAnnotation(calendarID, showCalendar);\n  return result;\n}\n\nfunction TestTimeZoneOffsetString(string) {\n  return OFFSET.test(StringCtor(string));\n}\n\nfunction ParseTimeZoneOffsetString(string) {\n  const match = OFFSET.exec(StringCtor(string));\n\n  if (!match) {\n    throw new RangeError(`invalid time zone offset: ${string}`);\n  }\n\n  const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : +1;\n  const hours = +match[2];\n  const minutes = +(match[3] || 0);\n  const seconds = +(match[4] || 0);\n  const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n  return sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n}\n\nfunction GetCanonicalTimeZoneIdentifier(timeZoneIdentifier) {\n  if (TestTimeZoneOffsetString(timeZoneIdentifier)) {\n    const offsetNs = ParseTimeZoneOffsetString(timeZoneIdentifier);\n    return FormatTimeZoneOffsetString(offsetNs);\n  }\n\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(StringCtor(timeZoneIdentifier));\n  return formatter.resolvedOptions().timeZone;\n}\n\nfunction GetIANATimeZoneOffsetNanoseconds(epochNanoseconds, id) {\n  const {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  } = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n  const utc = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (utc === null) throw new RangeError('Date outside of supported range');\n  return JSBI.toNumber(JSBI.subtract(utc, epochNanoseconds));\n}\n\nfunction FormatTimeZoneOffsetString(offsetNanosecondsParam) {\n  const sign = offsetNanosecondsParam < 0 ? '-' : '+';\n  const offsetNanoseconds = MathAbs(offsetNanosecondsParam);\n  const nanoseconds = offsetNanoseconds % 1e9;\n  const seconds = MathFloor(offsetNanoseconds / 1e9) % 60;\n  const minutes = MathFloor(offsetNanoseconds / 60e9) % 60;\n  const hours = MathFloor(offsetNanoseconds / 3600e9);\n  const hourString = ISODateTimePartString(hours);\n  const minuteString = ISODateTimePartString(minutes);\n  const secondString = ISODateTimePartString(seconds);\n  let post = '';\n\n  if (nanoseconds) {\n    let fraction = `${nanoseconds}`.padStart(9, '0');\n\n    while (fraction[fraction.length - 1] === '0') fraction = fraction.slice(0, -1);\n\n    post = `:${secondString}.${fraction}`;\n  } else if (seconds) {\n    post = `:${secondString}`;\n  }\n\n  return `${sign}${hourString}:${minuteString}${post}`;\n}\n\nfunction FormatISOTimeZoneOffsetString(offsetNanosecondsParam) {\n  let offsetNanoseconds = JSBI.toNumber(RoundNumberToIncrement(JSBI.BigInt(offsetNanosecondsParam), 60e9, 'halfExpand'));\n  const sign = offsetNanoseconds < 0 ? '-' : '+';\n  offsetNanoseconds = MathAbs(offsetNanoseconds);\n  const minutes = offsetNanoseconds / 60e9 % 60;\n  const hours = MathFloor(offsetNanoseconds / 3600e9);\n  const hourString = ISODateTimePartString(hours);\n  const minuteString = ISODateTimePartString(minutes);\n  return `${sign}${hourString}:${minuteString}`;\n}\n\nfunction GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n  // Note: Date.UTC() interprets one and two-digit years as being in the\n  // 20th century, so don't use it\n  const legacyDate = new Date();\n  legacyDate.setUTCHours(hour, minute, second, millisecond);\n  legacyDate.setUTCFullYear(year, month - 1, day);\n  const ms = legacyDate.getTime();\n  if (NumberIsNaN(ms)) return null;\n  let ns = JSBI.multiply(JSBI.BigInt(ms), MILLION);\n  ns = JSBI.add(ns, JSBI.multiply(JSBI.BigInt(microsecond), THOUSAND));\n  ns = JSBI.add(ns, JSBI.BigInt(nanosecond));\n  if (JSBI.lessThan(ns, NS_MIN) || JSBI.greaterThan(ns, NS_MAX)) return null;\n  return ns;\n}\n\nfunction GetISOPartsFromEpoch(epochNanoseconds) {\n  const {\n    quotient,\n    remainder\n  } = divmod(epochNanoseconds, MILLION);\n  let epochMilliseconds = JSBI.toNumber(quotient);\n  let nanos = JSBI.toNumber(remainder);\n\n  if (nanos < 0) {\n    nanos += 1e6;\n    epochMilliseconds -= 1;\n  }\n\n  const microsecond = MathFloor(nanos / 1e3) % 1e3;\n  const nanosecond = nanos % 1e3;\n  const item = new Date(epochMilliseconds);\n  const year = item.getUTCFullYear();\n  const month = item.getUTCMonth() + 1;\n  const day = item.getUTCDate();\n  const hour = item.getUTCHours();\n  const minute = item.getUTCMinutes();\n  const second = item.getUTCSeconds();\n  const millisecond = item.getUTCMilliseconds();\n  return {\n    epochMilliseconds,\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n} // ts-prune-ignore-next TODO: remove this after tests are converted to TS\n\n\nfunction GetIANATimeZoneDateTimeParts(epochNanoseconds, id) {\n  const {\n    epochMilliseconds,\n    millisecond,\n    microsecond,\n    nanosecond\n  } = GetISOPartsFromEpoch(epochNanoseconds);\n  const {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second\n  } = GetFormatterParts(id, epochMilliseconds);\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nfunction maxJSBI(one, two) {\n  return JSBI.lessThan(one, two) ? two : one;\n}\n/**\n * Our best guess at how far in advance new rules will be put into the TZDB for\n * future offset transitions. We'll pick 10 years but can always revise it if\n * we find that countries are being unusually proactive in their announcing\n * of offset changes.\n */\n\n\nfunction afterLatestPossibleTzdbRuleChange() {\n  return JSBI.add(SystemUTCEpochNanoSeconds(), ABOUT_TEN_YEARS_NANOS);\n}\n\nfunction GetIANATimeZoneNextTransition(epochNanoseconds, id) {\n  // Decide how far in the future after `epochNanoseconds` we'll look for an\n  // offset change. There are two cases:\n  // 1. If it's a past date (or a date in the near future) then it's possible\n  //    that the time zone may have newly added DST in the next few years. So\n  //    we'll have to look from the provided time until a few years after the\n  //    current system time. (Changes to DST policy are usually announced a few\n  //    years in the future.) Note that the first DST anywhere started in 1847,\n  //    so we'll start checks in 1847 instead of wasting cycles on years where\n  //    there will never be transitions.\n  // 2. If it's a future date beyond the next few years, then we'll just assume\n  //    that the latest DST policy in TZDB will still be in effect.  In this\n  //    case, we only need to look one year in the future to see if there are\n  //    any DST transitions.  We actually only need to look 9-10 months because\n  //    DST has two transitions per year, but we'll use a year just to be safe.\n  const oneYearLater = JSBI.add(epochNanoseconds, ABOUT_ONE_YEAR_NANOS);\n  const uppercap = maxJSBI(afterLatestPossibleTzdbRuleChange(), oneYearLater); // The first transition (in any timezone) recorded in the TZDB was in 1847, so\n  // start there if an earlier date is supplied.\n\n  let leftNanos = maxJSBI(BEFORE_FIRST_OFFSET_TRANSITION, epochNanoseconds);\n  const leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n  let rightNanos = leftNanos;\n  let rightOffsetNs = leftOffsetNs;\n\n  while (leftOffsetNs === rightOffsetNs && JSBI.lessThan(JSBI.BigInt(leftNanos), uppercap)) {\n    rightNanos = JSBI.add(leftNanos, TWO_WEEKS_NANOS);\n    rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n\n    if (leftOffsetNs === rightOffsetNs) {\n      leftNanos = rightNanos;\n    }\n  }\n\n  if (leftOffsetNs === rightOffsetNs) return null;\n  const result = bisect(epochNs => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n  return result;\n}\n\nfunction GetIANATimeZonePreviousTransition(epochNanoseconds, id) {\n  // If a time zone uses DST (at the time of `epochNanoseconds`), then we only\n  // have to look back one year to find a transition. But if it doesn't use DST,\n  // then we need to look all the way back to 1847 (the earliest rule in the\n  // TZDB) to see if it had other offset transitions in the past. Looping back\n  // from a far-future date to 1847 is very slow (minutes of 100% CPU!), and is\n  // also unnecessary because DST rules aren't put into the TZDB more than a few\n  // years in the future because the political changes in time zones happen with\n  // only a few years' warning. Therefore, if a far-future date is provided,\n  // then we'll run the check in two parts:\n  // 1. First, we'll look back for up to one year to see if the latest TZDB\n  //    rules have DST.\n  // 2. If not, then we'll \"fast-reverse\" back to a few years later than the\n  //    current system time, and then look back to 1847. This reduces the\n  //    worst-case loop from 273K years to 175 years, for a ~1500x improvement\n  //    in worst-case perf.\n  const afterLatestRule = afterLatestPossibleTzdbRuleChange();\n  const isFarFuture = JSBI.greaterThan(epochNanoseconds, afterLatestRule);\n  const lowercap = isFarFuture ? JSBI.subtract(epochNanoseconds, ABOUT_ONE_YEAR_NANOS) : BEFORE_FIRST_OFFSET_TRANSITION;\n  let rightNanos = JSBI.subtract(epochNanoseconds, ONE);\n  const rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n  let leftNanos = rightNanos;\n  let leftOffsetNs = rightOffsetNs;\n\n  while (rightOffsetNs === leftOffsetNs && JSBI.greaterThan(rightNanos, lowercap)) {\n    leftNanos = JSBI.subtract(rightNanos, TWO_WEEKS_NANOS);\n    leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n\n    if (rightOffsetNs === leftOffsetNs) {\n      rightNanos = leftNanos;\n    }\n  }\n\n  if (rightOffsetNs === leftOffsetNs) {\n    if (isFarFuture) {\n      // There was no DST after looking back one year, which means that the most\n      // recent TZDB rules don't have any recurring transitions. To check for\n      // transitions in older rules, back up to a few years after the current\n      // date and then look all the way back to 1847. Note that we move back one\n      // day from the latest possible rule so that when the recursion runs it\n      // won't consider the new time to be \"far future\" because the system clock\n      // has advanced in the meantime.\n      const newTimeToCheck = JSBI.subtract(afterLatestRule, DAY_NANOS);\n      return GetIANATimeZonePreviousTransition(newTimeToCheck, id);\n    }\n\n    return null;\n  }\n\n  const result = bisect(epochNs => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n  return result;\n} // ts-prune-ignore-next TODO: remove this after tests are converted to TS\n\n\nfunction parseFromEnUsFormat(datetime) {\n  const parts = datetime.split(/[^\\w]+/);\n\n  if (parts.length !== 7) {\n    throw new RangeError(`expected 7 parts in \"${datetime}`);\n  }\n\n  const month = +parts[0];\n  const day = +parts[1];\n  let year = +parts[2];\n  const era = parts[3].toUpperCase();\n\n  if (era === 'B' || era === 'BC') {\n    year = -year + 1;\n  } else if (era !== 'A' && era !== 'AD') {\n    throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n  }\n\n  let hour = +parts[4];\n\n  if (hour === 24) {\n    // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n    hour = 0;\n  }\n\n  const minute = +parts[5];\n  const second = +parts[6];\n\n  if (!NumberIsFinite(year) || !NumberIsFinite(month) || !NumberIsFinite(day) || !NumberIsFinite(hour) || !NumberIsFinite(minute) || !NumberIsFinite(second)) {\n    throw new RangeError(`Invalid number in \"${datetime}`);\n  }\n\n  return {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second\n  };\n} // ts-prune-ignore-next TODO: remove this after tests are converted to TS\n\n\nfunction GetFormatterParts(timeZone, epochMilliseconds) {\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone); // Using `format` instead of `formatToParts` for compatibility with older clients\n\n  const datetime = formatter.format(new Date(epochMilliseconds));\n  return parseFromEnUsFormat(datetime);\n}\n\nfunction GetIANATimeZoneEpochValue(id, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n  const ns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  if (ns === null) throw new RangeError('DateTime outside of supported range');\n  let nsEarlier = JSBI.subtract(ns, DAY_NANOS);\n  if (JSBI.lessThan(nsEarlier, NS_MIN)) nsEarlier = ns;\n  let nsLater = JSBI.add(ns, DAY_NANOS);\n  if (JSBI.greaterThan(nsLater, NS_MAX)) nsLater = ns;\n  const earliest = GetIANATimeZoneOffsetNanoseconds(nsEarlier, id);\n  const latest = GetIANATimeZoneOffsetNanoseconds(nsLater, id);\n  const found = earliest === latest ? [earliest] : [earliest, latest];\n  return found.map(offsetNanoseconds => {\n    const epochNanoseconds = JSBI.subtract(ns, JSBI.BigInt(offsetNanoseconds));\n    const parts = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n\n    if (year !== parts.year || month !== parts.month || day !== parts.day || hour !== parts.hour || minute !== parts.minute || second !== parts.second || millisecond !== parts.millisecond || microsecond !== parts.microsecond || nanosecond !== parts.nanosecond) {\n      return undefined;\n    }\n\n    return epochNanoseconds;\n  }).filter(x => x !== undefined);\n}\n\nfunction LeapYear(year) {\n  if (undefined === year) return false;\n  const isDiv4 = year % 4 === 0;\n  const isDiv100 = year % 100 === 0;\n  const isDiv400 = year % 400 === 0;\n  return isDiv4 && (!isDiv100 || isDiv400);\n}\n\nfunction ISODaysInMonth(year, month) {\n  const DoM = {\n    standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n    leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  };\n  return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\n\nfunction DayOfWeek(year, month, day) {\n  const m = month + (month < 3 ? 10 : -2);\n  const Y = year - (month < 3 ? 1 : 0);\n  const c = MathFloor(Y / 100);\n  const y = Y - c * 100;\n  const d = day;\n  const pD = d;\n  const pM = MathFloor(2.6 * m - 0.2);\n  const pY = y + MathFloor(y / 4);\n  const pC = MathFloor(c / 4) - 2 * c;\n  const dow = (pD + pM + pY + pC) % 7;\n  return dow + (dow <= 0 ? 7 : 0);\n}\n\nfunction DayOfYear(year, month, day) {\n  let days = day;\n\n  for (let m = month - 1; m > 0; m--) {\n    days += ISODaysInMonth(year, m);\n  }\n\n  return days;\n}\n\nfunction WeekOfYear(year, month, day) {\n  const doy = DayOfYear(year, month, day);\n  const dow = DayOfWeek(year, month, day) || 7;\n  const doj = DayOfWeek(year, 1, 1);\n  const week = MathFloor((doy - dow + 10) / 7);\n\n  if (week < 1) {\n    if (doj === 5 || doj === 6 && LeapYear(year - 1)) {\n      return 53;\n    } else {\n      return 52;\n    }\n  }\n\n  if (week === 53) {\n    if ((LeapYear(year) ? 366 : 365) - doy < 4 - dow) {\n      return 1;\n    }\n  }\n\n  return week;\n}\n\nfunction DurationSign(y, mon, w, d, h, min, s, ms, µs, ns) {\n  for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n    if (prop !== 0) return prop < 0 ? -1 : 1;\n  }\n\n  return 0;\n}\n\nfunction BalanceISOYearMonth(yearParam, monthParam) {\n  let year = yearParam;\n  let month = monthParam;\n  if (!NumberIsFinite(year) || !NumberIsFinite(month)) throw new RangeError('infinity is out of range');\n  month -= 1;\n  year += MathFloor(month / 12);\n  month %= 12;\n  if (month < 0) month += 12;\n  month += 1;\n  return {\n    year,\n    month\n  };\n}\n\nfunction BalanceISODate(yearParam, monthParam, dayParam) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  if (!NumberIsFinite(day)) throw new RangeError('infinity is out of range');\n  ({\n    year,\n    month\n  } = BalanceISOYearMonth(year, month));\n  let daysInYear = 0;\n  let testYear = month > 2 ? year : year - 1;\n\n  while (daysInYear = LeapYear(testYear) ? 366 : 365, day < -daysInYear) {\n    year -= 1;\n    testYear -= 1;\n    day += daysInYear;\n  }\n\n  testYear += 1;\n\n  while (daysInYear = LeapYear(testYear) ? 366 : 365, day > daysInYear) {\n    year += 1;\n    testYear += 1;\n    day -= daysInYear;\n  }\n\n  while (day < 1) {\n    ({\n      year,\n      month\n    } = BalanceISOYearMonth(year, month - 1));\n    day += ISODaysInMonth(year, month);\n  }\n\n  while (day > ISODaysInMonth(year, month)) {\n    day -= ISODaysInMonth(year, month);\n    ({\n      year,\n      month\n    } = BalanceISOYearMonth(year, month + 1));\n  }\n\n  return {\n    year,\n    month,\n    day\n  };\n}\n\nfunction BalanceISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n  const {\n    deltaDays,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  } = BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam);\n  const {\n    year,\n    month,\n    day\n  } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n  return {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n}\n\nfunction BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n\n  if (!NumberIsFinite(hour) || !NumberIsFinite(minute) || !NumberIsFinite(second) || !NumberIsFinite(millisecond) || !NumberIsFinite(microsecond) || !NumberIsFinite(nanosecond)) {\n    throw new RangeError('infinity is out of range');\n  }\n\n  microsecond += MathFloor(nanosecond / 1000);\n  nanosecond = NonNegativeModulo(nanosecond, 1000);\n  millisecond += MathFloor(microsecond / 1000);\n  microsecond = NonNegativeModulo(microsecond, 1000);\n  second += MathFloor(millisecond / 1000);\n  millisecond = NonNegativeModulo(millisecond, 1000);\n  minute += MathFloor(second / 60);\n  second = NonNegativeModulo(second, 60);\n  hour += MathFloor(minute / 60);\n  minute = NonNegativeModulo(minute, 60);\n  const deltaDays = MathFloor(hour / 24);\n  hour = NonNegativeModulo(hour, 24);\n  return {\n    deltaDays,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n}\n\nfunction TotalDurationNanoseconds(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, offsetShift) {\n  const days = JSBI.BigInt(daysParam);\n  let nanoseconds = JSBI.BigInt(nanosecondsParam);\n  if (daysParam !== 0) nanoseconds = JSBI.subtract(JSBI.BigInt(nanosecondsParam), JSBI.BigInt(offsetShift));\n  const hours = JSBI.add(JSBI.BigInt(hoursParam), JSBI.multiply(days, JSBI.BigInt(24)));\n  const minutes = JSBI.add(JSBI.BigInt(minutesParam), JSBI.multiply(hours, SIXTY));\n  const seconds = JSBI.add(JSBI.BigInt(secondsParam), JSBI.multiply(minutes, SIXTY));\n  const milliseconds = JSBI.add(JSBI.BigInt(millisecondsParam), JSBI.multiply(seconds, THOUSAND));\n  const microseconds = JSBI.add(JSBI.BigInt(microsecondsParam), JSBI.multiply(milliseconds, THOUSAND));\n  return JSBI.add(JSBI.BigInt(nanoseconds), JSBI.multiply(microseconds, THOUSAND));\n}\n\nfunction NanosecondsToDays(nanosecondsParam, relativeTo) {\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const sign = MathSign(JSBI.toNumber(nanosecondsParam));\n  let nanoseconds = JSBI.BigInt(nanosecondsParam);\n  let dayLengthNs = 86400e9;\n  if (sign === 0) return {\n    days: 0,\n    nanoseconds: ZERO,\n    dayLengthNs\n  };\n\n  if (!IsTemporalZonedDateTime(relativeTo)) {\n    let days;\n    ({\n      quotient: days,\n      remainder: nanoseconds\n    } = divmod(nanoseconds, JSBI.BigInt(dayLengthNs)));\n    return {\n      days: JSBI.toNumber(days),\n      nanoseconds,\n      dayLengthNs\n    };\n  }\n\n  const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n  const start = GetSlot(relativeTo, INSTANT);\n  const endNs = JSBI.add(startNs, nanoseconds);\n  const end = new TemporalInstant(endNs);\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR); // Find the difference in days only.\n\n  const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n  const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n  let {\n    days\n  } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, 'day');\n  let intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0); // may disambiguate\n  // If clock time after addition was in the middle of a skipped period, the\n  // endpoint was disambiguated to a later clock time. So it's possible that\n  // the resulting disambiguated result is later than endNs. If so, then back\n  // up one day and try again. Repeat if necessary (some transitions are\n  // > 24 hours) until either there's zero days left or the date duration is\n  // back inside the period where it belongs. Note that this case only can\n  // happen for positive durations because the only direction that\n  // `disambiguation: 'compatible'` can change clock time is forwards.\n\n  if (sign === 1) {\n    while (days > 0 && JSBI.greaterThan(intermediateNs, endNs)) {\n      --days;\n      intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0); // may do disambiguation\n    }\n  }\n\n  nanoseconds = JSBI.subtract(endNs, intermediateNs);\n  let isOverflow = false;\n  let relativeInstant = new TemporalInstant(intermediateNs);\n\n  do {\n    // calculate length of the next day (day that contains the time remainder)\n    const oneDayFartherNs = AddZonedDateTime(relativeInstant, timeZone, calendar, 0, 0, 0, sign, 0, 0, 0, 0, 0, 0);\n    const relativeNs = GetSlot(relativeInstant, EPOCHNANOSECONDS);\n    dayLengthNs = JSBI.toNumber(JSBI.subtract(oneDayFartherNs, relativeNs));\n    isOverflow = JSBI.greaterThan(JSBI.multiply(JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs)), JSBI.BigInt(sign)), ZERO);\n\n    if (isOverflow) {\n      nanoseconds = JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs));\n      relativeInstant = new TemporalInstant(oneDayFartherNs);\n      days += sign;\n    }\n  } while (isOverflow);\n\n  return {\n    days,\n    nanoseconds,\n    dayLengthNs: MathAbs(dayLengthNs)\n  };\n}\n\nfunction BalanceDuration(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, largestUnit, relativeTo = undefined) {\n  let days = daysParam;\n  let nanosecondsBigInt, microsecondsBigInt, millisecondsBigInt, secondsBigInt, minutesBigInt, hoursBigInt;\n\n  if (IsTemporalZonedDateTime(relativeTo)) {\n    const endNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), GetSlot(relativeTo, TIME_ZONE), GetSlot(relativeTo, CALENDAR), 0, 0, 0, days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam);\n    const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n    nanosecondsBigInt = JSBI.subtract(endNs, startNs);\n  } else {\n    nanosecondsBigInt = TotalDurationNanoseconds(days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, 0);\n  }\n\n  if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week' || largestUnit === 'day') {\n    ({\n      days,\n      nanoseconds: nanosecondsBigInt\n    } = NanosecondsToDays(nanosecondsBigInt, relativeTo));\n  } else {\n    days = 0;\n  }\n\n  const sign = JSBI.lessThan(nanosecondsBigInt, ZERO) ? -1 : 1;\n  nanosecondsBigInt = abs(nanosecondsBigInt);\n  microsecondsBigInt = millisecondsBigInt = secondsBigInt = minutesBigInt = hoursBigInt = ZERO;\n\n  switch (largestUnit) {\n    case 'year':\n    case 'month':\n    case 'week':\n    case 'day':\n    case 'hour':\n      ({\n        quotient: microsecondsBigInt,\n        remainder: nanosecondsBigInt\n      } = divmod(nanosecondsBigInt, THOUSAND));\n      ({\n        quotient: millisecondsBigInt,\n        remainder: microsecondsBigInt\n      } = divmod(microsecondsBigInt, THOUSAND));\n      ({\n        quotient: secondsBigInt,\n        remainder: millisecondsBigInt\n      } = divmod(millisecondsBigInt, THOUSAND));\n      ({\n        quotient: minutesBigInt,\n        remainder: secondsBigInt\n      } = divmod(secondsBigInt, SIXTY));\n      ({\n        quotient: hoursBigInt,\n        remainder: minutesBigInt\n      } = divmod(minutesBigInt, SIXTY));\n      break;\n\n    case 'minute':\n      ({\n        quotient: microsecondsBigInt,\n        remainder: nanosecondsBigInt\n      } = divmod(nanosecondsBigInt, THOUSAND));\n      ({\n        quotient: millisecondsBigInt,\n        remainder: microsecondsBigInt\n      } = divmod(microsecondsBigInt, THOUSAND));\n      ({\n        quotient: secondsBigInt,\n        remainder: millisecondsBigInt\n      } = divmod(millisecondsBigInt, THOUSAND));\n      ({\n        quotient: minutesBigInt,\n        remainder: secondsBigInt\n      } = divmod(secondsBigInt, SIXTY));\n      break;\n\n    case 'second':\n      ({\n        quotient: microsecondsBigInt,\n        remainder: nanosecondsBigInt\n      } = divmod(nanosecondsBigInt, THOUSAND));\n      ({\n        quotient: millisecondsBigInt,\n        remainder: microsecondsBigInt\n      } = divmod(microsecondsBigInt, THOUSAND));\n      ({\n        quotient: secondsBigInt,\n        remainder: millisecondsBigInt\n      } = divmod(millisecondsBigInt, THOUSAND));\n      break;\n\n    case 'millisecond':\n      ({\n        quotient: microsecondsBigInt,\n        remainder: nanosecondsBigInt\n      } = divmod(nanosecondsBigInt, THOUSAND));\n      ({\n        quotient: millisecondsBigInt,\n        remainder: microsecondsBigInt\n      } = divmod(microsecondsBigInt, THOUSAND));\n      break;\n\n    case 'microsecond':\n      ({\n        quotient: microsecondsBigInt,\n        remainder: nanosecondsBigInt\n      } = divmod(nanosecondsBigInt, THOUSAND));\n      break;\n\n    case 'nanosecond':\n      break;\n\n    default:\n      throw new Error('assert not reached');\n  }\n\n  const hours = JSBI.toNumber(hoursBigInt) * sign;\n  const minutes = JSBI.toNumber(minutesBigInt) * sign;\n  const seconds = JSBI.toNumber(secondsBigInt) * sign;\n  const milliseconds = JSBI.toNumber(millisecondsBigInt) * sign;\n  const microseconds = JSBI.toNumber(microsecondsBigInt) * sign;\n  const nanoseconds = JSBI.toNumber(nanosecondsBigInt) * sign;\n  return {\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  };\n}\n\nfunction UnbalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  let calendar;\n  let relativeTo;\n\n  if (relativeToParam) {\n    relativeTo = ToTemporalDate(relativeToParam);\n    calendar = GetSlot(relativeTo, CALENDAR);\n  }\n\n  const oneYear = new TemporalDuration(sign);\n  const oneMonth = new TemporalDuration(0, sign);\n  const oneWeek = new TemporalDuration(0, 0, sign);\n\n  switch (largestUnit) {\n    case 'year':\n      // no-op\n      break;\n\n    case 'month':\n      {\n        if (!calendar) throw new RangeError('a starting point is required for months balancing'); // balance years down to months\n\n        const dateAdd = calendar.dateAdd;\n        const dateUntil = calendar.dateUntil;\n        let relativeToDateOnly = relativeTo;\n\n        while (MathAbs(years) > 0) {\n          const addOptions = ObjectCreate$2(null);\n          const newRelativeTo = CalendarDateAdd(calendar, relativeToDateOnly, oneYear, addOptions, dateAdd);\n          const untilOptions = ObjectCreate$2(null);\n          untilOptions.largestUnit = 'month';\n          const untilResult = CalendarDateUntil(calendar, relativeToDateOnly, newRelativeTo, untilOptions, dateUntil);\n          const oneYearMonths = GetSlot(untilResult, MONTHS);\n          relativeToDateOnly = newRelativeTo;\n          months += oneYearMonths;\n          years -= sign;\n        }\n      }\n      break;\n\n    case 'week':\n      if (!calendar) throw new RangeError('a starting point is required for weeks balancing'); // balance years down to days\n\n      while (MathAbs(years) > 0) {\n        let oneYearDays;\n        ({\n          relativeTo,\n          days: oneYearDays\n        } = MoveRelativeDate(calendar, relativeTo, oneYear));\n        days += oneYearDays;\n        years -= sign;\n      } // balance months down to days\n\n\n      while (MathAbs(months) > 0) {\n        let oneMonthDays;\n        ({\n          relativeTo,\n          days: oneMonthDays\n        } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n        days += oneMonthDays;\n        months -= sign;\n      }\n\n      break;\n\n    default:\n      // balance years down to days\n      while (MathAbs(years) > 0) {\n        if (!calendar) throw new RangeError('a starting point is required for balancing calendar units');\n        let oneYearDays;\n        ({\n          relativeTo,\n          days: oneYearDays\n        } = MoveRelativeDate(calendar, relativeTo, oneYear));\n        days += oneYearDays;\n        years -= sign;\n      } // balance months down to days\n\n\n      while (MathAbs(months) > 0) {\n        if (!calendar) throw new RangeError('a starting point is required for balancing calendar units');\n        let oneMonthDays;\n        ({\n          relativeTo,\n          days: oneMonthDays\n        } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n        days += oneMonthDays;\n        months -= sign;\n      } // balance weeks down to days\n\n\n      while (MathAbs(weeks) > 0) {\n        if (!calendar) throw new RangeError('a starting point is required for balancing calendar units');\n        let oneWeekDays;\n        ({\n          relativeTo,\n          days: oneWeekDays\n        } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n        days += oneWeekDays;\n        weeks -= sign;\n      }\n\n      break;\n  }\n\n  return {\n    years,\n    months,\n    weeks,\n    days\n  };\n}\n\nfunction BalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  if (sign === 0) return {\n    years,\n    months,\n    weeks,\n    days\n  };\n  let calendar;\n  let relativeTo;\n\n  if (relativeToParam) {\n    relativeTo = ToTemporalDate(relativeToParam);\n    calendar = GetSlot(relativeTo, CALENDAR);\n  }\n\n  const oneYear = new TemporalDuration(sign);\n  const oneMonth = new TemporalDuration(0, sign);\n  const oneWeek = new TemporalDuration(0, 0, sign);\n\n  switch (largestUnit) {\n    case 'year':\n      {\n        if (!calendar) throw new RangeError('a starting point is required for years balancing'); // balance days up to years\n\n        let newRelativeTo, oneYearDays;\n        ({\n          relativeTo: newRelativeTo,\n          days: oneYearDays\n        } = MoveRelativeDate(calendar, relativeTo, oneYear));\n\n        while (MathAbs(days) >= MathAbs(oneYearDays)) {\n          days -= oneYearDays;\n          years += sign;\n          relativeTo = newRelativeTo;\n          ({\n            relativeTo: newRelativeTo,\n            days: oneYearDays\n          } = MoveRelativeDate(calendar, relativeTo, oneYear));\n        } // balance days up to months\n\n\n        let oneMonthDays;\n        ({\n          relativeTo: newRelativeTo,\n          days: oneMonthDays\n        } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n\n        while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n          days -= oneMonthDays;\n          months += sign;\n          relativeTo = newRelativeTo;\n          ({\n            relativeTo: newRelativeTo,\n            days: oneMonthDays\n          } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n        } // balance months up to years\n\n\n        const dateAdd = calendar.dateAdd;\n        const addOptions = ObjectCreate$2(null);\n        newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n        const dateUntil = calendar.dateUntil;\n        const untilOptions = ObjectCreate$2(null);\n        untilOptions.largestUnit = 'month';\n        let untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n        let oneYearMonths = GetSlot(untilResult, MONTHS);\n\n        while (MathAbs(months) >= MathAbs(oneYearMonths)) {\n          months -= oneYearMonths;\n          years += sign;\n          relativeTo = newRelativeTo;\n          const addOptions = ObjectCreate$2(null);\n          newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n          const untilOptions = ObjectCreate$2(null);\n          untilOptions.largestUnit = 'month';\n          untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n          oneYearMonths = GetSlot(untilResult, MONTHS);\n        }\n\n        break;\n      }\n\n    case 'month':\n      {\n        if (!calendar) throw new RangeError('a starting point is required for months balancing'); // balance days up to months\n\n        let newRelativeTo, oneMonthDays;\n        ({\n          relativeTo: newRelativeTo,\n          days: oneMonthDays\n        } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n\n        while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n          days -= oneMonthDays;\n          months += sign;\n          relativeTo = newRelativeTo;\n          ({\n            relativeTo: newRelativeTo,\n            days: oneMonthDays\n          } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n        }\n\n        break;\n      }\n\n    case 'week':\n      {\n        if (!calendar) throw new RangeError('a starting point is required for weeks balancing'); // balance days up to weeks\n\n        let newRelativeTo, oneWeekDays;\n        ({\n          relativeTo: newRelativeTo,\n          days: oneWeekDays\n        } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n\n        while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n          days -= oneWeekDays;\n          weeks += sign;\n          relativeTo = newRelativeTo;\n          ({\n            relativeTo: newRelativeTo,\n            days: oneWeekDays\n          } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n        }\n\n        break;\n      }\n  }\n\n  return {\n    years,\n    months,\n    weeks,\n    days\n  };\n}\n\nfunction CalculateOffsetShift(relativeTo, y, mon, w, d, h, min, s, ms, µs, ns) {\n  if (IsTemporalZonedDateTime(relativeTo)) {\n    const instant = GetSlot(relativeTo, INSTANT);\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const offsetBefore = GetOffsetNanosecondsFor(timeZone, instant);\n    const after = AddZonedDateTime(instant, timeZone, calendar, y, mon, w, d, h, min, s, ms, µs, ns);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const instantAfter = new TemporalInstant(after);\n    const offsetAfter = GetOffsetNanosecondsFor(timeZone, instantAfter);\n    return offsetAfter - offsetBefore;\n  }\n\n  return 0;\n}\n\nfunction CreateNegatedTemporalDuration(duration) {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(-GetSlot(duration, YEARS), -GetSlot(duration, MONTHS), -GetSlot(duration, WEEKS), -GetSlot(duration, DAYS), -GetSlot(duration, HOURS), -GetSlot(duration, MINUTES), -GetSlot(duration, SECONDS), -GetSlot(duration, MILLISECONDS), -GetSlot(duration, MICROSECONDS), -GetSlot(duration, NANOSECONDS));\n}\n\nfunction ConstrainToRange(value, min, max) {\n  // Math.Max accepts undefined values and returns NaN. Undefined values are\n  // used for optional params in the method below.\n  return MathMin(max, MathMax(min, value));\n}\n\nfunction ConstrainISODate(year, monthParam, dayParam) {\n  const month = ConstrainToRange(monthParam, 1, 12);\n  const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n  return {\n    year,\n    month,\n    day\n  };\n}\n\nfunction ConstrainTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n  const hour = ConstrainToRange(hourParam, 0, 23);\n  const minute = ConstrainToRange(minuteParam, 0, 59);\n  const second = ConstrainToRange(secondParam, 0, 59);\n  const millisecond = ConstrainToRange(millisecondParam, 0, 999);\n  const microsecond = ConstrainToRange(microsecondParam, 0, 999);\n  const nanosecond = ConstrainToRange(nanosecondParam, 0, 999);\n  return {\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n}\n\nfunction RejectToRange(value, min, max) {\n  if (value < min || value > max) throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\n\nfunction RejectISODate(year, month, day) {\n  RejectToRange(month, 1, 12);\n  RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\n\nfunction RejectDateRange(year, month, day) {\n  // Noon avoids trouble at edges of DateTime range (excludes midnight)\n  RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n}\n\nfunction RejectTime(hour, minute, second, millisecond, microsecond, nanosecond) {\n  RejectToRange(hour, 0, 23);\n  RejectToRange(minute, 0, 59);\n  RejectToRange(second, 0, 59);\n  RejectToRange(millisecond, 0, 999);\n  RejectToRange(microsecond, 0, 999);\n  RejectToRange(nanosecond, 0, 999);\n}\n\nfunction RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n  RejectISODate(year, month, day);\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nfunction RejectDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n  RejectToRange(year, YEAR_MIN, YEAR_MAX); // Reject any DateTime 24 hours or more outside the Instant range\n\n  if (year === YEAR_MIN && null == GetEpochFromISOParts(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1) || year === YEAR_MAX && null == GetEpochFromISOParts(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1)) {\n    throw new RangeError('DateTime outside of supported range');\n  }\n}\n\nfunction ValidateEpochNanoseconds(epochNanoseconds) {\n  if (JSBI.lessThan(epochNanoseconds, NS_MIN) || JSBI.greaterThan(epochNanoseconds, NS_MAX)) {\n    throw new RangeError('Instant outside of supported range');\n  }\n}\n\nfunction RejectYearMonthRange(year, month) {\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\n\n  if (year === YEAR_MIN) {\n    RejectToRange(month, 4, 12);\n  } else if (year === YEAR_MAX) {\n    RejectToRange(month, 1, 9);\n  }\n}\n\nfunction RejectDuration(y, mon, w, d, h, min, s, ms, µs, ns) {\n  const sign = DurationSign(y, mon, w, d, h, min, s, ms, µs, ns);\n\n  for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n    if (!NumberIsFinite(prop)) throw new RangeError('infinite values not allowed as duration fields');\n    const propSign = MathSign(prop);\n    if (propSign !== 0 && propSign !== sign) throw new RangeError('mixed-sign values not allowed as duration fields');\n  }\n}\n\nfunction DifferenceISODate(y1, m1, d1, y2, m2, d2, largestUnit) {\n  switch (largestUnit) {\n    case 'year':\n    case 'month':\n      {\n        const sign = -CompareISODate(y1, m1, d1, y2, m2, d2);\n        if (sign === 0) return {\n          years: 0,\n          months: 0,\n          weeks: 0,\n          days: 0\n        };\n        const start = {\n          year: y1,\n          month: m1,\n          day: d1\n        };\n        const end = {\n          year: y2,\n          month: m2,\n          day: d2\n        };\n        let years = end.year - start.year;\n        let mid = AddISODate(y1, m1, d1, years, 0, 0, 0, 'constrain');\n        let midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n\n        if (midSign === 0) {\n          return largestUnit === 'year' ? {\n            years,\n            months: 0,\n            weeks: 0,\n            days: 0\n          } : {\n            years: 0,\n            months: years * 12,\n            weeks: 0,\n            days: 0\n          };\n        }\n\n        let months = end.month - start.month;\n\n        if (midSign !== sign) {\n          years -= sign;\n          months += sign * 12;\n        }\n\n        mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n        midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n\n        if (midSign === 0) {\n          return largestUnit === 'year' ? {\n            years,\n            months,\n            weeks: 0,\n            days: 0\n          } : {\n            years: 0,\n            months: months + years * 12,\n            weeks: 0,\n            days: 0\n          };\n        }\n\n        if (midSign !== sign) {\n          // The end date is later in the month than mid date (or earlier for\n          // negative durations). Back up one month.\n          months -= sign;\n\n          if (months === -sign) {\n            years -= sign;\n            months = 11 * sign;\n          }\n\n          mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n          midSign = -CompareISODate(y1, m1, d1, mid.year, mid.month, mid.day);\n        }\n\n        let days = 0; // If we get here, months and years are correct (no overflow), and `mid`\n        // is within the range from `start` to `end`. To count the days between\n        // `mid` and `end`, there are 3 cases:\n        // 1) same month: use simple subtraction\n        // 2) end is previous month from intermediate (negative duration)\n        // 3) end is next month from intermediate (positive duration)\n\n        if (mid.month === end.month) {\n          // 1) same month: use simple subtraction\n          days = end.day - mid.day;\n        } else if (sign < 0) {\n          // 2) end is previous month from intermediate (negative duration)\n          // Example: intermediate: Feb 1, end: Jan 30, DaysInMonth = 31, days = -2\n          days = -mid.day - (ISODaysInMonth(end.year, end.month) - end.day);\n        } else {\n          // 3) end is next month from intermediate (positive duration)\n          // Example: intermediate: Jan 29, end: Feb 1, DaysInMonth = 31, days = 3\n          days = end.day + (ISODaysInMonth(mid.year, mid.month) - mid.day);\n        }\n\n        if (largestUnit === 'month') {\n          months += years * 12;\n          years = 0;\n        }\n\n        return {\n          years,\n          months,\n          weeks: 0,\n          days\n        };\n      }\n\n    case 'week':\n    case 'day':\n      {\n        let larger, smaller, sign;\n\n        if (CompareISODate(y1, m1, d1, y2, m2, d2) < 0) {\n          smaller = {\n            year: y1,\n            month: m1,\n            day: d1\n          };\n          larger = {\n            year: y2,\n            month: m2,\n            day: d2\n          };\n          sign = 1;\n        } else {\n          smaller = {\n            year: y2,\n            month: m2,\n            day: d2\n          };\n          larger = {\n            year: y1,\n            month: m1,\n            day: d1\n          };\n          sign = -1;\n        }\n\n        let days = DayOfYear(larger.year, larger.month, larger.day) - DayOfYear(smaller.year, smaller.month, smaller.day);\n\n        for (let year = smaller.year; year < larger.year; ++year) {\n          days += LeapYear(year) ? 366 : 365;\n        }\n\n        let weeks = 0;\n\n        if (largestUnit === 'week') {\n          weeks = MathFloor(days / 7);\n          days %= 7;\n        }\n\n        weeks *= sign;\n        days *= sign;\n        return {\n          years: 0,\n          months: 0,\n          weeks,\n          days\n        };\n      }\n\n    default:\n      throw new Error('assert not reached');\n  }\n}\n\nfunction DifferenceTime(h1, min1, s1, ms1, µs1, ns1, h2, min2, s2, ms2, µs2, ns2) {\n  let hours = h2 - h1;\n  let minutes = min2 - min1;\n  let seconds = s2 - s1;\n  let milliseconds = ms2 - ms1;\n  let microseconds = µs2 - µs1;\n  let nanoseconds = ns2 - ns1;\n  const sign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  hours *= sign;\n  minutes *= sign;\n  seconds *= sign;\n  milliseconds *= sign;\n  microseconds *= sign;\n  nanoseconds *= sign;\n  let deltaDays = 0;\n  ({\n    deltaDays,\n    hour: hours,\n    minute: minutes,\n    second: seconds,\n    millisecond: milliseconds,\n    microsecond: microseconds,\n    nanosecond: nanoseconds\n  } = BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n  deltaDays *= sign;\n  hours *= sign;\n  minutes *= sign;\n  seconds *= sign;\n  milliseconds *= sign;\n  microseconds *= sign;\n  nanoseconds *= sign;\n  return {\n    deltaDays,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  };\n}\n\nfunction DifferenceInstant(ns1, ns2, increment, unit, roundingMode) {\n  const diff = JSBI.subtract(ns2, ns1);\n  const remainder = JSBI.remainder(diff, JSBI.BigInt(86400e9));\n  const wholeDays = JSBI.subtract(diff, remainder);\n  const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n  const roundedDiff = JSBI.add(wholeDays, roundedRemainder);\n  const nanoseconds = JSBI.toNumber(JSBI.remainder(roundedDiff, THOUSAND));\n  const microseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(roundedDiff, THOUSAND), THOUSAND));\n  const milliseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(roundedDiff, MILLION), THOUSAND));\n  const seconds = JSBI.toNumber(JSBI.divide(roundedDiff, BILLION));\n  return {\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  };\n}\n\nfunction DifferenceISODateTime(y1Param, mon1Param, d1Param, h1, min1, s1, ms1, µs1, ns1, y2, mon2, d2, h2, min2, s2, ms2, µs2, ns2, calendar, largestUnit, options = ObjectCreate$2(null)) {\n  let y1 = y1Param;\n  let mon1 = mon1Param;\n  let d1 = d1Param;\n  let {\n    deltaDays,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  } = DifferenceTime(h1, min1, s1, ms1, µs1, ns1, h2, min2, s2, ms2, µs2, ns2);\n  const timeSign = DurationSign(0, 0, 0, deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  ({\n    year: y1,\n    month: mon1,\n    day: d1\n  } = BalanceISODate(y1, mon1, d1 + deltaDays));\n  const dateSign = CompareISODate(y2, mon2, d2, y1, mon1, d1);\n\n  if (dateSign === -timeSign) {\n    ({\n      year: y1,\n      month: mon1,\n      day: d1\n    } = BalanceISODate(y1, mon1, d1 - timeSign));\n    ({\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(-timeSign, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n  }\n\n  const date1 = CreateTemporalDate(y1, mon1, d1, calendar);\n  const date2 = CreateTemporalDate(y2, mon2, d2, calendar);\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n  const untilOptions = { ...options,\n    largestUnit: dateLargestUnit\n  };\n  let {\n    years,\n    months,\n    weeks,\n    days\n  } = CalendarDateUntil(calendar, date1, date2, untilOptions); // Signs of date part and time part may not agree; balance them together\n\n  ({\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n  return {\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  };\n}\n\nfunction DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, options) {\n  const nsDiff = JSBI.subtract(ns2, ns1);\n\n  if (JSBI.equal(nsDiff, ZERO)) {\n    return {\n      years: 0,\n      months: 0,\n      weeks: 0,\n      days: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: 0,\n      milliseconds: 0,\n      microseconds: 0,\n      nanoseconds: 0\n    };\n  } // Find the difference in dates only.\n\n\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const start = new TemporalInstant(ns1);\n  const end = new TemporalInstant(ns2);\n  const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n  const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n  let {\n    years,\n    months,\n    weeks,\n    days\n  } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, largestUnit, options);\n  const intermediateNs = AddZonedDateTime(start, timeZone, calendar, years, months, weeks, 0, 0, 0, 0, 0, 0, 0); // may disambiguate\n\n  let timeRemainderNs = JSBI.subtract(ns2, intermediateNs);\n  const intermediate = CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n  ({\n    nanoseconds: timeRemainderNs,\n    days\n  } = NanosecondsToDays(timeRemainderNs, intermediate)); // Finally, merge the date and time durations and return the merged result.\n\n  const {\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  } = BalanceDuration(0, 0, 0, 0, 0, 0, JSBI.toNumber(timeRemainderNs), 'hour');\n  return {\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  };\n}\n\nfunction AddISODate(yearParam, monthParam, dayParam, yearsParam, monthsParam, weeksParam, daysParam, overflow) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n  year += years;\n  month += months;\n  ({\n    year,\n    month\n  } = BalanceISOYearMonth(year, month));\n  ({\n    year,\n    month,\n    day\n  } = RegulateISODate(year, month, day, overflow));\n  days += 7 * weeks;\n  day += days;\n  ({\n    year,\n    month,\n    day\n  } = BalanceISODate(year, month, day));\n  return {\n    year,\n    month,\n    day\n  };\n}\n\nfunction AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n  hour += hours;\n  minute += minutes;\n  second += seconds;\n  millisecond += milliseconds;\n  microsecond += microseconds;\n  nanosecond += nanoseconds;\n  let deltaDays = 0;\n  ({\n    deltaDays,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  } = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond));\n  return {\n    deltaDays,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n}\n\nfunction AddDuration(y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1, y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2, relativeTo) {\n  const largestUnit1 = DefaultTemporalLargestUnit(y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1);\n  const largestUnit2 = DefaultTemporalLargestUnit(y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2);\n  const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n  let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n\n  if (!relativeTo) {\n    if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week') {\n      throw new RangeError('relativeTo is required for years, months, or weeks arithmetic');\n    }\n\n    years = months = weeks = 0;\n    ({\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(d1 + d2, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, µs1 + µs2, ns1 + ns2, largestUnit));\n  } else if (IsTemporalDate(relativeTo)) {\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const dateDuration1 = new TemporalDuration(y1, mon1, w1, d1, 0, 0, 0, 0, 0, 0);\n    const dateDuration2 = new TemporalDuration(y2, mon2, w2, d2, 0, 0, 0, 0, 0, 0);\n    const dateAdd = calendar.dateAdd;\n    const firstAddOptions = ObjectCreate$2(null);\n    const intermediate = CalendarDateAdd(calendar, relativeTo, dateDuration1, firstAddOptions, dateAdd);\n    const secondAddOptions = ObjectCreate$2(null);\n    const end = CalendarDateAdd(calendar, intermediate, dateDuration2, secondAddOptions, dateAdd);\n    const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n    const differenceOptions = ObjectCreate$2(null);\n    differenceOptions.largestUnit = dateLargestUnit;\n    ({\n      years,\n      months,\n      weeks,\n      days\n    } = CalendarDateUntil(calendar, relativeTo, end, differenceOptions)); // Signs of date part and time part may not agree; balance them together\n\n    ({\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(days, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, µs1 + µs2, ns1 + ns2, largestUnit));\n  } else {\n    // relativeTo is a ZonedDateTime\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1);\n    const endNs = AddZonedDateTime(new TemporalInstant(intermediateNs), timeZone, calendar, y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2);\n\n    if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n      // The user is only asking for a time difference, so return difference of instants.\n      years = 0;\n      months = 0;\n      weeks = 0;\n      days = 0;\n      ({\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = DifferenceInstant(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, 1, 'nanosecond', 'halfExpand'));\n      ({\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    } else {\n      ({\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = DifferenceZonedDateTime(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, timeZone, calendar, largestUnit));\n    }\n  }\n\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return {\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  };\n}\n\nfunction AddInstant(epochNanoseconds, h, min, s, ms, µs, ns) {\n  let sum = ZERO;\n  sum = JSBI.add(sum, JSBI.BigInt(ns));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(µs), THOUSAND));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(ms), MILLION));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(s), BILLION));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(min), JSBI.BigInt(60 * 1e9)));\n  sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(h), JSBI.BigInt(60 * 60 * 1e9)));\n  const result = JSBI.add(epochNanoseconds, sum);\n  ValidateEpochNanoseconds(result);\n  return result;\n}\n\nfunction AddDateTime(year, month, day, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, calendar, years, months, weeks, daysParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options) {\n  let days = daysParam; // Add the time part\n\n  let {\n    deltaDays,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  } = AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  days += deltaDays; // Delegate the date part addition to the calendar\n\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  const datePart = CreateTemporalDate(year, month, day, calendar);\n  const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n  return {\n    year: GetSlot(addedDate, ISO_YEAR),\n    month: GetSlot(addedDate, ISO_MONTH),\n    day: GetSlot(addedDate, ISO_DAY),\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n}\n\nfunction AddZonedDateTime(instant, timeZone, calendar, years, months, weeks, days, h, min, s, ms, µs, ns, options) {\n  // If only time is to be added, then use Instant math. It's not OK to fall\n  // through to the date/time code below because compatible disambiguation in\n  // the PlainDateTime=>Instant conversion will change the offset of any\n  // ZonedDateTime in the repeated clock time after a backwards transition.\n  // When adding/subtracting time units and not dates, this disambiguation is\n  // not expected and so is avoided below via a fast path for time-only\n  // arithmetic.\n  // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n\n  if (DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0) === 0) {\n    return AddInstant(GetSlot(instant, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n  } // RFC 5545 requires the date portion to be added in calendar days and the\n  // time portion to be added in exact time.\n\n\n  const dt = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar);\n  const datePart = CreateTemporalDate(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), calendar);\n  const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n  const dtIntermediate = CreateTemporalDateTime(GetSlot(addedDate, ISO_YEAR), GetSlot(addedDate, ISO_MONTH), GetSlot(addedDate, ISO_DAY), GetSlot(dt, ISO_HOUR), GetSlot(dt, ISO_MINUTE), GetSlot(dt, ISO_SECOND), GetSlot(dt, ISO_MILLISECOND), GetSlot(dt, ISO_MICROSECOND), GetSlot(dt, ISO_NANOSECOND), calendar); // Note that 'compatible' is used below because this disambiguation behavior\n  // is required by RFC 5545.\n\n  const instantIntermediate = BuiltinTimeZoneGetInstantFor(timeZone, dtIntermediate, 'compatible');\n  return AddInstant(GetSlot(instantIntermediate, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n}\n\nfunction RoundNumberToIncrement(quantity, increment, mode) {\n  if (increment === 1) return quantity;\n  let {\n    quotient,\n    remainder\n  } = divmod(quantity, JSBI.BigInt(increment));\n  if (JSBI.equal(remainder, ZERO)) return quantity;\n  const sign = JSBI.lessThan(remainder, ZERO) ? -1 : 1;\n\n  switch (mode) {\n    case 'ceil':\n      if (sign > 0) quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      break;\n\n    case 'floor':\n      if (sign < 0) quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      break;\n\n    case 'trunc':\n      // no change needed, because divmod is a truncation\n      break;\n\n    case 'halfExpand':\n      // \"half up away from zero\"\n      if (JSBI.toNumber(abs(JSBI.multiply(remainder, JSBI.BigInt(2)))) >= increment) {\n        quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n      }\n\n      break;\n  }\n\n  return JSBI.multiply(quotient, JSBI.BigInt(increment));\n}\n\nfunction RoundInstant(epochNs, increment, unit, roundingMode) {\n  // Note: NonNegativeModulo, but with BigInt\n  let remainder = JSBI.remainder(epochNs, JSBI.BigInt(86400e9));\n  if (JSBI.lessThan(remainder, ZERO)) remainder = JSBI.add(remainder, JSBI.BigInt(86400e9));\n  const wholeDays = JSBI.subtract(epochNs, remainder);\n  const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n  return JSBI.add(wholeDays, roundedRemainder);\n}\n\nfunction RoundISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n  const {\n    deltaDays,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  } = RoundTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs);\n  const {\n    year,\n    month,\n    day\n  } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n  return {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond\n  };\n}\n\nfunction RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n  let quantity = ZERO;\n\n  switch (unit) {\n    case 'day':\n    case 'hour':\n      quantity = JSBI.BigInt(hour);\n    // fall through\n\n    case 'minute':\n      quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(minute));\n    // fall through\n\n    case 'second':\n      quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(second));\n    // fall through\n\n    case 'millisecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(millisecond));\n    // fall through\n\n    case 'microsecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(microsecond));\n    // fall through\n\n    case 'nanosecond':\n      quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(nanosecond));\n  }\n\n  const nsPerUnit = unit === 'day' ? dayLengthNs : nsPerTimeUnit[unit];\n  const rounded = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode);\n  const result = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(nsPerUnit)));\n\n  switch (unit) {\n    case 'day':\n      return {\n        deltaDays: result,\n        hour: 0,\n        minute: 0,\n        second: 0,\n        millisecond: 0,\n        microsecond: 0,\n        nanosecond: 0\n      };\n\n    case 'hour':\n      return BalanceTime(result, 0, 0, 0, 0, 0);\n\n    case 'minute':\n      return BalanceTime(hour, result, 0, 0, 0, 0);\n\n    case 'second':\n      return BalanceTime(hour, minute, result, 0, 0, 0);\n\n    case 'millisecond':\n      return BalanceTime(hour, minute, second, result, 0, 0);\n\n    case 'microsecond':\n      return BalanceTime(hour, minute, second, millisecond, result, 0);\n\n    case 'nanosecond':\n      return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n\n    default:\n      throw new Error(`Invalid unit ${unit}`);\n  }\n}\n\nfunction DaysUntil(earlier, later) {\n  return DifferenceISODate(GetSlot(earlier, ISO_YEAR), GetSlot(earlier, ISO_MONTH), GetSlot(earlier, ISO_DAY), GetSlot(later, ISO_YEAR), GetSlot(later, ISO_MONTH), GetSlot(later, ISO_DAY), 'day').days;\n}\n\nfunction MoveRelativeDate(calendar, relativeToParam, duration) {\n  const options = ObjectCreate$2(null);\n  const later = CalendarDateAdd(calendar, relativeToParam, duration, options);\n  const days = DaysUntil(relativeToParam, later);\n  return {\n    relativeTo: later,\n    days\n  };\n}\n\nfunction MoveRelativeZonedDateTime(relativeTo, years, months, weeks, days) {\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR);\n  const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  return CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n}\n\nfunction AdjustRoundedDurationDays(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeTo) {\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n  let hours = hoursParam;\n  let minutes = minutesParam;\n  let seconds = secondsParam;\n  let milliseconds = millisecondsParam;\n  let microseconds = microsecondsParam;\n  let nanoseconds = nanosecondsParam;\n\n  if (!IsTemporalZonedDateTime(relativeTo) || unit === 'year' || unit === 'month' || unit === 'week' || unit === 'day' || unit === 'nanosecond' && increment === 1) {\n    return {\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    };\n  } // There's one more round of rounding possible: if relativeTo is a\n  // ZonedDateTime, the time units could have rounded up into enough hours\n  // to exceed the day length. If this happens, grow the date part by a\n  // single day and re-run exact time rounding on the smaller remainder. DO\n  // NOT RECURSE, because once the extra hours are sucked up into the date\n  // duration, there's no way for another full day to come from the next\n  // round of rounding. And if it were possible (e.g. contrived calendar\n  // with 30-minute-long \"days\") then it'd risk an infinite loop.\n\n\n  let timeRemainderNs = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 0);\n  const direction = MathSign(JSBI.toNumber(timeRemainderNs));\n  const timeZone = GetSlot(relativeTo, TIME_ZONE);\n  const calendar = GetSlot(relativeTo, CALENDAR);\n  const dayStart = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const dayEnd = AddZonedDateTime(new TemporalInstant(dayStart), timeZone, calendar, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0);\n  const dayLengthNs = JSBI.subtract(dayEnd, dayStart);\n\n  if (JSBI.greaterThanOrEqual(JSBI.multiply(JSBI.subtract(timeRemainderNs, dayLengthNs), JSBI.BigInt(direction)), ZERO)) {\n    ({\n      years,\n      months,\n      weeks,\n      days\n    } = AddDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0, relativeTo));\n    timeRemainderNs = RoundInstant(JSBI.subtract(timeRemainderNs, dayLengthNs), increment, unit, roundingMode);\n    ({\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(0, 0, 0, 0, 0, 0, JSBI.toNumber(timeRemainderNs), 'hour'));\n  }\n\n  return {\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  };\n}\n\nfunction RoundDuration(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeToParam = undefined) {\n  let years = yearsParam;\n  let months = monthsParam;\n  let weeks = weeksParam;\n  let days = daysParam;\n  let hours = hoursParam;\n  let minutes = minutesParam;\n  let seconds = secondsParam;\n  let milliseconds = millisecondsParam;\n  let microseconds = microsecondsParam;\n  let nanoseconds = JSBI.BigInt(nanosecondsParam);\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  let calendar, zdtRelative; // A cast is used below because relativeTo will be either PlainDate or\n  // undefined for the rest of this long method (after any ZDT=>PlainDate\n  // conversion below), and TS isn't smart enough to know that the type has\n  // changed. See https://github.com/microsoft/TypeScript/issues/27706.\n\n  let relativeTo = relativeToParam;\n\n  if (relativeTo) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n      zdtRelative = relativeTo;\n      relativeTo = ToTemporalDate(relativeTo);\n    } else if (!IsTemporalDate(relativeTo)) {\n      throw new TypeError('starting point must be PlainDate or ZonedDateTime');\n    }\n\n    calendar = GetSlot(relativeTo, CALENDAR);\n  } // First convert time units up to days, if rounding to days or higher units.\n  // If rounding relative to a ZonedDateTime, then some days may not be 24h.\n  // TS doesn't know that `dayLengthNs` is only used if the unit is day or\n  // larger. We'll cast away `undefined` when it's used lower down below.\n\n\n  let dayLengthNs;\n\n  if (unit === 'year' || unit === 'month' || unit === 'week' || unit === 'day') {\n    nanoseconds = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanosecondsParam, 0);\n    let intermediate;\n\n    if (zdtRelative) {\n      intermediate = MoveRelativeZonedDateTime(zdtRelative, years, months, weeks, days);\n    }\n\n    let deltaDays;\n    let dayLength;\n    ({\n      days: deltaDays,\n      nanoseconds,\n      dayLengthNs: dayLength\n    } = NanosecondsToDays(nanoseconds, intermediate));\n    dayLengthNs = JSBI.BigInt(dayLength);\n    days += deltaDays;\n    hours = minutes = seconds = milliseconds = microseconds = 0;\n  }\n\n  let total;\n\n  switch (unit) {\n    case 'year':\n      {\n        if (!calendar) throw new RangeError('A starting point is required for years rounding'); // convert months and weeks to days by calculating difference(\n        // relativeTo + years, relativeTo + { years, months, weeks })\n\n        const yearsDuration = new TemporalDuration(years);\n        const dateAdd = calendar.dateAdd;\n        const firstAddOptions = ObjectCreate$2(null);\n        const yearsLater = CalendarDateAdd(calendar, relativeTo, yearsDuration, firstAddOptions, dateAdd);\n        const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n        const secondAddOptions = ObjectCreate$2(null);\n        const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n        const monthsWeeksInDays = DaysUntil(yearsLater, yearsMonthsWeeksLater);\n        relativeTo = yearsLater;\n        days += monthsWeeksInDays;\n        const thirdAddOptions = ObjectCreate$2(null);\n        const daysLater = CalendarDateAdd(calendar, relativeTo, {\n          days\n        }, thirdAddOptions, dateAdd);\n        const untilOptions = ObjectCreate$2(null);\n        untilOptions.largestUnit = 'year';\n        const yearsPassed = CalendarDateUntil(calendar, relativeTo, daysLater, untilOptions).years;\n        years += yearsPassed;\n        const oldRelativeTo = relativeTo;\n        const fourthAddOptions = ObjectCreate$2(null);\n        relativeTo = CalendarDateAdd(calendar, relativeTo, {\n          years: yearsPassed\n        }, fourthAddOptions, dateAdd);\n        const daysPassed = DaysUntil(oldRelativeTo, relativeTo);\n        days -= daysPassed;\n        const oneYear = new TemporalDuration(days < 0 ? -1 : 1);\n        let {\n          days: oneYearDays\n        } = MoveRelativeDate(calendar, relativeTo, oneYear); // Note that `nanoseconds` below (here and in similar code for months,\n        // weeks, and days further below) isn't actually nanoseconds for the\n        // full date range.  Instead, it's a BigInt representation of total\n        // days multiplied by the number of nanoseconds in the last day of\n        // the duration. This lets us do days-or-larger rounding using BigInt\n        // math which reduces precision loss.\n\n        oneYearDays = MathAbs(oneYearDays); // dayLengthNs is never undefined if unit is `day` or larger.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const divisor = JSBI.multiply(JSBI.BigInt(oneYearDays), dayLengthNs);\n        nanoseconds = JSBI.add( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(years)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n        const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n        total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n        years = JSBI.toNumber(JSBI.divide(rounded, divisor));\n        nanoseconds = ZERO;\n        months = weeks = days = 0;\n        break;\n      }\n\n    case 'month':\n      {\n        if (!calendar) throw new RangeError('A starting point is required for months rounding'); // convert weeks to days by calculating difference(relativeTo +\n        //   { years, months }, relativeTo + { years, months, weeks })\n\n        const yearsMonths = new TemporalDuration(years, months);\n        const dateAdd = calendar.dateAdd;\n        const firstAddOptions = ObjectCreate$2(null);\n        const yearsMonthsLater = CalendarDateAdd(calendar, relativeTo, yearsMonths, firstAddOptions, dateAdd);\n        const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n        const secondAddOptions = ObjectCreate$2(null);\n        const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n        const weeksInDays = DaysUntil(yearsMonthsLater, yearsMonthsWeeksLater);\n        relativeTo = yearsMonthsLater;\n        days += weeksInDays; // Months may be different lengths of days depending on the calendar,\n        // convert days to months in a loop as described above under 'years'.\n\n        const sign = MathSign(days);\n        const oneMonth = new TemporalDuration(0, days < 0 ? -1 : 1);\n        let oneMonthDays;\n        ({\n          relativeTo,\n          days: oneMonthDays\n        } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n\n        while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n          months += sign;\n          days -= oneMonthDays;\n          ({\n            relativeTo,\n            days: oneMonthDays\n          } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n        }\n\n        oneMonthDays = MathAbs(oneMonthDays); // dayLengthNs is never undefined if unit is `day` or larger.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const divisor = JSBI.multiply(JSBI.BigInt(oneMonthDays), dayLengthNs);\n        nanoseconds = JSBI.add( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(months)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n        const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n        total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n        months = JSBI.toNumber(JSBI.divide(rounded, divisor));\n        nanoseconds = ZERO;\n        weeks = days = 0;\n        break;\n      }\n\n    case 'week':\n      {\n        if (!calendar) throw new RangeError('A starting point is required for weeks rounding'); // Weeks may be different lengths of days depending on the calendar,\n        // convert days to weeks in a loop as described above under 'years'.\n\n        const sign = MathSign(days);\n        const oneWeek = new TemporalDuration(0, 0, days < 0 ? -1 : 1);\n        let oneWeekDays;\n        ({\n          relativeTo,\n          days: oneWeekDays\n        } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n\n        while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n          weeks += sign;\n          days -= oneWeekDays;\n          ({\n            relativeTo,\n            days: oneWeekDays\n          } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n        }\n\n        oneWeekDays = MathAbs(oneWeekDays); // dayLengthNs is never undefined if unit is `day` or larger.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const divisor = JSBI.multiply(JSBI.BigInt(oneWeekDays), dayLengthNs);\n        nanoseconds = JSBI.add( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(weeks)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n        const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n        total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n        weeks = JSBI.toNumber(JSBI.divide(rounded, divisor));\n        nanoseconds = ZERO;\n        days = 0;\n        break;\n      }\n\n    case 'day':\n      {\n        // dayLengthNs is never undefined if unit is `day` or larger.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const divisor = dayLengthNs;\n        nanoseconds = JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(days)), nanoseconds);\n        const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n        total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n        days = JSBI.toNumber(JSBI.divide(rounded, divisor));\n        nanoseconds = ZERO;\n        break;\n      }\n\n    case 'hour':\n      {\n        const divisor = 3600e9;\n        let allNanoseconds = JSBI.multiply(JSBI.BigInt(hours), JSBI.BigInt(3600e9));\n        allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9)));\n        allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n        allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n        allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n        allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n        total = JSBI.toNumber(allNanoseconds) / divisor;\n        const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n        hours = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n        nanoseconds = ZERO;\n        minutes = seconds = milliseconds = microseconds = 0;\n        break;\n      }\n\n    case 'minute':\n      {\n        const divisor = 60e9;\n        let allNanoseconds = JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9));\n        allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n        allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n        allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n        allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n        total = JSBI.toNumber(allNanoseconds) / divisor;\n        const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n        minutes = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n        nanoseconds = ZERO;\n        seconds = milliseconds = microseconds = 0;\n        break;\n      }\n\n    case 'second':\n      {\n        const divisor = 1e9;\n        let allNanoseconds = JSBI.multiply(JSBI.BigInt(seconds), BILLION);\n        allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n        allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n        allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n        total = JSBI.toNumber(allNanoseconds) / divisor;\n        const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n        seconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n        nanoseconds = ZERO;\n        milliseconds = microseconds = 0;\n        break;\n      }\n\n    case 'millisecond':\n      {\n        const divisor = 1e6;\n        let allNanoseconds = JSBI.multiply(JSBI.BigInt(milliseconds), MILLION);\n        allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n        allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n        total = JSBI.toNumber(allNanoseconds) / divisor;\n        const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n        milliseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n        nanoseconds = ZERO;\n        microseconds = 0;\n        break;\n      }\n\n    case 'microsecond':\n      {\n        const divisor = 1e3;\n        let allNanoseconds = JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND);\n        allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n        total = JSBI.toNumber(allNanoseconds) / divisor;\n        const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n        microseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n        nanoseconds = ZERO;\n        break;\n      }\n\n    case 'nanosecond':\n      {\n        total = JSBI.toNumber(nanoseconds);\n        nanoseconds = RoundNumberToIncrement(nanoseconds, increment, roundingMode);\n        break;\n      }\n  }\n\n  return {\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds: JSBI.toNumber(nanoseconds),\n    total\n  };\n}\n\nfunction CompareISODate(y1, m1, d1, y2, m2, d2) {\n  for (const [x, y] of [[y1, y2], [m1, m2], [d1, d2]]) {\n    if (x !== y) return ComparisonResult(x - y);\n  }\n\n  return 0;\n}\n\nfunction NonNegativeModulo(x, y) {\n  let result = x % y;\n  if (ObjectIs(result, -0)) return 0;\n  if (result < 0) result += y;\n  return result;\n}\n\nfunction ToBigIntExternal(arg) {\n  const jsbiBI = ToBigInt(arg);\n  if (typeof globalThis.BigInt !== 'undefined') return globalThis.BigInt(jsbiBI.toString(10));\n  return jsbiBI;\n}\n\nfunction ToBigInt(arg) {\n  if (arg instanceof JSBI) {\n    return arg;\n  }\n\n  let prim = arg;\n\n  if (typeof arg === 'object') {\n    const toPrimFn = arg[Symbol.toPrimitive];\n\n    if (toPrimFn && typeof toPrimFn === 'function') {\n      prim = ReflectApply$1(toPrimFn, arg, ['number']);\n    }\n  }\n\n  switch (typeof prim) {\n    case 'undefined':\n    case 'object':\n    case 'number':\n    case 'symbol':\n    default:\n      throw new TypeError(`cannot convert ${typeof arg} to bigint`);\n\n    case 'string':\n      if (!prim.match(/^\\s*(?:[+-]?\\d+\\s*)?$/)) {\n        throw new SyntaxError('invalid BigInt syntax');\n      }\n\n    // eslint: no-fallthrough: false\n\n    case 'bigint':\n      try {\n        return JSBI.BigInt(prim.toString());\n      } catch (e) {\n        if (e instanceof Error && e.message.startsWith('Invalid integer')) throw new SyntaxError(e.message);\n        throw e;\n      }\n\n    case 'boolean':\n      if (prim) {\n        return ONE;\n      } else {\n        return ZERO;\n      }\n\n  }\n} // Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\n\n\nconst SystemUTCEpochNanoSeconds = (() => {\n  let ns = JSBI.BigInt(Date.now() % 1e6);\n  return () => {\n    const ms = JSBI.BigInt(Date.now());\n    const result = JSBI.add(JSBI.multiply(ms, MILLION), ns);\n    ns = JSBI.divide(ms, MILLION);\n    if (JSBI.greaterThan(result, NS_MAX)) return NS_MAX;\n    if (JSBI.lessThan(result, NS_MIN)) return NS_MIN;\n    return result;\n  };\n})();\n\nfunction SystemTimeZone() {\n  const fmt = new IntlDateTimeFormat$1('en-us');\n  const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n  return new TemporalTimeZone(ParseTemporalTimeZone(fmt.resolvedOptions().timeZone));\n}\n\nfunction ComparisonResult(value) {\n  return value < 0 ? -1 : value > 0 ? 1 : value;\n}\n\nfunction GetOptionsObject(options) {\n  if (options === undefined) return ObjectCreate$2(null);\n  if (IsObject(options) && options !== null) return options;\n  throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\n\nfunction CreateOnePropObject(propName, propValue) {\n  const o = ObjectCreate$2(null);\n  o[propName] = propValue;\n  return o;\n}\n\nfunction GetOption(options, property, allowedValues, fallback) {\n  let value = options[property];\n\n  if (value !== undefined) {\n    value = ToString(value);\n\n    if (!allowedValues.includes(value)) {\n      throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n    }\n\n    return value;\n  }\n\n  return fallback;\n}\n\nfunction GetNumberOption(options, property, minimum, maximum, fallback) {\n  let valueRaw = options[property];\n  if (valueRaw === undefined) return fallback;\n  const value = ToNumber(valueRaw);\n\n  if (NumberIsNaN(value) || value < minimum || value > maximum) {\n    throw new RangeError(`${property} must be between ${minimum} and ${maximum}, not ${value}`);\n  }\n\n  return MathFloor(value);\n}\n\nconst OFFSET = new RegExp(`^${offset.source}$`);\n\nfunction bisect(getState, leftParam, rightParam, lstateParam = getState(leftParam), rstateParam = getState(rightParam)) {\n  // This doesn't make much sense - why do these get converted unnecessarily?\n  let left = JSBI.BigInt(leftParam);\n  let right = JSBI.BigInt(rightParam);\n  let lstate = lstateParam;\n  let rstate = rstateParam;\n\n  while (JSBI.greaterThan(JSBI.subtract(right, left), ONE)) {\n    const middle = JSBI.divide(JSBI.add(left, right), JSBI.BigInt(2));\n    const mstate = getState(middle);\n\n    if (mstate === lstate) {\n      left = middle;\n      lstate = mstate;\n    } else if (mstate === rstate) {\n      right = middle;\n      rstate = mstate;\n    } else {\n      throw new Error(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n    }\n  }\n\n  return right;\n}\n\nconst nsPerTimeUnit = {\n  hour: 3600e9,\n  minute: 60e9,\n  second: 1e9,\n  millisecond: 1e6,\n  microsecond: 1e3,\n  nanosecond: 1\n};\nconst DATE = Symbol('date');\nconst YM = Symbol('ym');\nconst MD = Symbol('md');\nconst TIME = Symbol('time');\nconst DATETIME = Symbol('datetime');\nconst ZONED = Symbol('zoneddatetime');\nconst INST = Symbol('instant');\nconst ORIGINAL = Symbol('original');\nconst TZ_RESOLVED = Symbol('timezone');\nconst TZ_GIVEN = Symbol('timezone-id-given');\nconst CAL_ID = Symbol('calendar-id');\nconst LOCALE = Symbol('locale');\nconst OPTIONS = Symbol('options');\n\nconst descriptor = value => {\n  return {\n    value,\n    enumerable: true,\n    writable: false,\n    configurable: true\n  };\n};\n\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ObjectAssign$1 = Object.assign;\nconst ObjectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst ReflectApply = Reflect.apply; // Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\n\nfunction getPropLazy(obj, prop) {\n  let val = obj[prop];\n\n  if (typeof val === 'function') {\n    // If we get here, `val` is an \"amender function\". It will take the user's\n    // options and transform them into suitable options to be passed into the\n    // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n    // will vary depending on the Temporal type, so that's why we store separate\n    // formatters in separate props on the polyfill's DateTimeFormat instances.\n    // The efficiency happens because we don't create an (expensive) formatter\n    // until the user calls toLocaleString for that Temporal type.\n    val = new IntlDateTimeFormat(obj[LOCALE], val(obj[OPTIONS])); // TODO: can this be typed more cleanly?\n\n    obj[prop] = val;\n  }\n\n  return val;\n} // Similarly, lazy-init TimeZone instances.\n\n\nfunction getResolvedTimeZoneLazy(obj) {\n  let val = obj[TZ_RESOLVED];\n\n  if (typeof val === 'string') {\n    val = ToTemporalTimeZone(val);\n    obj[TZ_RESOLVED] = val;\n  }\n\n  return val;\n}\n\nfunction DateTimeFormatImpl(locale = undefined, optionsParam = {}) {\n  if (!(this instanceof DateTimeFormatImpl)) {\n    return new DateTimeFormatImpl(locale, optionsParam);\n  }\n\n  const hasOptions = typeof optionsParam !== 'undefined';\n  const options = hasOptions ? ObjectAssign$1({}, optionsParam) : {}; // TODO: remove type assertion after Temporal types land in TS lib types\n\n  const original = new IntlDateTimeFormat(locale, options);\n  const ro = original.resolvedOptions(); // DateTimeFormat instances are very expensive to create. Therefore, they will\n  // be lazily created only when needed, using the locale and options provided.\n  // But it's possible for callers to mutate those inputs before lazy creation\n  // happens. For this reason, we clone the inputs instead of caching the\n  // original objects. To avoid the complexity of deep cloning any inputs that\n  // are themselves objects (e.g. the locales array, or options property values\n  // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n  // coercion and cloning for us. Unfortunately, we can't just use the resolved\n  // options as-is because our options-amending logic adds additional fields if\n  // the user doesn't supply any unit fields like year, month, day, hour, etc.\n  // Therefore, we limit the properties in the clone to properties that were\n  // present in the original input.\n\n  if (hasOptions) {\n    const clonedResolved = ObjectAssign$1({}, ro);\n\n    for (const prop in clonedResolved) {\n      if (!ReflectApply(ObjectHasOwnProperty, options, [prop])) {\n        delete clonedResolved[prop];\n      }\n    }\n\n    this[OPTIONS] = clonedResolved;\n  } else {\n    this[OPTIONS] = options;\n  }\n\n  this[TZ_GIVEN] = options.timeZone ? options.timeZone : null;\n  this[LOCALE] = ro.locale;\n  this[ORIGINAL] = original;\n  this[TZ_RESOLVED] = ro.timeZone;\n  this[CAL_ID] = ro.calendar;\n  this[DATE] = dateAmend;\n  this[YM] = yearMonthAmend;\n  this[MD] = monthDayAmend;\n  this[TIME] = timeAmend;\n  this[DATETIME] = datetimeAmend;\n  this[ZONED] = zonedDateTimeAmend;\n  this[INST] = instantAmend;\n  return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\n\nObject.defineProperty(DateTimeFormatImpl, 'name', {\n  writable: true,\n  value: 'DateTimeFormat'\n});\n\nDateTimeFormatImpl.supportedLocalesOf = function (locales, options) {\n  return IntlDateTimeFormat.supportedLocalesOf(locales, options);\n};\n\nconst properties = {\n  resolvedOptions: descriptor(resolvedOptions),\n  format: descriptor(format),\n  formatRange: descriptor(formatRange)\n};\n\nif ('formatToParts' in IntlDateTimeFormat.prototype) {\n  properties.formatToParts = descriptor(formatToParts);\n}\n\nif ('formatRangeToParts' in IntlDateTimeFormat.prototype) {\n  properties.formatRangeToParts = descriptor(formatRangeToParts);\n}\n\nDateTimeFormatImpl.prototype = Object.create(IntlDateTimeFormat.prototype, properties); // Ensure that the prototype isn't writeable.\n\nObject.defineProperty(DateTimeFormatImpl, 'prototype', {\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\nconst DateTimeFormat = DateTimeFormatImpl;\n\nfunction resolvedOptions() {\n  return this[ORIGINAL].resolvedOptions();\n}\n\nfunction adjustFormatterTimeZone(formatter, timeZone) {\n  if (!timeZone) return formatter;\n  const options = formatter.resolvedOptions();\n  if (options.timeZone === timeZone) return formatter; // Existing Intl isn't typed to accept Temporal-specific options and the lib\n  // types for resolved options are less restrictive than the types for options.\n  // For example, `weekday` is\n  // `'long' | 'short' | 'narrow'` in options but `string` in resolved options.\n  // TODO: investigate why, and file an issue against TS if it's a bug.\n\n  if (options['dateStyle'] || options['timeStyle']) {\n    // Unfortunately, Safari's resolvedOptions include parameters that will\n    // cause errors at runtime if passed along with\n    // dateStyle or timeStyle options as per\n    // https://tc39.es/proposal-intl-datetime-style/#table-datetimeformat-components.\n    // This has been fixed in newer versions of Safari:\n    // https://bugs.webkit.org/show_bug.cgi?id=231041\n    delete options['weekday'];\n    delete options['era'];\n    delete options['year'];\n    delete options['month'];\n    delete options['day'];\n    delete options['hour'];\n    delete options['minute'];\n    delete options['second'];\n    delete options['timeZoneName'];\n    delete options['hourCycle'];\n    delete options['hour12'];\n    delete options['dayPeriod'];\n  }\n\n  return new IntlDateTimeFormat(options.locale, { ...options,\n    timeZone\n  });\n} // TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\n\n\nfunction format(datetime, ...rest) {\n  let {\n    instant,\n    formatter,\n    timeZone\n  } = extractOverrides(datetime, this);\n\n  if (instant && formatter) {\n    formatter = adjustFormatterTimeZone(formatter, timeZone);\n    return formatter.format(instant.epochMilliseconds);\n  }\n\n  return this[ORIGINAL].format(datetime, ...rest);\n}\n\nfunction formatToParts(datetime, ...rest) {\n  let {\n    instant,\n    formatter,\n    timeZone\n  } = extractOverrides(datetime, this);\n\n  if (instant && formatter) {\n    formatter = adjustFormatterTimeZone(formatter, timeZone);\n    return formatter.formatToParts(instant.epochMilliseconds);\n  }\n\n  return this[ORIGINAL].formatToParts(datetime, ...rest);\n}\n\nfunction formatRange(a, b) {\n  if (isTemporalObject(a) || isTemporalObject(b)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n    }\n\n    const {\n      instant: aa,\n      formatter: aformatter,\n      timeZone: atz\n    } = extractOverrides(a, this);\n    const {\n      instant: bb,\n      formatter: bformatter,\n      timeZone: btz\n    } = extractOverrides(b, this);\n\n    if (atz && btz && atz !== btz) {\n      throw new RangeError('cannot format range between different time zones');\n    }\n\n    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n      const formatter = adjustFormatterTimeZone(aformatter, atz); // TODO: Remove type assertion after this method lands in TS lib types\n\n      return formatter.formatRange(aa.epochMilliseconds, bb.epochMilliseconds);\n    }\n  } // TODO: Remove type assertion after this method lands in TS lib types\n\n\n  return this[ORIGINAL].formatRange(a, b);\n}\n\nfunction formatRangeToParts(a, b) {\n  if (isTemporalObject(a) || isTemporalObject(b)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n    }\n\n    const {\n      instant: aa,\n      formatter: aformatter,\n      timeZone: atz\n    } = extractOverrides(a, this);\n    const {\n      instant: bb,\n      formatter: bformatter,\n      timeZone: btz\n    } = extractOverrides(b, this);\n\n    if (atz && btz && atz !== btz) {\n      throw new RangeError('cannot format range between different time zones');\n    }\n\n    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n      const formatter = adjustFormatterTimeZone(aformatter, atz); // TODO: Remove type assertion after this method lands in TS lib types\n\n      return formatter.formatRangeToParts(aa.epochMilliseconds, bb.epochMilliseconds);\n    }\n  } // TODO: Remove type assertion after this method lands in TS lib types\n\n\n  return this[ORIGINAL].formatRangeToParts(a, b);\n}\n\nfunction amend(optionsParam = {}, amended = {}) {\n  const options = ObjectAssign$1({}, optionsParam);\n\n  for (const opt of ['year', 'month', 'day', 'hour', 'minute', 'second', 'weekday', 'dayPeriod', 'timeZoneName', 'dateStyle', 'timeStyle']) {\n    options[opt] = opt in amended ? amended[opt] : options[opt];\n    if (options[opt] === false || options[opt] === undefined) delete options[opt];\n  }\n\n  return options;\n}\n\nfunction timeAmend(optionsParam) {\n  let options = amend(optionsParam, {\n    year: false,\n    month: false,\n    day: false,\n    weekday: false,\n    timeZoneName: false,\n    dateStyle: false\n  });\n\n  if (!hasTimeOptions(options)) {\n    options = ObjectAssign$1({}, options, {\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n\n  return options;\n}\n\nfunction yearMonthAmend(optionsParam) {\n  let options = amend(optionsParam, {\n    day: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    dateStyle: false,\n    timeStyle: false\n  });\n\n  if (!('year' in options || 'month' in options)) {\n    options = ObjectAssign$1(options, {\n      year: 'numeric',\n      month: 'numeric'\n    });\n  }\n\n  return options;\n}\n\nfunction monthDayAmend(optionsParam) {\n  let options = amend(optionsParam, {\n    year: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    dateStyle: false,\n    timeStyle: false\n  });\n\n  if (!('month' in options || 'day' in options)) {\n    options = ObjectAssign$1({}, options, {\n      month: 'numeric',\n      day: 'numeric'\n    });\n  }\n\n  return options;\n}\n\nfunction dateAmend(optionsParam) {\n  let options = amend(optionsParam, {\n    hour: false,\n    minute: false,\n    second: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    timeStyle: false\n  });\n\n  if (!hasDateOptions(options)) {\n    options = ObjectAssign$1({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric'\n    });\n  }\n\n  return options;\n}\n\nfunction datetimeAmend(optionsParam) {\n  let options = amend(optionsParam, {\n    timeZoneName: false\n  });\n\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    options = ObjectAssign$1({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n\n  return options;\n}\n\nfunction zonedDateTimeAmend(optionsParam) {\n  let options = optionsParam;\n\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    options = ObjectAssign$1({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n    if (options.timeZoneName === undefined) options.timeZoneName = 'short';\n  }\n\n  return options;\n}\n\nfunction instantAmend(optionsParam) {\n  let options = optionsParam;\n\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    options = ObjectAssign$1({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n\n  return options;\n}\n\nfunction hasDateOptions(options) {\n  return 'year' in options || 'month' in options || 'day' in options || 'weekday' in options || 'dateStyle' in options;\n}\n\nfunction hasTimeOptions(options) {\n  return 'hour' in options || 'minute' in options || 'second' in options || 'timeStyle' in options || 'dayPeriod' in options;\n}\n\nfunction isTemporalObject(obj) {\n  return IsTemporalDate(obj) || IsTemporalTime(obj) || IsTemporalDateTime(obj) || IsTemporalZonedDateTime(obj) || IsTemporalYearMonth(obj) || IsTemporalMonthDay(obj) || IsTemporalInstant(obj);\n}\n\nfunction sameTemporalType(x, y) {\n  if (!isTemporalObject(x) || !isTemporalObject(y)) return false;\n  if (IsTemporalTime(x) && !IsTemporalTime(y)) return false;\n  if (IsTemporalDate(x) && !IsTemporalDate(y)) return false;\n  if (IsTemporalDateTime(x) && !IsTemporalDateTime(y)) return false;\n  if (IsTemporalZonedDateTime(x) && !IsTemporalZonedDateTime(y)) return false;\n  if (IsTemporalYearMonth(x) && !IsTemporalYearMonth(y)) return false;\n  if (IsTemporalMonthDay(x) && !IsTemporalMonthDay(y)) return false;\n  if (IsTemporalInstant(x) && !IsTemporalInstant(y)) return false;\n  return true;\n}\n\nfunction extractOverrides(temporalObj, main) {\n  const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n\n  if (IsTemporalTime(temporalObj)) {\n    const hour = GetSlot(temporalObj, ISO_HOUR);\n    const minute = GetSlot(temporalObj, ISO_MINUTE);\n    const second = GetSlot(temporalObj, ISO_SECOND);\n    const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n    const datetime = new DateTime(1970, 1, 1, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n    return {\n      instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n      formatter: getPropLazy(main, TIME)\n    };\n  }\n\n  if (IsTemporalYearMonth(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const referenceISODay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n\n    if (calendar !== main[CAL_ID]) {\n      throw new RangeError(`cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n    }\n\n    const datetime = new DateTime(isoYear, isoMonth, referenceISODay, 12, 0, 0, 0, 0, 0, calendar);\n    return {\n      instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n      formatter: getPropLazy(main, YM)\n    };\n  }\n\n  if (IsTemporalMonthDay(temporalObj)) {\n    const referenceISOYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n\n    if (calendar !== main[CAL_ID]) {\n      throw new RangeError(`cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n    }\n\n    const datetime = new DateTime(referenceISOYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, calendar);\n    return {\n      instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n      formatter: getPropLazy(main, MD)\n    };\n  }\n\n  if (IsTemporalDate(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n\n    if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n      throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n    }\n\n    const datetime = new DateTime(isoYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, main[CAL_ID]);\n    return {\n      instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n      formatter: getPropLazy(main, DATE)\n    };\n  }\n\n  if (IsTemporalDateTime(temporalObj)) {\n    const isoYear = GetSlot(temporalObj, ISO_YEAR);\n    const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n    const isoDay = GetSlot(temporalObj, ISO_DAY);\n    const hour = GetSlot(temporalObj, ISO_HOUR);\n    const minute = GetSlot(temporalObj, ISO_MINUTE);\n    const second = GetSlot(temporalObj, ISO_SECOND);\n    const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n    const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n\n    if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n      throw new RangeError(`cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n    }\n\n    let datetime = temporalObj;\n\n    if (calendar === 'iso8601') {\n      datetime = new DateTime(isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n    }\n\n    return {\n      instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n      formatter: getPropLazy(main, DATETIME)\n    };\n  }\n\n  if (IsTemporalZonedDateTime(temporalObj)) {\n    const calendar = ToString(GetSlot(temporalObj, CALENDAR));\n\n    if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n      throw new RangeError(`cannot format ZonedDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n    }\n\n    const timeZone = GetSlot(temporalObj, TIME_ZONE);\n    const objTimeZone = ToString(timeZone);\n\n    if (main[TZ_GIVEN] && main[TZ_GIVEN] !== objTimeZone) {\n      throw new RangeError(`timeZone option ${main[TZ_GIVEN]} doesn't match actual time zone ${objTimeZone}`);\n    }\n\n    return {\n      instant: GetSlot(temporalObj, INSTANT),\n      formatter: getPropLazy(main, ZONED),\n      timeZone: objTimeZone\n    };\n  }\n\n  if (IsTemporalInstant(temporalObj)) {\n    return {\n      instant: temporalObj,\n      formatter: getPropLazy(main, INST)\n    };\n  }\n\n  return {};\n}\n\nvar intl = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  DateTimeFormat: DateTimeFormat\n});\nconst DISALLOWED_UNITS$3 = ['year', 'month', 'week', 'day'];\nconst MAX_DIFFERENCE_INCREMENTS = {\n  hour: 24,\n  minute: 60,\n  second: 60,\n  millisecond: 1000,\n  microsecond: 1000,\n  nanosecond: 1000\n};\n\nclass Instant {\n  constructor(epochNanoseconds) {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n\n    const ns = ToBigInt(epochNanoseconds);\n    ValidateEpochNanoseconds(ns);\n    CreateSlots(this);\n    SetSlot(this, EPOCHNANOSECONDS, ns);\n    {\n      const repr = TemporalInstantToString(this, undefined, 'auto');\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${repr}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  get epochSeconds() {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(JSBI.divide(value, BILLION));\n  }\n\n  get epochMilliseconds() {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n    return JSBI.toNumber(JSBI.divide(value, MILLION));\n  }\n\n  get epochMicroseconds() {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n    return ToBigIntExternal(JSBI.divide(value, THOUSAND));\n  }\n\n  get epochNanoseconds() {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return ToBigIntExternal(JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n  }\n\n  add(temporalDurationLike) {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const {\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n    const ns = AddInstant(GetSlot(this, EPOCHNANOSECONDS), hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    return new Instant(ns);\n  }\n\n  subtract(temporalDurationLike) {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const {\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n    const ns = AddInstant(GetSlot(this, EPOCHNANOSECONDS), -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n    return new Instant(ns);\n  }\n\n  until(otherParam, optionsParam = undefined) {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalInstant(otherParam);\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$3);\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('second', smallestUnit);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$3, defaultLargestUnit);\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n    const onens = GetSlot(this, EPOCHNANOSECONDS);\n    const twons = GetSlot(other, EPOCHNANOSECONDS);\n    let {\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n    let hours, minutes;\n    ({\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n\n  since(otherParam, optionsParam = undefined) {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalInstant(otherParam);\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$3);\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('second', smallestUnit);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$3, defaultLargestUnit);\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n    const onens = GetSlot(other, EPOCHNANOSECONDS);\n    const twons = GetSlot(this, EPOCHNANOSECONDS);\n    let {\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n    let hours, minutes;\n    ({\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n\n  round(optionsParam) {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    if (optionsParam === undefined) throw new TypeError('options parameter is required');\n    const options = typeof optionsParam === 'string' ? CreateOnePropObject('smallestUnit', optionsParam) : GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS$3);\n    if (smallestUnit === undefined) throw new RangeError('smallestUnit is required');\n    const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n    const maximumIncrements = {\n      hour: 24,\n      minute: 1440,\n      second: 86400,\n      millisecond: 86400e3,\n      microsecond: 86400e6,\n      nanosecond: 86400e9\n    };\n    const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], true);\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = RoundInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n    return new Instant(roundedNs);\n  }\n\n  equals(otherParam) {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalInstant(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    return JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two));\n  }\n\n  toString(optionsParam = undefined) {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    const options = GetOptionsObject(optionsParam);\n    let timeZone = options.timeZone;\n    if (timeZone !== undefined) timeZone = ToTemporalTimeZone(timeZone); // Although TS doesn't acknowledge it, below here `timeZone` is a Temporal.TimeZoneProtocol\n\n    const {\n      precision,\n      unit,\n      increment\n    } = ToSecondsStringPrecision(options);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = RoundInstant(ns, increment, unit, roundingMode);\n    const roundedInstant = new Instant(roundedNs);\n    return TemporalInstantToString(roundedInstant, timeZone, precision);\n  }\n\n  toJSON() {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return TemporalInstantToString(this, undefined, 'auto');\n  }\n\n  toLocaleString(locales = undefined, options = undefined) {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n\n  valueOf() {\n    throw new TypeError('use compare() or equals() to compare Temporal.Instant');\n  }\n\n  toZonedDateTime(item) {\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n\n    if (!IsObject(item)) {\n      throw new TypeError('invalid argument in toZonedDateTime');\n    }\n\n    const calendarLike = item.calendar;\n\n    if (calendarLike === undefined) {\n      throw new TypeError('missing calendar property in toZonedDateTime');\n    }\n\n    const calendar = ToTemporalCalendar(calendarLike);\n    const temporalTimeZoneLike = item.timeZone;\n\n    if (temporalTimeZoneLike === undefined) {\n      throw new TypeError('missing timeZone property in toZonedDateTime');\n    }\n\n    const timeZone = ToTemporalTimeZone(temporalTimeZoneLike);\n    return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n\n  toZonedDateTimeISO(itemParam) {\n    let item = itemParam;\n    if (!IsTemporalInstant(this)) throw new TypeError('invalid receiver');\n\n    if (IsObject(item)) {\n      const timeZoneProperty = item.timeZone;\n\n      if (timeZoneProperty !== undefined) {\n        item = timeZoneProperty;\n      }\n    }\n\n    const timeZone = ToTemporalTimeZone(item);\n    const calendar = GetISO8601Calendar();\n    return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n\n  static fromEpochSeconds(epochSecondsParam) {\n    const epochSeconds = ToNumber(epochSecondsParam);\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochSeconds), BILLION);\n    ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n\n  static fromEpochMilliseconds(epochMillisecondsParam) {\n    const epochMilliseconds = ToNumber(epochMillisecondsParam);\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochMilliseconds), MILLION);\n    ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n\n  static fromEpochMicroseconds(epochMicrosecondsParam) {\n    const epochMicroseconds = ToBigInt(epochMicrosecondsParam);\n    const epochNanoseconds = JSBI.multiply(epochMicroseconds, THOUSAND);\n    ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n\n  static fromEpochNanoseconds(epochNanosecondsParam) {\n    const epochNanoseconds = ToBigInt(epochNanosecondsParam);\n    ValidateEpochNanoseconds(epochNanoseconds);\n    return new Instant(epochNanoseconds);\n  }\n\n  static from(item) {\n    if (IsTemporalInstant(item)) {\n      return new Instant(GetSlot(item, EPOCHNANOSECONDS));\n    }\n\n    return ToTemporalInstant(item);\n  }\n\n  static compare(oneParam, twoParam) {\n    const one = ToTemporalInstant(oneParam);\n    const two = ToTemporalInstant(twoParam);\n    const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n    const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(oneNs, twoNs)) return -1;\n    if (JSBI.greaterThan(oneNs, twoNs)) return 1;\n    return 0;\n  }\n\n}\n\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\nconst DISALLOWED_UNITS$2 = ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'];\n\nclass PlainDate {\n  constructor(isoYearParam, isoMonthParam, isoDayParam, calendarParam = GetISO8601Calendar()) {\n    const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n    const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n    const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n    const calendar = ToTemporalCalendar(calendarParam); // Note: if the arguments are not passed,\n    //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n    //       be rejected by RejectISODate in CreateTemporalDateSlots. This check\n    //       exists only to improve the error message.\n\n    if (arguments.length < 3) {\n      throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n    }\n\n    CreateTemporalDateSlots(this, isoYear, isoMonth, isoDay, calendar);\n  }\n\n  get calendar() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR);\n  }\n\n  get era() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n\n  get eraYear() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get year() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get month() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n\n  get monthCode() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n\n  get day() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n\n  get dayOfWeek() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n  }\n\n  get dayOfYear() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get weekOfYear() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get daysInWeek() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n  }\n\n  get daysInMonth() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n\n  get daysInYear() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get monthsInYear() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get inLeapYear() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n\n  with(temporalDateLike, optionsParam = undefined) {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n\n    if (!IsObject(temporalDateLike)) {\n      throw new TypeError('invalid argument');\n    }\n\n    RejectObjectWithCalendarOrTimeZone(temporalDateLike);\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n    const props = ToPartialRecord(temporalDateLike, fieldNames);\n\n    if (!props) {\n      throw new TypeError('invalid date-like');\n    }\n\n    let fields = ToTemporalDateFields(this, fieldNames);\n    fields = CalendarMergeFields(calendar, fields, props);\n    fields = ToTemporalDateFields(fields, fieldNames);\n    const options = GetOptionsObject(optionsParam);\n    return DateFromFields(calendar, fields, options);\n  }\n\n  withCalendar(calendarParam) {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = ToTemporalCalendar(calendarParam);\n    return new PlainDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n  }\n\n  add(temporalDurationLike, optionsParam = undefined) {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const duration = ToTemporalDuration(temporalDurationLike);\n    const options = GetOptionsObject(optionsParam);\n    return CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n  }\n\n  subtract(temporalDurationLike, optionsParam = undefined) {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const duration = CreateNegatedTemporalDuration(ToTemporalDuration(temporalDurationLike));\n    const options = GetOptionsObject(optionsParam);\n    return CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n  }\n\n  until(otherParam, optionsParam = undefined) {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalDate(otherParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarId = ToString(calendar);\n    const otherCalendarId = ToString(otherCalendar);\n\n    if (calendarId !== otherCalendarId) {\n      throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n    }\n\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS$2);\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$2, defaultLargestUnit);\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n    const untilOptions = { ...options,\n      largestUnit\n    };\n    const result = CalendarDateUntil(calendar, this, other, untilOptions);\n    if (smallestUnit === 'day' && roundingIncrement === 1) return result;\n    let {\n      years,\n      months,\n      weeks,\n      days\n    } = result;\n    ({\n      years,\n      months,\n      weeks,\n      days\n    } = RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, this));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n  }\n\n  since(otherParam, optionsParam = undefined) {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalDate(otherParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarId = ToString(calendar);\n    const otherCalendarId = ToString(otherCalendar);\n\n    if (calendarId !== otherCalendarId) {\n      throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n    }\n\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS$2);\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$2, defaultLargestUnit);\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n    const untilOptions = { ...options,\n      largestUnit\n    };\n    let {\n      years,\n      months,\n      weeks,\n      days\n    } = CalendarDateUntil(calendar, this, other, untilOptions);\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n\n    if (smallestUnit === 'day' && roundingIncrement === 1) {\n      return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n    }\n\n    ({\n      years,\n      months,\n      weeks,\n      days\n    } = RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), this));\n    return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n  }\n\n  equals(otherParam) {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalDate(otherParam);\n\n    for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n\n    return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n\n  toString(optionsParam = undefined) {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const options = GetOptionsObject(optionsParam);\n    const showCalendar = ToShowCalendarOption(options);\n    return TemporalDateToString(this, showCalendar);\n  }\n\n  toJSON() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return TemporalDateToString(this);\n  }\n\n  toLocaleString(locales = undefined, options = undefined) {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n\n  valueOf() {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainDate');\n  }\n\n  toPlainDateTime(temporalTimeParam = undefined) {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n    if (temporalTimeParam === undefined) return CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n    const temporalTime = ToTemporalTime(temporalTimeParam);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n  }\n\n  toZonedDateTime(item) {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    let timeZone, temporalTime;\n\n    if (IsObject(item)) {\n      const timeZoneLike = item.timeZone;\n\n      if (timeZoneLike === undefined) {\n        // The cast below is needed because it's possible here for\n        // `timeZoneLike` here to be `{ plainTime: Temporal.PlainTimeLike }`,\n        // not a TimeZoneProtocol.\n        // TODO: should we check for that shape to improve on the (bad) error\n        // message that the caller will get from ToTemporalTimeZone?\n        timeZone = ToTemporalTimeZone(item);\n      } else {\n        timeZone = ToTemporalTimeZone(timeZoneLike);\n        temporalTime = item.plainTime;\n      }\n    } else {\n      timeZone = ToTemporalTimeZone(item);\n    }\n\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n    let hour = 0,\n        minute = 0,\n        second = 0,\n        millisecond = 0,\n        microsecond = 0,\n        nanosecond = 0;\n\n    if (temporalTime !== undefined) {\n      temporalTime = ToTemporalTime(temporalTime);\n      hour = GetSlot(temporalTime, ISO_HOUR);\n      minute = GetSlot(temporalTime, ISO_MINUTE);\n      second = GetSlot(temporalTime, ISO_SECOND);\n      millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n      microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n      nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n    }\n\n    const dt = CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n    return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n\n  toPlainYearMonth() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n    const fields = ToTemporalYearMonthFields(this, fieldNames);\n    return YearMonthFromFields(calendar, fields);\n  }\n\n  toPlainMonthDay() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n    const fields = ToTemporalMonthDayFields(this, fieldNames);\n    return MonthDayFromFields(calendar, fields);\n  }\n\n  getISOFields() {\n    if (!IsTemporalDate(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n\n  static from(item, optionsParam = undefined) {\n    const options = GetOptionsObject(optionsParam);\n\n    if (IsTemporalDate(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n\n      return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n    }\n\n    return ToTemporalDate(item, options);\n  }\n\n  static compare(oneParam, twoParam) {\n    const one = ToTemporalDate(oneParam);\n    const two = ToTemporalDate(twoParam);\n    return CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n  }\n\n}\n\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n\nclass PlainDateTime {\n  constructor(isoYearParam, isoMonthParam, isoDayParam, hourParam = 0, minuteParam = 0, secondParam = 0, millisecondParam = 0, microsecondParam = 0, nanosecondParam = 0, calendarParam = GetISO8601Calendar()) {\n    const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n    const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n    const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n    const hour = ToIntegerThrowOnInfinity(hourParam);\n    const minute = ToIntegerThrowOnInfinity(minuteParam);\n    const second = ToIntegerThrowOnInfinity(secondParam);\n    const millisecond = ToIntegerThrowOnInfinity(millisecondParam);\n    const microsecond = ToIntegerThrowOnInfinity(microsecondParam);\n    const nanosecond = ToIntegerThrowOnInfinity(nanosecondParam);\n    const calendar = ToTemporalCalendar(calendarParam); // Note: if the arguments are not passed,\n    //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n    //       be rejected by RejectDateTime in CreateTemporalDateTimeSlots. This\n    //       check exists only to improve the error message.\n\n    if (arguments.length < 3) {\n      throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n    }\n\n    CreateTemporalDateTimeSlots(this, isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n  }\n\n  get calendar() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR);\n  }\n\n  get year() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get month() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n\n  get monthCode() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n\n  get day() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n\n  get hour() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_HOUR);\n  }\n\n  get minute() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MINUTE);\n  }\n\n  get second() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_SECOND);\n  }\n\n  get millisecond() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MILLISECOND);\n  }\n\n  get microsecond() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MICROSECOND);\n  }\n\n  get nanosecond() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_NANOSECOND);\n  }\n\n  get era() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n\n  get eraYear() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get dayOfWeek() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n  }\n\n  get dayOfYear() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get weekOfYear() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get daysInWeek() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n  }\n\n  get daysInYear() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get daysInMonth() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n\n  get monthsInYear() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get inLeapYear() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n\n  with(temporalDateTimeLike, optionsParam = undefined) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n\n    if (!IsObject(temporalDateTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n\n    RejectObjectWithCalendarOrTimeZone(temporalDateTimeLike);\n    const options = GetOptionsObject(optionsParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['day', 'hour', 'microsecond', 'millisecond', 'minute', 'month', 'monthCode', 'nanosecond', 'second', 'year']);\n    const props = ToPartialRecord(temporalDateTimeLike, fieldNames);\n\n    if (!props) {\n      throw new TypeError('invalid date-time-like');\n    }\n\n    let fields = ToTemporalDateTimeFields(this, fieldNames);\n    fields = CalendarMergeFields(calendar, fields, props);\n    fields = ToTemporalDateTimeFields(fields, fieldNames);\n    const {\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = InterpretTemporalDateTimeFields(calendar, fields, options);\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n  }\n\n  withPlainTime(temporalTimeParam = undefined) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const year = GetSlot(this, ISO_YEAR);\n    const month = GetSlot(this, ISO_MONTH);\n    const day = GetSlot(this, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n    if (temporalTimeParam === undefined) return CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n    const temporalTime = ToTemporalTime(temporalTimeParam);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n  }\n\n  withPlainDate(temporalDateParam) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const temporalDate = ToTemporalDate(temporalDateParam);\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    let calendar = GetSlot(temporalDate, CALENDAR);\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n    calendar = ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n  }\n\n  withCalendar(calendarParam) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = ToTemporalCalendar(calendarParam);\n    return new PlainDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar);\n  }\n\n  add(temporalDurationLike, optionsParam = undefined) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const duration = ToLimitedTemporalDuration(temporalDurationLike);\n    const {\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = duration;\n    const options = GetOptionsObject(optionsParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const {\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n  }\n\n  subtract(temporalDurationLike, optionsParam = undefined) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const duration = ToLimitedTemporalDuration(temporalDurationLike);\n    const {\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = duration;\n    const options = GetOptionsObject(optionsParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const {\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n  }\n\n  until(otherParam, optionsParam = undefined) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalDateTime(otherParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarId = ToString(calendar);\n    const otherCalendarId = ToString(otherCalendar);\n\n    if (calendarId !== otherCalendarId) {\n      throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n    }\n\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n    let {\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n    const relativeTo = TemporalDateTimeToDate(this);\n    ({\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n    ({\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n\n  since(otherParam, optionsParam = undefined) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalDateTime(otherParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarId = ToString(calendar);\n    const otherCalendarId = ToString(otherCalendar);\n\n    if (calendarId !== otherCalendarId) {\n      throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n    }\n\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n    let {\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n    const relativeTo = TemporalDateTimeToDate(this);\n    ({\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), relativeTo));\n    ({\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n  }\n\n  round(optionsParam) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    if (optionsParam === undefined) throw new TypeError('options parameter is required');\n    const options = typeof optionsParam === 'string' ? CreateOnePropObject('smallestUnit', optionsParam) : GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n    if (smallestUnit === undefined) throw new RangeError('smallestUnit is required');\n    const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n    let year = GetSlot(this, ISO_YEAR);\n    let month = GetSlot(this, ISO_MONTH);\n    let day = GetSlot(this, ISO_DAY);\n    let hour = GetSlot(this, ISO_HOUR);\n    let minute = GetSlot(this, ISO_MINUTE);\n    let second = GetSlot(this, ISO_SECOND);\n    let millisecond = GetSlot(this, ISO_MILLISECOND);\n    let microsecond = GetSlot(this, ISO_MICROSECOND);\n    let nanosecond = GetSlot(this, ISO_NANOSECOND);\n    ({\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, GetSlot(this, CALENDAR));\n  }\n\n  equals(otherParam) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalDateTime(otherParam);\n\n    for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n\n    return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n\n  toString(optionsParam = undefined) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const options = GetOptionsObject(optionsParam);\n    const {\n      precision,\n      unit,\n      increment\n    } = ToSecondsStringPrecision(options);\n    const showCalendar = ToShowCalendarOption(options);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    return TemporalDateTimeToString(this, precision, showCalendar, {\n      unit,\n      increment,\n      roundingMode\n    });\n  }\n\n  toJSON() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return TemporalDateTimeToString(this, 'auto');\n  }\n\n  toLocaleString(locales = undefined, options = undefined) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n\n  valueOf() {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainDateTime');\n  }\n\n  toZonedDateTime(temporalTimeZoneLike, optionsParam = undefined) {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const timeZone = ToTemporalTimeZone(temporalTimeZoneLike);\n    const options = GetOptionsObject(optionsParam);\n    const disambiguation = ToTemporalDisambiguation(options);\n    const instant = BuiltinTimeZoneGetInstantFor(timeZone, this, disambiguation);\n    return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n  }\n\n  toPlainDate() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return TemporalDateTimeToDate(this);\n  }\n\n  toPlainYearMonth() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n    const fields = ToTemporalYearMonthFields(this, fieldNames);\n    return YearMonthFromFields(calendar, fields);\n  }\n\n  toPlainMonthDay() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n    const fields = ToTemporalMonthDayFields(this, fieldNames);\n    return MonthDayFromFields(calendar, fields);\n  }\n\n  toPlainTime() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return TemporalDateTimeToTime(this);\n  }\n\n  getISOFields() {\n    if (!IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoHour: GetSlot(this, ISO_HOUR),\n      isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n      isoMinute: GetSlot(this, ISO_MINUTE),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n      isoSecond: GetSlot(this, ISO_SECOND),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n\n  static from(item, optionsParam = undefined) {\n    const options = GetOptionsObject(optionsParam);\n\n    if (IsTemporalDateTime(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n\n      return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND), GetSlot(item, CALENDAR));\n    }\n\n    return ToTemporalDateTime(item, options);\n  }\n\n  static compare(oneParam, twoParam) {\n    const one = ToTemporalDateTime(oneParam);\n    const two = ToTemporalDateTime(twoParam);\n\n    for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n      const val1 = GetSlot(one, slot);\n      const val2 = GetSlot(two, slot);\n      if (val1 !== val2) return ComparisonResult(val1 - val2);\n    }\n\n    return 0;\n  }\n\n}\n\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n\nclass Duration {\n  constructor(yearsParam = 0, monthsParam = 0, weeksParam = 0, daysParam = 0, hoursParam = 0, minutesParam = 0, secondsParam = 0, millisecondsParam = 0, microsecondsParam = 0, nanosecondsParam = 0) {\n    const years = ToIntegerWithoutRounding(yearsParam);\n    const months = ToIntegerWithoutRounding(monthsParam);\n    const weeks = ToIntegerWithoutRounding(weeksParam);\n    const days = ToIntegerWithoutRounding(daysParam);\n    const hours = ToIntegerWithoutRounding(hoursParam);\n    const minutes = ToIntegerWithoutRounding(minutesParam);\n    const seconds = ToIntegerWithoutRounding(secondsParam);\n    const milliseconds = ToIntegerWithoutRounding(millisecondsParam);\n    const microseconds = ToIntegerWithoutRounding(microsecondsParam);\n    const nanoseconds = ToIntegerWithoutRounding(nanosecondsParam);\n    const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n    for (const prop of [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]) {\n      if (!Number.isFinite(prop)) throw new RangeError('infinite values not allowed as duration fields');\n      const propSign = Math.sign(prop);\n      if (propSign !== 0 && propSign !== sign) throw new RangeError('mixed-sign values not allowed as duration fields');\n    }\n\n    CreateSlots(this);\n    SetSlot(this, YEARS, years);\n    SetSlot(this, MONTHS, months);\n    SetSlot(this, WEEKS, weeks);\n    SetSlot(this, DAYS, days);\n    SetSlot(this, HOURS, hours);\n    SetSlot(this, MINUTES, minutes);\n    SetSlot(this, SECONDS, seconds);\n    SetSlot(this, MILLISECONDS, milliseconds);\n    SetSlot(this, MICROSECONDS, microseconds);\n    SetSlot(this, NANOSECONDS, nanoseconds);\n    {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${TemporalDurationToString(this)}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  get years() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, YEARS);\n  }\n\n  get months() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MONTHS);\n  }\n\n  get weeks() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, WEEKS);\n  }\n\n  get days() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, DAYS);\n  }\n\n  get hours() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, HOURS);\n  }\n\n  get minutes() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MINUTES);\n  }\n\n  get seconds() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, SECONDS);\n  }\n\n  get milliseconds() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MILLISECONDS);\n  }\n\n  get microseconds() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, MICROSECONDS);\n  }\n\n  get nanoseconds() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, NANOSECONDS);\n  }\n\n  get sign() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS));\n  }\n\n  get blank() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS)) === 0;\n  }\n\n  with(durationLike) {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    const props = ToPartialRecord(durationLike, ['days', 'hours', 'microseconds', 'milliseconds', 'minutes', 'months', 'nanoseconds', 'seconds', 'weeks', 'years']);\n\n    if (!props) {\n      throw new TypeError('invalid duration-like');\n    }\n\n    const {\n      years = GetSlot(this, YEARS),\n      months = GetSlot(this, MONTHS),\n      weeks = GetSlot(this, WEEKS),\n      days = GetSlot(this, DAYS),\n      hours = GetSlot(this, HOURS),\n      minutes = GetSlot(this, MINUTES),\n      seconds = GetSlot(this, SECONDS),\n      milliseconds = GetSlot(this, MILLISECONDS),\n      microseconds = GetSlot(this, MICROSECONDS),\n      nanoseconds = GetSlot(this, NANOSECONDS)\n    } = props;\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n\n  negated() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return CreateNegatedTemporalDuration(this);\n  }\n\n  abs() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return new Duration(Math.abs(GetSlot(this, YEARS)), Math.abs(GetSlot(this, MONTHS)), Math.abs(GetSlot(this, WEEKS)), Math.abs(GetSlot(this, DAYS)), Math.abs(GetSlot(this, HOURS)), Math.abs(GetSlot(this, MINUTES)), Math.abs(GetSlot(this, SECONDS)), Math.abs(GetSlot(this, MILLISECONDS)), Math.abs(GetSlot(this, MICROSECONDS)), Math.abs(GetSlot(this, NANOSECONDS)));\n  }\n\n  add(other, optionsParam = undefined) {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    let {\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = ToLimitedTemporalDuration(other);\n    const options = GetOptionsObject(optionsParam);\n    const relativeTo = ToRelativeTemporalObject(options);\n    ({\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, relativeTo));\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n\n  subtract(other, optionsParam = undefined) {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    let {\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = ToLimitedTemporalDuration(other);\n    const options = GetOptionsObject(optionsParam);\n    const relativeTo = ToRelativeTemporalObject(options);\n    ({\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, relativeTo));\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n\n  round(optionsParam) {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    if (optionsParam === undefined) throw new TypeError('options parameter is required');\n    let years = GetSlot(this, YEARS);\n    let months = GetSlot(this, MONTHS);\n    let weeks = GetSlot(this, WEEKS);\n    let days = GetSlot(this, DAYS);\n    let hours = GetSlot(this, HOURS);\n    let minutes = GetSlot(this, MINUTES);\n    let seconds = GetSlot(this, SECONDS);\n    let milliseconds = GetSlot(this, MILLISECONDS);\n    let microseconds = GetSlot(this, MICROSECONDS);\n    let nanoseconds = GetSlot(this, NANOSECONDS);\n    let defaultLargestUnit = DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    const options = typeof optionsParam === 'string' ? CreateOnePropObject('smallestUnit', optionsParam) : GetOptionsObject(optionsParam);\n    let smallestUnit = ToSmallestTemporalUnit(options, undefined);\n    let smallestUnitPresent = true;\n\n    if (!smallestUnit) {\n      smallestUnitPresent = false;\n      smallestUnit = 'nanosecond';\n    }\n\n    defaultLargestUnit = LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit);\n    let largestUnit = ToLargestTemporalUnit(options, undefined);\n    let largestUnitPresent = true;\n\n    if (!largestUnit) {\n      largestUnitPresent = false;\n      largestUnit = defaultLargestUnit;\n    }\n\n    if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\n\n    if (!smallestUnitPresent && !largestUnitPresent) {\n      throw new RangeError('at least one of smallestUnit or largestUnit is required');\n    }\n\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n    const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n    let relativeTo = ToRelativeTemporalObject(options);\n    ({\n      years,\n      months,\n      weeks,\n      days\n    } = UnbalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n    ({\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n    ({\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n    ({\n      years,\n      months,\n      weeks,\n      days\n    } = BalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n\n    if (IsTemporalZonedDateTime(relativeTo)) {\n      relativeTo = MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n    }\n\n    ({\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit, relativeTo));\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n\n  total(optionsParam) {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    let years = GetSlot(this, YEARS);\n    let months = GetSlot(this, MONTHS);\n    let weeks = GetSlot(this, WEEKS);\n    let days = GetSlot(this, DAYS);\n    let hours = GetSlot(this, HOURS);\n    let minutes = GetSlot(this, MINUTES);\n    let seconds = GetSlot(this, SECONDS);\n    let milliseconds = GetSlot(this, MILLISECONDS);\n    let microseconds = GetSlot(this, MICROSECONDS);\n    let nanoseconds = GetSlot(this, NANOSECONDS);\n    if (optionsParam === undefined) throw new TypeError('options argument is required');\n    const options = typeof optionsParam === 'string' ? CreateOnePropObject('unit', optionsParam) : GetOptionsObject(optionsParam);\n    const unit = ToTemporalDurationTotalUnit(options);\n    if (unit === undefined) throw new RangeError('unit option is required');\n    const relativeTo = ToRelativeTemporalObject(options); // Convert larger units down to days\n\n    ({\n      years,\n      months,\n      weeks,\n      days\n    } = UnbalanceDurationRelative(years, months, weeks, days, unit, relativeTo)); // If the unit we're totalling is smaller than `days`, convert days down to that unit.\n\n    let intermediate;\n\n    if (IsTemporalZonedDateTime(relativeTo)) {\n      intermediate = MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n    }\n\n    ({\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, unit, intermediate)); // Finally, truncate to the correct unit and calculate remainder\n\n    const {\n      total\n    } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 1, unit, 'trunc', relativeTo);\n    return total;\n  }\n\n  toString(optionsParam = undefined) {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    const options = GetOptionsObject(optionsParam);\n    const {\n      precision,\n      unit,\n      increment\n    } = ToSecondsStringPrecision(options);\n    if (precision === 'minute') throw new RangeError('smallestUnit must not be \"minute\"');\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    return TemporalDurationToString(this, precision, {\n      unit,\n      increment,\n      roundingMode\n    });\n  }\n\n  toJSON() {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n    return TemporalDurationToString(this);\n  }\n\n  toLocaleString(locales = undefined, options = undefined) {\n    if (!IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n\n    if (typeof Intl !== 'undefined' && typeof Intl.DurationFormat !== 'undefined') {\n      return new Intl.DurationFormat(locales, options).format(this);\n    }\n\n    console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n    return TemporalDurationToString(this);\n  }\n\n  valueOf() {\n    throw new TypeError('use compare() to compare Temporal.Duration');\n  }\n\n  static from(item) {\n    if (IsTemporalDuration(item)) {\n      return new Duration(GetSlot(item, YEARS), GetSlot(item, MONTHS), GetSlot(item, WEEKS), GetSlot(item, DAYS), GetSlot(item, HOURS), GetSlot(item, MINUTES), GetSlot(item, SECONDS), GetSlot(item, MILLISECONDS), GetSlot(item, MICROSECONDS), GetSlot(item, NANOSECONDS));\n    }\n\n    return ToTemporalDuration(item);\n  }\n\n  static compare(oneParam, twoParam, optionsParam = undefined) {\n    const one = ToTemporalDuration(oneParam);\n    const two = ToTemporalDuration(twoParam);\n    const options = GetOptionsObject(optionsParam);\n    const relativeTo = ToRelativeTemporalObject(options);\n    const y1 = GetSlot(one, YEARS);\n    const mon1 = GetSlot(one, MONTHS);\n    const w1 = GetSlot(one, WEEKS);\n    let d1 = GetSlot(one, DAYS);\n    const h1 = GetSlot(one, HOURS);\n    const min1 = GetSlot(one, MINUTES);\n    const s1 = GetSlot(one, SECONDS);\n    const ms1 = GetSlot(one, MILLISECONDS);\n    const µs1 = GetSlot(one, MICROSECONDS);\n    let ns1 = GetSlot(one, NANOSECONDS);\n    const y2 = GetSlot(two, YEARS);\n    const mon2 = GetSlot(two, MONTHS);\n    const w2 = GetSlot(two, WEEKS);\n    let d2 = GetSlot(two, DAYS);\n    const h2 = GetSlot(two, HOURS);\n    const min2 = GetSlot(two, MINUTES);\n    const s2 = GetSlot(two, SECONDS);\n    const ms2 = GetSlot(two, MILLISECONDS);\n    const µs2 = GetSlot(two, MICROSECONDS);\n    let ns2 = GetSlot(two, NANOSECONDS);\n    const shift1 = CalculateOffsetShift(relativeTo, y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1);\n    const shift2 = CalculateOffsetShift(relativeTo, y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2);\n\n    if (y1 !== 0 || y2 !== 0 || mon1 !== 0 || mon2 !== 0 || w1 !== 0 || w2 !== 0) {\n      ({\n        days: d1\n      } = UnbalanceDurationRelative(y1, mon1, w1, d1, 'day', relativeTo));\n      ({\n        days: d2\n      } = UnbalanceDurationRelative(y2, mon2, w2, d2, 'day', relativeTo));\n    }\n\n    const totalNs1 = TotalDurationNanoseconds(d1, h1, min1, s1, ms1, µs1, ns1, shift1);\n    const totalNs2 = TotalDurationNanoseconds(d2, h2, min2, s2, ms2, µs2, ns2, shift2);\n    return ComparisonResult(JSBI.toNumber(JSBI.subtract(totalNs1, totalNs2)));\n  }\n\n}\n\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\nconst ObjectCreate$1 = Object.create;\n\nclass PlainMonthDay {\n  constructor(isoMonthParam, isoDayParam, calendarParam = GetISO8601Calendar(), referenceISOYearParam = 1972) {\n    const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n    const isoDay = ToIntegerThrowOnInfinity(isoDayParam);\n    const calendar = ToTemporalCalendar(calendarParam);\n    const referenceISOYear = ToIntegerThrowOnInfinity(referenceISOYearParam); // Note: if the arguments are not passed,\n    //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n    //       be rejected by RejectISODate in CreateTemporalMonthDaySlots. This\n    //       check exists only to improve the error message.\n\n    if (arguments.length < 2) {\n      throw new RangeError('missing argument: isoMonth and isoDay are required');\n    }\n\n    CreateTemporalMonthDaySlots(this, isoMonth, isoDay, calendar, referenceISOYear);\n  }\n\n  get monthCode() {\n    if (!IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n\n  get day() {\n    if (!IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return CalendarDay(GetSlot(this, CALENDAR), this);\n  }\n\n  get calendar() {\n    if (!IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR);\n  }\n\n  with(temporalMonthDayLike, optionsParam = undefined) {\n    if (!IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n\n    if (!IsObject(temporalMonthDayLike)) {\n      throw new TypeError('invalid argument');\n    }\n\n    RejectObjectWithCalendarOrTimeZone(temporalMonthDayLike);\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n    const props = ToPartialRecord(temporalMonthDayLike, fieldNames);\n\n    if (!props) {\n      throw new TypeError('invalid month-day-like');\n    }\n\n    let fields = ToTemporalMonthDayFields(this, fieldNames);\n    fields = CalendarMergeFields(calendar, fields, props);\n    fields = ToTemporalMonthDayFields(fields, fieldNames);\n    const options = GetOptionsObject(optionsParam);\n    return MonthDayFromFields(calendar, fields, options);\n  }\n\n  equals(otherParam) {\n    if (!IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalMonthDay(otherParam);\n\n    for (const slot of [ISO_MONTH, ISO_DAY, ISO_YEAR]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n\n    return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n\n  toString(optionsParam = undefined) {\n    if (!IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    const options = GetOptionsObject(optionsParam);\n    const showCalendar = ToShowCalendarOption(options);\n    return TemporalMonthDayToString(this, showCalendar);\n  }\n\n  toJSON() {\n    if (!IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return TemporalMonthDayToString(this);\n  }\n\n  toLocaleString(locales = undefined, options = undefined) {\n    if (!IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n\n  valueOf() {\n    throw new TypeError('use equals() to compare Temporal.PlainMonthDay');\n  }\n\n  toPlainDate(item) {\n    if (!IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    if (!IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n    const receiverFieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n    const fields = ToTemporalMonthDayFields(this, receiverFieldNames);\n    const inputFieldNames = CalendarFields(calendar, ['year']);\n    const inputEntries = [['year', undefined]]; // Add extra fields from the calendar at the end\n\n    inputFieldNames.forEach(fieldName => {\n      if (!inputEntries.some(([name]) => name === fieldName)) {\n        inputEntries.push([fieldName, undefined]); // Make TS ignore extra fields\n      }\n    });\n    const inputFields = PrepareTemporalFields(item, inputEntries);\n    let mergedFields = CalendarMergeFields(calendar, fields, inputFields);\n    const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n    const mergedEntries = [];\n    mergedFieldNames.forEach(fieldName => {\n      if (!mergedEntries.some(([name]) => name === fieldName)) {\n        mergedEntries.push([fieldName, undefined]);\n      }\n    });\n    mergedFields = PrepareTemporalFields(mergedFields, mergedEntries);\n    const options = ObjectCreate$1(null);\n    options.overflow = 'reject';\n    return DateFromFields(calendar, mergedFields, options);\n  }\n\n  getISOFields() {\n    if (!IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n\n  static from(item, optionsParam = undefined) {\n    const options = GetOptionsObject(optionsParam);\n\n    if (IsTemporalMonthDay(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n\n      return CreateTemporalMonthDay(GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR), GetSlot(item, ISO_YEAR));\n    }\n\n    return ToTemporalMonthDay(item, options);\n  }\n\n}\n\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n\nconst instant = () => {\n  const Instant = GetIntrinsic('%Temporal.Instant%');\n  return new Instant(SystemUTCEpochNanoSeconds());\n};\n\nconst plainDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n  const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n  const calendar = ToTemporalCalendar(calendarLike);\n  const inst = instant();\n  return BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\n\nconst plainDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n  const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n  const calendar = GetISO8601Calendar();\n  const inst = instant();\n  return BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\n\nconst zonedDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n  const tZ = ToTemporalTimeZone(temporalTimeZoneLike);\n  const calendar = ToTemporalCalendar(calendarLike);\n  return CreateTemporalZonedDateTime(SystemUTCEpochNanoSeconds(), tZ, calendar);\n};\n\nconst zonedDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n  return zonedDateTime(GetISO8601Calendar(), temporalTimeZoneLike);\n};\n\nconst plainDate = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n  return TemporalDateTimeToDate(plainDateTime(calendarLike, temporalTimeZoneLike));\n};\n\nconst plainDateISO = (temporalTimeZoneLike = timeZone()) => {\n  return TemporalDateTimeToDate(plainDateTimeISO(temporalTimeZoneLike));\n};\n\nconst plainTimeISO = (temporalTimeZoneLike = timeZone()) => {\n  return TemporalDateTimeToTime(plainDateTimeISO(temporalTimeZoneLike));\n};\n\nconst timeZone = () => {\n  return SystemTimeZone();\n};\n\nconst Now = {\n  instant,\n  plainDateTime,\n  plainDateTimeISO,\n  plainDate,\n  plainDateISO,\n  plainTimeISO,\n  timeZone,\n  zonedDateTime,\n  zonedDateTimeISO,\n  [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n  value: 'Temporal.Now',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nconst ObjectAssign = Object.assign;\nconst DISALLOWED_UNITS$1 = ['year', 'month', 'week', 'day'];\nconst MAX_INCREMENTS = {\n  hour: 24,\n  minute: 60,\n  second: 60,\n  millisecond: 1000,\n  microsecond: 1000,\n  nanosecond: 1000\n};\n\nfunction TemporalTimeToString(time, precision, options = undefined) {\n  let hour = GetSlot(time, ISO_HOUR);\n  let minute = GetSlot(time, ISO_MINUTE);\n  let second = GetSlot(time, ISO_SECOND);\n  let millisecond = GetSlot(time, ISO_MILLISECOND);\n  let microsecond = GetSlot(time, ISO_MICROSECOND);\n  let nanosecond = GetSlot(time, ISO_NANOSECOND);\n\n  if (options) {\n    const {\n      unit,\n      increment,\n      roundingMode\n    } = options;\n    ({\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n  }\n\n  const hourString = ISODateTimePartString(hour);\n  const minuteString = ISODateTimePartString(minute);\n  const seconds = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n  return `${hourString}:${minuteString}${seconds}`;\n}\n\nclass PlainTime {\n  constructor(isoHourParam = 0, isoMinuteParam = 0, isoSecondParam = 0, isoMillisecondParam = 0, isoMicrosecondParam = 0, isoNanosecondParam = 0) {\n    const isoHour = ToIntegerThrowOnInfinity(isoHourParam);\n    const isoMinute = ToIntegerThrowOnInfinity(isoMinuteParam);\n    const isoSecond = ToIntegerThrowOnInfinity(isoSecondParam);\n    const isoMillisecond = ToIntegerThrowOnInfinity(isoMillisecondParam);\n    const isoMicrosecond = ToIntegerThrowOnInfinity(isoMicrosecondParam);\n    const isoNanosecond = ToIntegerThrowOnInfinity(isoNanosecondParam);\n    RejectTime(isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond);\n    CreateSlots(this);\n    SetSlot(this, ISO_HOUR, isoHour);\n    SetSlot(this, ISO_MINUTE, isoMinute);\n    SetSlot(this, ISO_SECOND, isoSecond);\n    SetSlot(this, ISO_MILLISECOND, isoMillisecond);\n    SetSlot(this, ISO_MICROSECOND, isoMicrosecond);\n    SetSlot(this, ISO_NANOSECOND, isoNanosecond);\n    SetSlot(this, CALENDAR, GetISO8601Calendar());\n    {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${TemporalTimeToString(this, 'auto')}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  get calendar() {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver'); // PlainTime's calendar isn't settable, so can't be a userland calendar\n\n    return GetSlot(this, CALENDAR);\n  }\n\n  get hour() {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_HOUR);\n  }\n\n  get minute() {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MINUTE);\n  }\n\n  get second() {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_SECOND);\n  }\n\n  get millisecond() {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MILLISECOND);\n  }\n\n  get microsecond() {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_MICROSECOND);\n  }\n\n  get nanosecond() {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, ISO_NANOSECOND);\n  }\n\n  with(temporalTimeLike, optionsParam = undefined) {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n\n    if (!IsObject(temporalTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n\n    RejectObjectWithCalendarOrTimeZone(temporalTimeLike);\n    const options = GetOptionsObject(optionsParam);\n    const overflow = ToTemporalOverflow(options);\n    const props = ToPartialRecord(temporalTimeLike, ['hour', 'microsecond', 'millisecond', 'minute', 'nanosecond', 'second']);\n\n    if (!props) {\n      throw new TypeError('invalid time-like');\n    }\n\n    const fields = ToTemporalTimeRecord(this);\n    let {\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = ObjectAssign(fields, props);\n    ({\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n\n  add(temporalDurationLike) {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const duration = ToLimitedTemporalDuration(temporalDurationLike);\n    const {\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = duration;\n    let hour = GetSlot(this, ISO_HOUR);\n    let minute = GetSlot(this, ISO_MINUTE);\n    let second = GetSlot(this, ISO_SECOND);\n    let millisecond = GetSlot(this, ISO_MILLISECOND);\n    let microsecond = GetSlot(this, ISO_MICROSECOND);\n    let nanosecond = GetSlot(this, ISO_NANOSECOND);\n    ({\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = AddTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n    ({\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n\n  subtract(temporalDurationLike) {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const duration = ToLimitedTemporalDuration(temporalDurationLike);\n    const {\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = duration;\n    let hour = GetSlot(this, ISO_HOUR);\n    let minute = GetSlot(this, ISO_MINUTE);\n    let second = GetSlot(this, ISO_SECOND);\n    let millisecond = GetSlot(this, ISO_MILLISECOND);\n    let microsecond = GetSlot(this, ISO_MICROSECOND);\n    let nanosecond = GetSlot(this, ISO_NANOSECOND);\n    ({\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = AddTime(hour, minute, second, millisecond, microsecond, nanosecond, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds));\n    ({\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n\n  until(otherParam, optionsParam = undefined) {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalTime(otherParam);\n    const options = GetOptionsObject(optionsParam);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$1, 'hour');\n    const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$1);\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n    let {\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = DifferenceTime(GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND));\n    ({\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = RoundDuration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode));\n    ({\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n\n  since(otherParam, optionsParam = undefined) {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalTime(otherParam);\n    const options = GetOptionsObject(optionsParam);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS$1, 'hour');\n    const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS$1);\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n    let {\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = DifferenceTime(GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND));\n    ({\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = RoundDuration(0, 0, 0, 0, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode)));\n    hours = -hours;\n    minutes = -minutes;\n    seconds = -seconds;\n    milliseconds = -milliseconds;\n    microseconds = -microseconds;\n    nanoseconds = -nanoseconds;\n    ({\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n\n  round(optionsParam) {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    if (optionsParam === undefined) throw new TypeError('options parameter is required');\n    const options = typeof optionsParam === 'string' ? CreateOnePropObject('smallestUnit', optionsParam) : GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS$1);\n    if (smallestUnit === undefined) throw new RangeError('smallestUnit is required');\n    const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n    const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n    let hour = GetSlot(this, ISO_HOUR);\n    let minute = GetSlot(this, ISO_MINUTE);\n    let second = GetSlot(this, ISO_SECOND);\n    let millisecond = GetSlot(this, ISO_MILLISECOND);\n    let microsecond = GetSlot(this, ISO_MICROSECOND);\n    let nanosecond = GetSlot(this, ISO_NANOSECOND);\n    ({\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n\n  equals(otherParam) {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalTime(otherParam);\n\n    for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n\n    return true;\n  }\n\n  toString(optionsParam = undefined) {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const options = GetOptionsObject(optionsParam);\n    const {\n      precision,\n      unit,\n      increment\n    } = ToSecondsStringPrecision(options);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    return TemporalTimeToString(this, precision, {\n      unit,\n      increment,\n      roundingMode\n    });\n  }\n\n  toJSON() {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return TemporalTimeToString(this, 'auto');\n  }\n\n  toLocaleString(locales = undefined, options = undefined) {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n\n  valueOf() {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainTime');\n  }\n\n  toPlainDateTime(temporalDateParam) {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    const temporalDate = ToTemporalDate(temporalDateParam);\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    const calendar = GetSlot(temporalDate, CALENDAR);\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n  }\n\n  toZonedDateTime(item) {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n\n    if (!IsObject(item)) {\n      throw new TypeError('invalid argument');\n    }\n\n    const dateLike = item.plainDate;\n\n    if (dateLike === undefined) {\n      throw new TypeError('missing date property');\n    }\n\n    const temporalDate = ToTemporalDate(dateLike);\n    const timeZoneLike = item.timeZone;\n\n    if (timeZoneLike === undefined) {\n      throw new TypeError('missing timeZone property');\n    }\n\n    const timeZone = ToTemporalTimeZone(timeZoneLike);\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    const calendar = GetSlot(temporalDate, CALENDAR);\n    const hour = GetSlot(this, ISO_HOUR);\n    const minute = GetSlot(this, ISO_MINUTE);\n    const second = GetSlot(this, ISO_SECOND);\n    const millisecond = GetSlot(this, ISO_MILLISECOND);\n    const microsecond = GetSlot(this, ISO_MICROSECOND);\n    const nanosecond = GetSlot(this, ISO_NANOSECOND);\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n    return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n\n  getISOFields() {\n    if (!IsTemporalTime(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoHour: GetSlot(this, ISO_HOUR),\n      isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n      isoMinute: GetSlot(this, ISO_MINUTE),\n      isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n      isoSecond: GetSlot(this, ISO_SECOND)\n    };\n  }\n\n  static from(item, optionsParam = undefined) {\n    const options = GetOptionsObject(optionsParam);\n    const overflow = ToTemporalOverflow(options);\n\n    if (IsTemporalTime(item)) {\n      return new PlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n    }\n\n    return ToTemporalTime(item, overflow);\n  }\n\n  static compare(oneParam, twoParam) {\n    const one = ToTemporalTime(oneParam);\n    const two = ToTemporalTime(twoParam);\n\n    for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n      const val1 = GetSlot(one, slot);\n      const val2 = GetSlot(two, slot);\n      if (val1 !== val2) return ComparisonResult(val1 - val2);\n    }\n\n    return 0;\n  }\n\n}\n\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n\nclass TimeZone {\n  constructor(timeZoneIdentifierParam) {\n    // Note: if the argument is not passed, GetCanonicalTimeZoneIdentifier(undefined) will throw.\n    //       This check exists only to improve the error message.\n    if (arguments.length < 1) {\n      throw new RangeError('missing argument: identifier is required');\n    }\n\n    const timeZoneIdentifier = GetCanonicalTimeZoneIdentifier(timeZoneIdentifierParam);\n    CreateSlots(this);\n    SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);\n    {\n      Object.defineProperty(this, '_repr_', {\n        value: `${this[Symbol.toStringTag]} <${timeZoneIdentifier}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  get id() {\n    if (!IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return ToString(this);\n  }\n\n  getOffsetNanosecondsFor(instantParam) {\n    if (!IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const instant = ToTemporalInstant(instantParam);\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    if (TestTimeZoneOffsetString(id)) {\n      return ParseTimeZoneOffsetString(id);\n    }\n\n    return GetIANATimeZoneOffsetNanoseconds(GetSlot(instant, EPOCHNANOSECONDS), id);\n  }\n\n  getOffsetStringFor(instantParam) {\n    if (!IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const instant = ToTemporalInstant(instantParam);\n    return BuiltinTimeZoneGetOffsetStringFor(this, instant);\n  }\n\n  getPlainDateTimeFor(instantParam, calendarParam = GetISO8601Calendar()) {\n    const instant = ToTemporalInstant(instantParam);\n    const calendar = ToTemporalCalendar(calendarParam);\n    return BuiltinTimeZoneGetPlainDateTimeFor(this, instant, calendar);\n  }\n\n  getInstantFor(dateTimeParam, optionsParam = undefined) {\n    if (!IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const dateTime = ToTemporalDateTime(dateTimeParam);\n    const options = GetOptionsObject(optionsParam);\n    const disambiguation = ToTemporalDisambiguation(options);\n    return BuiltinTimeZoneGetInstantFor(this, dateTime, disambiguation);\n  }\n\n  getPossibleInstantsFor(dateTimeParam) {\n    if (!IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const dateTime = ToTemporalDateTime(dateTimeParam);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    const id = GetSlot(this, TIMEZONE_ID);\n\n    if (TestTimeZoneOffsetString(id)) {\n      const epochNs = GetEpochFromISOParts(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n      if (epochNs === null) throw new RangeError('DateTime outside of supported range');\n      const offsetNs = ParseTimeZoneOffsetString(id);\n      return [new Instant(JSBI.subtract(epochNs, JSBI.BigInt(offsetNs)))];\n    }\n\n    const possibleEpochNs = GetIANATimeZoneEpochValue(id, GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n    return possibleEpochNs.map(ns => new Instant(ns));\n  }\n\n  getNextTransition(startingPointParam) {\n    if (!IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const startingPoint = ToTemporalInstant(startingPointParam);\n    const id = GetSlot(this, TIMEZONE_ID); // Offset time zones or UTC have no transitions\n\n    if (TestTimeZoneOffsetString(id) || id === 'UTC') {\n      return null;\n    }\n\n    let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    epochNanoseconds = GetIANATimeZoneNextTransition(epochNanoseconds, id);\n    return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n  }\n\n  getPreviousTransition(startingPointParam) {\n    if (!IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    const startingPoint = ToTemporalInstant(startingPointParam);\n    const id = GetSlot(this, TIMEZONE_ID); // Offset time zones or UTC have no transitions\n\n    if (TestTimeZoneOffsetString(id) || id === 'UTC') {\n      return null;\n    }\n\n    let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    epochNanoseconds = GetIANATimeZonePreviousTransition(epochNanoseconds, id);\n    return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n  }\n\n  toString() {\n    if (!IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return ToString(GetSlot(this, TIMEZONE_ID));\n  }\n\n  toJSON() {\n    if (!IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n    return ToString(this);\n  }\n\n  static from(item) {\n    return ToTemporalTimeZone(item);\n  }\n\n}\n\nMakeIntrinsicClass(TimeZone, 'Temporal.TimeZone');\nconst ObjectCreate = Object.create;\nconst DISALLOWED_UNITS = ['week', 'day', 'hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'];\n\nclass PlainYearMonth {\n  constructor(isoYearParam, isoMonthParam, calendarParam = GetISO8601Calendar(), referenceISODayParam = 1) {\n    const isoYear = ToIntegerThrowOnInfinity(isoYearParam);\n    const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);\n    const calendar = ToTemporalCalendar(calendarParam);\n    const referenceISODay = ToIntegerThrowOnInfinity(referenceISODayParam); // Note: if the arguments are not passed,\n    //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n    //       be rejected by RejectISODate in CreateTemporalYearMonthSlots. This\n    //       check exists only to improve the error message.\n\n    if (arguments.length < 2) {\n      throw new RangeError('missing argument: isoYear and isoMonth are required');\n    }\n\n    CreateTemporalYearMonthSlots(this, isoYear, isoMonth, calendar, referenceISODay);\n  }\n\n  get year() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return CalendarYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get month() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return CalendarMonth(GetSlot(this, CALENDAR), this);\n  }\n\n  get monthCode() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return CalendarMonthCode(GetSlot(this, CALENDAR), this);\n  }\n\n  get calendar() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR);\n  }\n\n  get era() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return CalendarEra(GetSlot(this, CALENDAR), this);\n  }\n\n  get eraYear() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return CalendarEraYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get daysInMonth() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n  }\n\n  get daysInYear() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get monthsInYear() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n  }\n\n  get inLeapYear() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n  }\n\n  with(temporalYearMonthLike, optionsParam = undefined) {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n\n    if (!IsObject(temporalYearMonthLike)) {\n      throw new TypeError('invalid argument');\n    }\n\n    RejectObjectWithCalendarOrTimeZone(temporalYearMonthLike);\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year']);\n    const props = ToPartialRecord(temporalYearMonthLike, fieldNames);\n\n    if (!props) {\n      throw new TypeError('invalid year-month-like');\n    }\n\n    let fields = ToTemporalYearMonthFields(this, fieldNames);\n    fields = CalendarMergeFields(calendar, fields, props);\n    fields = ToTemporalYearMonthFields(fields, fieldNames);\n    const options = GetOptionsObject(optionsParam);\n    return YearMonthFromFields(calendar, fields, options);\n  }\n\n  add(temporalDurationLike, optionsParam = undefined) {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    const duration = ToLimitedTemporalDuration(temporalDurationLike);\n    let {\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = duration;\n    ({\n      days\n    } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n    const options = GetOptionsObject(optionsParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n    const fields = ToTemporalYearMonthFields(this, fieldNames);\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const day = sign < 0 ? ToPositiveInteger(CalendarDaysInMonth(calendar, this)) : 1;\n    const startDate = DateFromFields(calendar, { ...fields,\n      day\n    });\n    const optionsCopy = { ...options\n    };\n    const addedDate = CalendarDateAdd(calendar, startDate, { ...duration,\n      days\n    }, options);\n    const addedDateFields = ToTemporalYearMonthFields(addedDate, fieldNames);\n    return YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n  }\n\n  subtract(temporalDurationLike, optionsParam = undefined) {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    let duration = ToLimitedTemporalDuration(temporalDurationLike);\n    duration = {\n      years: -duration.years,\n      months: -duration.months,\n      weeks: -duration.weeks,\n      days: -duration.days,\n      hours: -duration.hours,\n      minutes: -duration.minutes,\n      seconds: -duration.seconds,\n      milliseconds: -duration.milliseconds,\n      microseconds: -duration.microseconds,\n      nanoseconds: -duration.nanoseconds\n    };\n    let {\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = duration;\n    ({\n      days\n    } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n    const options = GetOptionsObject(optionsParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n    const fields = ToTemporalYearMonthFields(this, fieldNames);\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const day = sign < 0 ? ToPositiveInteger(CalendarDaysInMonth(calendar, this)) : 1;\n    const startDate = DateFromFields(calendar, { ...fields,\n      day\n    });\n    const optionsCopy = { ...options\n    };\n    const addedDate = CalendarDateAdd(calendar, startDate, { ...duration,\n      days\n    }, options);\n    const addedDateFields = ToTemporalYearMonthFields(addedDate, fieldNames);\n    return YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n  }\n\n  until(otherParam, optionsParam = undefined) {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalYearMonth(otherParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarID = ToString(calendar);\n    const otherCalendarID = ToString(otherCalendar);\n\n    if (calendarID !== otherCalendarID) {\n      throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n    }\n\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n    const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n    const otherFields = ToTemporalYearMonthFields(other, fieldNames);\n    const thisFields = ToTemporalYearMonthFields(this, fieldNames);\n    const otherDate = DateFromFields(calendar, { ...otherFields,\n      day: 1\n    });\n    const thisDate = DateFromFields(calendar, { ...thisFields,\n      day: 1\n    });\n    const untilOptions = { ...options,\n      largestUnit\n    };\n    const result = CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n    if (smallestUnit === 'month' && roundingIncrement === 1) return result;\n    let {\n      years,\n      months\n    } = result;\n    ({\n      years,\n      months\n    } = RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, thisDate));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(years, months, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n\n  since(otherParam, optionsParam = undefined) {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalYearMonth(otherParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarID = ToString(calendar);\n    const otherCalendarID = ToString(otherCalendar);\n\n    if (calendarID !== otherCalendarID) {\n      throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n    }\n\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n    const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n    const otherFields = ToTemporalYearMonthFields(other, fieldNames);\n    const thisFields = ToTemporalYearMonthFields(this, fieldNames);\n    const otherDate = DateFromFields(calendar, { ...otherFields,\n      day: 1\n    });\n    const thisDate = DateFromFields(calendar, { ...thisFields,\n      day: 1\n    });\n    const untilOptions = { ...options,\n      largestUnit\n    };\n    let {\n      years,\n      months\n    } = CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n\n    if (smallestUnit === 'month' && roundingIncrement === 1) {\n      return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n\n    ({\n      years,\n      months\n    } = RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), thisDate));\n    return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n\n  equals(otherParam) {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalYearMonth(otherParam);\n\n    for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n      const val1 = GetSlot(this, slot);\n      const val2 = GetSlot(other, slot);\n      if (val1 !== val2) return false;\n    }\n\n    return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n\n  toString(optionsParam = undefined) {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    const options = GetOptionsObject(optionsParam);\n    const showCalendar = ToShowCalendarOption(options);\n    return TemporalYearMonthToString(this, showCalendar);\n  }\n\n  toJSON() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return TemporalYearMonthToString(this);\n  }\n\n  toLocaleString(locales = undefined, options = undefined) {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n\n  valueOf() {\n    throw new TypeError('use compare() or equals() to compare Temporal.PlainYearMonth');\n  }\n\n  toPlainDate(item) {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    if (!IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n    const receiverFieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n    const fields = ToTemporalYearMonthFields(this, receiverFieldNames);\n    const inputFieldNames = CalendarFields(calendar, ['day']);\n    const inputEntries = [['day']]; // Add extra fields from the calendar at the end\n\n    inputFieldNames.forEach(fieldName => {\n      if (!inputEntries.some(([name]) => name === fieldName)) {\n        inputEntries.push([fieldName, undefined]); // Make TS ignore extra fields\n      }\n    });\n    const inputFields = PrepareTemporalFields(item, inputEntries);\n    let mergedFields = CalendarMergeFields(calendar, fields, inputFields);\n    const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n    const mergedEntries = [];\n    mergedFieldNames.forEach(fieldName => {\n      if (!mergedEntries.some(([name]) => name === fieldName)) {\n        mergedEntries.push([fieldName, undefined]);\n      }\n    });\n    mergedFields = PrepareTemporalFields(mergedFields, mergedEntries);\n    const options = ObjectCreate(null);\n    options.overflow = 'reject';\n    return DateFromFields(calendar, mergedFields, options);\n  }\n\n  getISOFields() {\n    if (!IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(this, ISO_DAY),\n      isoMonth: GetSlot(this, ISO_MONTH),\n      isoYear: GetSlot(this, ISO_YEAR)\n    };\n  }\n\n  static from(item, optionsParam = undefined) {\n    const options = GetOptionsObject(optionsParam);\n\n    if (IsTemporalYearMonth(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n\n      return CreateTemporalYearMonth(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, CALENDAR), GetSlot(item, ISO_DAY));\n    }\n\n    return ToTemporalYearMonth(item, options);\n  }\n\n  static compare(oneParam, twoParam) {\n    const one = ToTemporalYearMonth(oneParam);\n    const two = ToTemporalYearMonth(twoParam);\n    return CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n  }\n\n}\n\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\nconst ArrayPrototypePush = Array.prototype.push;\n\nclass ZonedDateTime {\n  constructor(epochNanosecondsParam, timeZoneParam, calendarParam = GetISO8601Calendar()) {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    //       ToTemporalTimeZone(undefined) will end up calling TimeZone.from(\"undefined\"), which\n    //       could succeed.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n\n    const epochNanoseconds = ToBigInt(epochNanosecondsParam);\n    const timeZone = ToTemporalTimeZone(timeZoneParam);\n    const calendar = ToTemporalCalendar(calendarParam);\n    CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n  }\n\n  get calendar() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, CALENDAR);\n  }\n\n  get timeZone() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(this, TIME_ZONE);\n  }\n\n  get year() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get month() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarMonth(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get monthCode() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarMonthCode(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get day() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDay(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get hour() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_HOUR);\n  }\n\n  get minute() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MINUTE);\n  }\n\n  get second() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_SECOND);\n  }\n\n  get millisecond() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MILLISECOND);\n  }\n\n  get microsecond() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_MICROSECOND);\n  }\n\n  get nanosecond() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetSlot(dateTime(this), ISO_NANOSECOND);\n  }\n\n  get era() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarEra(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get eraYear() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarEraYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get epochSeconds() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(JSBI.divide(value, BILLION));\n  }\n\n  get epochMilliseconds() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return JSBI.toNumber(JSBI.divide(value, MILLION));\n  }\n\n  get epochMicroseconds() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return ToBigIntExternal(JSBI.divide(value, THOUSAND));\n  }\n\n  get epochNanoseconds() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n  }\n\n  get dayOfWeek() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDayOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get dayOfYear() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDayOfYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get weekOfYear() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarWeekOfYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get hoursInDay() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const year = GetSlot(dt, ISO_YEAR);\n    const month = GetSlot(dt, ISO_MONTH);\n    const day = GetSlot(dt, ISO_DAY);\n    const today = new DateTime(year, month, day, 0, 0, 0, 0, 0, 0);\n    const tomorrowFields = AddISODate(year, month, day, 0, 0, 0, 1, 'reject');\n    const tomorrow = new DateTime(tomorrowFields.year, tomorrowFields.month, tomorrowFields.day, 0, 0, 0, 0, 0, 0);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const todayNs = GetSlot(BuiltinTimeZoneGetInstantFor(timeZone, today, 'compatible'), EPOCHNANOSECONDS);\n    const tomorrowNs = GetSlot(BuiltinTimeZoneGetInstantFor(timeZone, tomorrow, 'compatible'), EPOCHNANOSECONDS);\n    return JSBI.toNumber(JSBI.subtract(tomorrowNs, todayNs)) / 3.6e12;\n  }\n\n  get daysInWeek() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDaysInWeek(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get daysInMonth() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDaysInMonth(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get daysInYear() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarDaysInYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get monthsInYear() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarMonthsInYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get inLeapYear() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return CalendarInLeapYear(GetSlot(this, CALENDAR), dateTime(this));\n  }\n\n  get offset() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return BuiltinTimeZoneGetOffsetStringFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n  }\n\n  get offsetNanoseconds() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n  }\n\n  with(temporalZonedDateTimeLike, optionsParam = undefined) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n\n    if (!IsObject(temporalZonedDateTimeLike)) {\n      throw new TypeError('invalid zoned-date-time-like');\n    }\n\n    RejectObjectWithCalendarOrTimeZone(temporalZonedDateTimeLike);\n    const options = GetOptionsObject(optionsParam);\n    const disambiguation = ToTemporalDisambiguation(options);\n    const offset = ToTemporalOffset(options, 'prefer');\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['day', 'hour', 'microsecond', 'millisecond', 'minute', 'month', 'monthCode', 'nanosecond', 'second', 'year']);\n    ArrayPrototypePush.call(fieldNames, 'offset');\n    const props = ToPartialRecord(temporalZonedDateTimeLike, fieldNames);\n\n    if (!props) {\n      throw new TypeError('invalid zoned-date-time-like');\n    } // Unlike ToTemporalZonedDateTimeFields, the offset property will be required.\n\n\n    const entries = [['day', undefined], ['hour', 0], ['microsecond', 0], ['millisecond', 0], ['minute', 0], ['month', undefined], ['monthCode', undefined], ['nanosecond', 0], ['second', 0], ['year', undefined], ['offset'], ['timeZone']]; // Add extra fields from the calendar at the end\n\n    fieldNames.forEach(fieldName => {\n      if (!entries.some(([name]) => name === fieldName)) {\n        entries.push([fieldName, undefined]);\n      }\n    });\n    let fields = PrepareTemporalFields(this, entries);\n    fields = CalendarMergeFields(calendar, fields, props);\n    fields = PrepareTemporalFields(fields, entries);\n    const {\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = InterpretTemporalDateTimeFields(calendar, fields, options);\n    const offsetNs = ParseTimeZoneOffsetString(fields.offset);\n    const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, disambiguation, offset,\n    /* matchMinute = */\n    false);\n    return CreateTemporalZonedDateTime(epochNanoseconds, GetSlot(this, TIME_ZONE), calendar);\n  }\n\n  withPlainDate(temporalDateParam) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const temporalDate = ToTemporalDate(temporalDateParam);\n    const year = GetSlot(temporalDate, ISO_YEAR);\n    const month = GetSlot(temporalDate, ISO_MONTH);\n    const day = GetSlot(temporalDate, ISO_DAY);\n    let calendar = GetSlot(temporalDate, CALENDAR);\n    const thisDt = dateTime(this);\n    const hour = GetSlot(thisDt, ISO_HOUR);\n    const minute = GetSlot(thisDt, ISO_MINUTE);\n    const second = GetSlot(thisDt, ISO_SECOND);\n    const millisecond = GetSlot(thisDt, ISO_MILLISECOND);\n    const microsecond = GetSlot(thisDt, ISO_MICROSECOND);\n    const nanosecond = GetSlot(thisDt, ISO_NANOSECOND);\n    calendar = ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n    return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n\n  withPlainTime(temporalTimeParam = undefined) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n    const temporalTime = temporalTimeParam == undefined ? new PlainTime() : ToTemporalTime(temporalTimeParam);\n    const thisDt = dateTime(this);\n    const year = GetSlot(thisDt, ISO_YEAR);\n    const month = GetSlot(thisDt, ISO_MONTH);\n    const day = GetSlot(thisDt, ISO_DAY);\n    const calendar = GetSlot(this, CALENDAR);\n    const hour = GetSlot(temporalTime, ISO_HOUR);\n    const minute = GetSlot(temporalTime, ISO_MINUTE);\n    const second = GetSlot(temporalTime, ISO_SECOND);\n    const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n    return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n\n  withTimeZone(timeZoneParam) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const timeZone = ToTemporalTimeZone(timeZoneParam);\n    return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n  }\n\n  withCalendar(calendarParam) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = ToTemporalCalendar(calendarParam);\n    return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n  }\n\n  add(temporalDurationLike, optionsParam = undefined) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const duration = ToLimitedTemporalDuration(temporalDurationLike);\n    const {\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = duration;\n    const options = GetOptionsObject(optionsParam);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const calendar = GetSlot(this, CALENDAR);\n    const epochNanoseconds = AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n  }\n\n  subtract(temporalDurationLike, optionsParam = undefined) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const duration = ToLimitedTemporalDuration(temporalDurationLike);\n    const {\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds\n    } = duration;\n    const options = GetOptionsObject(optionsParam);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const calendar = GetSlot(this, CALENDAR);\n    const epochNanoseconds = AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n  }\n\n  until(otherParam, optionsParam = undefined) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalZonedDateTime(otherParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarId = ToString(calendar);\n    const otherCalendarId = ToString(otherCalendar);\n\n    if (calendarId !== otherCalendarId) {\n      throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n    }\n\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('hour', smallestUnit);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n    const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n    const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n\n    if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n      // The user is only asking for a time difference, so return difference of instants.\n      years = 0;\n      months = 0;\n      weeks = 0;\n      days = 0;\n      ({\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n      ({\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    } else {\n      const timeZone = GetSlot(this, TIME_ZONE);\n\n      if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n        throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" + 'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n      }\n\n      const untilOptions = { ...options,\n        largestUnit\n      };\n      ({\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n      ({\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n      ({\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n    }\n\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n\n  since(otherParam, optionsParam = undefined) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalZonedDateTime(otherParam);\n    const calendar = GetSlot(this, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarId = ToString(calendar);\n    const otherCalendarId = ToString(otherCalendar);\n\n    if (calendarId !== otherCalendarId) {\n      throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n    }\n\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, 'nanosecond');\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('hour', smallestUnit);\n    const largestUnit = ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n    ValidateTemporalUnitRange(largestUnit, smallestUnit);\n    let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    roundingMode = NegateTemporalRoundingMode(roundingMode);\n    const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n    const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n    const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n\n    if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n      // The user is only asking for a time difference, so return difference of instants.\n      years = 0;\n      months = 0;\n      weeks = 0;\n      days = 0;\n      ({\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n      ({\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    } else {\n      const timeZone = GetSlot(this, TIME_ZONE);\n\n      if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n        throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" + 'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n      }\n\n      const untilOptions = { ...options,\n        largestUnit\n      };\n      ({\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n      ({\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n      ({\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds\n      } = AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n    }\n\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n  }\n\n  round(optionsParam) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    if (optionsParam === undefined) throw new TypeError('options parameter is required');\n    const options = typeof optionsParam === 'string' ? CreateOnePropObject('smallestUnit', optionsParam) : GetOptionsObject(optionsParam);\n    const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n    if (smallestUnit === undefined) throw new RangeError('smallestUnit is required');\n    const roundingMode = ToTemporalRoundingMode(options, 'halfExpand');\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false); // first, round the underlying DateTime fields\n\n    const dt = dateTime(this);\n    let year = GetSlot(dt, ISO_YEAR);\n    let month = GetSlot(dt, ISO_MONTH);\n    let day = GetSlot(dt, ISO_DAY);\n    let hour = GetSlot(dt, ISO_HOUR);\n    let minute = GetSlot(dt, ISO_MINUTE);\n    let second = GetSlot(dt, ISO_SECOND);\n    let millisecond = GetSlot(dt, ISO_MILLISECOND);\n    let microsecond = GetSlot(dt, ISO_MICROSECOND);\n    let nanosecond = GetSlot(dt, ISO_NANOSECOND);\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const calendar = GetSlot(this, CALENDAR);\n    const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0);\n    const instantStart = BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n    const endNs = AddZonedDateTime(instantStart, timeZone, calendar, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);\n    const dayLengthNs = JSBI.subtract(endNs, JSBI.BigInt(GetSlot(instantStart, EPOCHNANOSECONDS)));\n\n    if (JSBI.equal(dayLengthNs, ZERO)) {\n      throw new RangeError('cannot round a ZonedDateTime in a calendar with zero-length days');\n    }\n\n    ({\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond\n    } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode, // Days are guaranteed to be shorter than Number.MAX_SAFE_INTEGER\n    // (which can hold up to 104 days in nanoseconds)\n    JSBI.toNumber(dayLengthNs))); // Now reset all DateTime fields but leave the TimeZone. The offset will\n    // also be retained if the new date/time values are still OK with the old\n    // offset. Otherwise the offset will be changed to be compatible with the\n    // new date/time values. If DST disambiguation is required, the `compatible`\n    // disambiguation algorithm will be used.\n\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, GetSlot(this, INSTANT));\n    const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, 'compatible', 'prefer',\n    /* matchMinute = */\n    false);\n    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n  }\n\n  equals(otherParam) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const other = ToTemporalZonedDateTime(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    if (!JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two))) return false;\n    if (!TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE))) return false;\n    return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n\n  toString(optionsParam = undefined) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const options = GetOptionsObject(optionsParam);\n    const {\n      precision,\n      unit,\n      increment\n    } = ToSecondsStringPrecision(options);\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const showCalendar = ToShowCalendarOption(options);\n    const showTimeZone = ToShowTimeZoneNameOption(options);\n    const showOffset = ToShowOffsetOption(options);\n    return TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n      unit,\n      increment,\n      roundingMode\n    });\n  }\n\n  toLocaleString(locales = undefined, options = undefined) {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return new DateTimeFormat(locales, options).format(this);\n  }\n\n  toJSON() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return TemporalZonedDateTimeToString(this, 'auto');\n  }\n\n  valueOf() {\n    throw new TypeError('use compare() or equals() to compare Temporal.ZonedDateTime');\n  }\n\n  startOfDay() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const calendar = GetSlot(this, CALENDAR);\n    const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0, calendar);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const instant = BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n    return CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n  }\n\n  toInstant() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n  }\n\n  toPlainDate() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return TemporalDateTimeToDate(dateTime(this));\n  }\n\n  toPlainTime() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return TemporalDateTimeToTime(dateTime(this));\n  }\n\n  toPlainDateTime() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    return dateTime(this);\n  }\n\n  toPlainYearMonth() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n    const fields = ToTemporalYearMonthFields(this, fieldNames);\n    return YearMonthFromFields(calendar, fields);\n  }\n\n  toPlainMonthDay() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const calendar = GetSlot(this, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['day', 'monthCode']);\n    const fields = ToTemporalMonthDayFields(this, fieldNames);\n    return MonthDayFromFields(calendar, fields);\n  }\n\n  getISOFields() {\n    if (!IsTemporalZonedDateTime(this)) throw new TypeError('invalid receiver');\n    const dt = dateTime(this);\n    const tz = GetSlot(this, TIME_ZONE);\n    return {\n      calendar: GetSlot(this, CALENDAR),\n      isoDay: GetSlot(dt, ISO_DAY),\n      isoHour: GetSlot(dt, ISO_HOUR),\n      isoMicrosecond: GetSlot(dt, ISO_MICROSECOND),\n      isoMillisecond: GetSlot(dt, ISO_MILLISECOND),\n      isoMinute: GetSlot(dt, ISO_MINUTE),\n      isoMonth: GetSlot(dt, ISO_MONTH),\n      isoNanosecond: GetSlot(dt, ISO_NANOSECOND),\n      isoSecond: GetSlot(dt, ISO_SECOND),\n      isoYear: GetSlot(dt, ISO_YEAR),\n      offset: BuiltinTimeZoneGetOffsetStringFor(tz, GetSlot(this, INSTANT)),\n      timeZone: tz\n    };\n  }\n\n  static from(item, optionsParam = undefined) {\n    const options = GetOptionsObject(optionsParam);\n\n    if (IsTemporalZonedDateTime(item)) {\n      ToTemporalOverflow(options); // validate and ignore\n\n      ToTemporalDisambiguation(options);\n      ToTemporalOffset(options, 'reject');\n      return CreateTemporalZonedDateTime(GetSlot(item, EPOCHNANOSECONDS), GetSlot(item, TIME_ZONE), GetSlot(item, CALENDAR));\n    }\n\n    return ToTemporalZonedDateTime(item, options);\n  }\n\n  static compare(oneParam, twoParam) {\n    const one = ToTemporalZonedDateTime(oneParam);\n    const two = ToTemporalZonedDateTime(twoParam);\n    const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n    const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return -1;\n    if (JSBI.greaterThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return 1;\n    return 0;\n  }\n\n}\n\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\n\nfunction dateTime(zdt) {\n  return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, INSTANT), GetSlot(zdt, CALENDAR));\n}\n\nvar temporal = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Instant: Instant,\n  Calendar: Calendar,\n  PlainDate: PlainDate,\n  PlainDateTime: PlainDateTime,\n  Duration: Duration,\n  PlainMonthDay: PlainMonthDay,\n  Now: Now,\n  PlainTime: PlainTime,\n  TimeZone: TimeZone,\n  PlainYearMonth: PlainYearMonth,\n  ZonedDateTime: ZonedDateTime\n});\n\nfunction toTemporalInstant() {\n  // Observable access to valueOf is not correct here, but unavoidable\n  const epochNanoseconds = JSBI.multiply(JSBI.BigInt(+this), MILLION);\n  return new Instant(ToBigInt(epochNanoseconds));\n} // This entry point treats Temporal as a library, and does not polyfill it onto\n// Work around https://github.com/babel/babel/issues/2025.\n\n\nconst types = [Instant, Calendar, PlainDate, PlainDateTime, Duration, PlainMonthDay, // Temporal.Now, // plain object (not a constructor), so no `prototype`\nPlainTime, TimeZone, PlainYearMonth, ZonedDateTime];\n\nfor (const type of types) {\n  const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype');\n\n  if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n    descriptor.configurable = false;\n    descriptor.enumerable = false;\n    descriptor.writable = false;\n    Object.defineProperty(type, 'prototype', descriptor);\n  }\n}\n\nexport { intl as Intl, temporal as Temporal, toTemporalInstant }; //# sourceMappingURL=index.esm.js.map","map":null,"metadata":{},"sourceType":"module"}