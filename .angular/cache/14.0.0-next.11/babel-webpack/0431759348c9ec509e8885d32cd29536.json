{"ast":null,"code":"var _JwtService_instances, _JwtService_handleLogin, _JwtService_decodeToken;\n\nimport { __classPrivateFieldGet } from \"tslib\"; // eslint-disable-next-line @typescript-eslint/consistent-type-imports\n\nimport { HttpErrorResponse, HttpHeaders } from '@angular/common/http';\nimport { catchError, first, map } from 'rxjs/operators';\nimport { Temporal } from '@js-temporal/polyfill';\nimport log from 'loglevel';\nimport { of } from 'rxjs';\nimport { paths } from '../shared';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./storage.service\";\nexport class JwtService {\n  constructor(httpClient, storageService) {\n    this.httpClient = httpClient;\n    this.storageService = storageService;\n\n    _JwtService_instances.add(this);\n\n    log.debug('JwtService.constructor()');\n  }\n\n  login(username, password) {\n    const loginPath = paths.login;\n    log.debug('JwtService.login: loginPath=', loginPath);\n    /* eslint-disable @typescript-eslint/naming-convention */\n\n    const headers = new HttpHeaders({\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Accept: 'text/plain'\n    });\n    /* eslint-enable @typescript-eslint/naming-convention */\n\n    return this.httpClient.post(loginPath, `username=${username}&password=${password}`, {\n      headers,\n      observe: 'response',\n      responseType: 'json'\n    }).pipe( // den 1. Datensatz empfangen und danach implizites \"unsubscribe\"\n    first(), catchError(err => {\n      log.debug('JwtService.login: err=', err); // z.B. Statuscode 401 (Unauthorized) oder 504 (Gateway Timeout)\n\n      return of(err);\n    }), map(result => __classPrivateFieldGet(this, _JwtService_instances, \"m\", _JwtService_handleLogin).call(this, result)));\n  }\n\n}\n_JwtService_instances = new WeakSet(), _JwtService_handleLogin = function _JwtService_handleLogin(result) {\n  if (result instanceof HttpErrorResponse) {\n    log.error('JwtService.login: result=', result); // TODO Fehlerbehandlung fuer falsche Logindaten\n\n    return;\n  }\n\n  const {\n    status,\n    ok,\n    body\n  } = result;\n  log.debug('JwtService.login: status=', status);\n  log.debug('JwtService.login: body', body);\n\n  if (!ok || body === null) {\n    const {\n      statusText\n    } = result;\n    log.error('JwtService.login: statusText', statusText);\n    return;\n  }\n\n  const {\n    token,\n    roles\n  } = body;\n  const authorization = `Bearer ${token}`;\n  log.debug('JwtService.login: authorization=', authorization);\n\n  const decodedToken = __classPrivateFieldGet(this, _JwtService_instances, \"m\", _JwtService_decodeToken).call(this, token); // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n\n\n  log.debug('JwtService.login: decodedToken', decodedToken);\n\n  if (decodedToken.exp === undefined) {\n    log.warn('JwtService.login: exp fehlt');\n    return;\n  } // Expiration beim Token: Sekunden seit 1.1.1970 UTC\n  // Cookie: Millisekunden in eigener Zeitzone\n\n\n  const expiration = decodedToken.exp * JwtService.MILLIS_PER_SECOND + JwtService.TIMEZONE_OFFSET_MS;\n  log.debug('JwtService.login: expiration=', expiration);\n  this.storageService.saveAuthorization(authorization, roles, expiration);\n  return roles;\n}, _JwtService_decodeToken = function _JwtService_decodeToken(token) {\n  var _a; // Destructuring\n\n\n  const [, payload, signature] = token.split('.');\n\n  if (signature === undefined) {\n    log.error('JwtService.#decodeToken: JWT enthaelt keine Signature');\n    return;\n  }\n\n  let base64Token = (_a = payload === null || payload === void 0 ? void 0 : payload.replace(/-/gu, '+')) === null || _a === void 0 ? void 0 : _a.replace(/_/gu, '/');\n\n  if (base64Token === undefined) {\n    return Promise.reject(new Error('Interner Fehler beim Einloggen'));\n  }\n  /* eslint-disable @typescript-eslint/no-magic-numbers */\n\n\n  switch (base64Token.length % 4) {\n    case 0:\n      break;\n\n    case 2:\n      base64Token += '==';\n      break;\n\n    case 3:\n      base64Token += '=';\n      break;\n\n    default:\n      log.error('JwtService.#decodeToken: Laenge des JWT in Base64 ist falsch.');\n      return;\n  }\n  /* eslint-enable @typescript-eslint/no-magic-numbers */\n  // http://xkr.us/articles/javascript/encode-compare\n  // http://stackoverflow.com/questions/75980/when-are-you-supposed-to-use-escape-instead-of-encodeuri-encodeuricomponent#23842171\n\n\n  const decodedStr = decodeURIComponent(encodeURIComponent(window.atob(base64Token)));\n  return JSON.parse(decodedStr);\n};\nJwtService.NANOS_PER_MILLIS = 1000000;\nJwtService.MILLIS_PER_SECOND = 1000;\nJwtService.TIMEZONE_OFFSET_MS = Temporal.Now.timeZone().getOffsetNanosecondsFor(Temporal.Now.instant()) / JwtService.NANOS_PER_MILLIS;\n\nJwtService.ɵfac = function JwtService_Factory(t) {\n  return new (t || JwtService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.StorageService));\n};\n\nJwtService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: JwtService,\n  factory: JwtService.ɵfac,\n  providedIn: 'root'\n});","map":null,"metadata":{},"sourceType":"module"}